{"postmanCollection":{"filePaths":["/var/tmp/Roost/RoostGPT/pw-api-openai-github-1763639890489/458a3327-63a1-4cdb-bea8-38de438a6be3/source/api-spec/postman_collections/pw-api-openai-github-1763639890489/swagger/roost_postman_swagger_1763640455.json"]},"headBranch":"roost-458a3327-63a1-4cdb-bea8-38de438a6be3","reportHeadBranch":"roost-report","aiUsage":{"promptTokens":36856,"completionTokens":15411,"apiCallsToAI":36},"repoPath":"/var/tmp/Roost/RoostGPT/pw-api-openai-github-1763639890489/458a3327-63a1-4cdb-bea8-38de438a6be3/source/api-spec","errorMsg":"","gitPrUrl":"","status":"","statusDetails":"","coverageReportURL":{},"testReportURL":{},"testMetrics":{"filesScanned":1,"totalFiles":1,"totalTestFiles":37,"successfulTests":37,"testWithCompilationErrors":0,"skippedMethods":0,"toBeProcessed":0,"testswithRunTimeErrors":0,"existingTestPresent":0,"notSupported":0,"methodsScanned":37,"methodsSuccess":37},"advancedDetails":{"credential-register/swagger_server/swagger/swagger.yaml":{"submitRequest":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/Submit_Request.json","feedback":[],"name":"Submit Request","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for submitRequest for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"submitRequest_POST_532a3877ae","jsonData":"[\n  {\n    \"value_object\": {\n      \"id\": 123,\n      \"name\": \"Test Object 1\",\n      \"description\": \"This is a test object\"\n    },\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"value_object\": {\n      \"id\": 456,\n      \"name\": \"Test Object 2\",\n      \"description\": \"This is another test object\"\n    },\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"value_object\": {\n      \"id\": \"invalid_id\",\n      \"name\": \"Test Object 3\",\n      \"description\": \"This is a test object with invalid id\"\n    },\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"value_object\": {\n      \"name\": \"Test Object 4\",\n      \"description\": \"This is a test object with missing id\"\n    },\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"value_object\": {\n      \"id\": 789,\n      \"name\": \"Test Object 5\",\n      \"description\": \"This is a test object with non-existent id\"\n    },\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"value_object\": {\n      \"id\": 1011,\n      \"name\": \"Test Object 6\",\n      \"description\": \"This is a test object with unauthorized access\"\n    },\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  }\n]"}},"authToken":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"","feedback":[],"name":"AuthToken","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for authToken for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful login\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: token\n\n        pm.test(`'responseData field has token that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`token`)) {\n            const value = responseData?.token;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"authToken_POST_ea9d3d413d"}},"deposit":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/Deposit.json","feedback":[],"name":"Deposit","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deposit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Deposit success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"deposit_POST_615681a608","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"sourceAccountId_*string\": \"1042345\",\n    \"amount_*string\": \"1042222\",\n    \"currency_*string\": \"USD\",\n    \"statusCode\": 200,\n    \"scenario\": \"Deposit success\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"sourceAccountId_*string\": \"1042346\",\n    \"amount_*string\": \"1042223\",\n    \"currency_*string\": \"EUR\",\n    \"image\": {\n      \"frontImage_*string\": \"front_image_1\",\n      \"backImage_*string\": \"back_image_1\"\n    },\n    \"statusCode\": 200,\n    \"scenario\": \"Deposit success\"\n  },\n  {\n    \"sourceAccountId_*string\": \"1042347\",\n    \"amount_*string\": \"1042224\",\n    \"currency_*string\": \"GBP\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"sourceAccountId_*string\": \"1042348\",\n    \"amount_*string\": \"1042225\",\n    \"currency_*string\": \"JPY\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"sourceAccountId_*string\": \"1042349\",\n    \"amount_*string\": \"1042226\",\n    \"currency_*string\": \"AUD\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"sourceAccountId_*string\": \"1042350\",\n    \"amount_*string\": \"1042227\",\n    \"currency_*string\": \"CAD\",\n    \"image\": {\n      \"frontImage_*string\": \"front_image_2\",\n      \"backImage_*string\": \"back_image_2\"\n    },\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"GetAccountInfo":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/GetAccountInfo.json","feedback":[],"name":"GetAccountInfo","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'accounts' as type array'`, function() {\n          const value = responseData?.accounts;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.accounts field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`accounts`)) {\n            let accountsArray = ld.get(responseData, `accounts`, []);\n            if (Array.isArray(accountsArray)) {\n              for (let accounts_it = 0; accounts_it < accountsArray.length; accounts_it++) {\n                let iterator = accounts_it;\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'customerId' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.customerId;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountNickname' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountNickname;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'activatedDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.activatedDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCash' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCash;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCashLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCashLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCredit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCredit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'bankName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.bankName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'branchName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.branchName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardStatus;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'creditLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.creditLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'currency' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.currency;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'currentBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.currentBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'deactivatedDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.deactivatedDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.dueAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.dueDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'earlyWithdrawalPenalty' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.earlyWithdrawalPenalty;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'email' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.email;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.expDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'fdType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.fdType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'image' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.image;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'interestRate' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.interestRate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'internalTransferFromEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.internalTransferFromEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'internalTransferToEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.internalTransferToEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isPrimaryMobile' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isPrimaryMobile;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isAlternateMobileNumber' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isAlternateMobileNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isStatement' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isStatement;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lastDrawDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.lastDrawDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'loanMaturityDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.loanMaturityDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'loanOriginationDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.loanOriginationDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'location' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.location;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lastUpdated' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.lastUpdated;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'maxTransactionLimit' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.maxTransactionLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'maturityDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.maturityDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'minimumPaymentDue' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.minimumPaymentDue;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'minimumBalance' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.minimumBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'monthlyPayment' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.monthlyPayment;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'openingBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.openingBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'originalLoanAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.originalLoanAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'P2PLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.P2PLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'p2pEnabled' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.p2pEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'paybillEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.paybillEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'payoffAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.payoffAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'personalBankerName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.personalBankerName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'personalBankerContact' as type 'object'`, function() {\n                    const value = accountsArray[iterator]?.personalBankerContact;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: accountsArray[${iterator}].personalBankerContact\n                  // subKey: email\n                  // array: accountsArray\n\n\n                  pm.test(`'accountsArray[${iterator}].personalBankerContact field has email that is of type string'`, function() {\n                    let parent = accountsArray[iterator].personalBankerContact;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`email`)) {\n                      const value = accountsArray[iterator].personalBankerContact?.email;\n                      console.log(`accountsArray[iterator].personalBankerContact?.email`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: accountsArray[${iterator}].personalBankerContact\n                  // subKey: mobileNumber\n                  // array: accountsArray\n\n\n                  pm.test(`'accountsArray[${iterator}].personalBankerContact field has mobileNumber that is of type string'`, function() {\n                    let parent = accountsArray[iterator].personalBankerContact;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n                      const value = accountsArray[iterator].personalBankerContact?.mobileNumber;\n                      console.log(`accountsArray[iterator].personalBankerContact?.mobileNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'phone' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.phone;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'postedBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.postedBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'principalBalance' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.principalBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'productCode' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.productCode;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'productName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.productName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'propertyAddress' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.propertyAddress;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'rewardPoints' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.rewardPoints;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'routingNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.routingNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'statementDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.statementDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'status' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.status;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'swiftCode' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.swiftCode;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.totalBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'unbilledAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.unbilledAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'valueAtMaturity' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.valueAtMaturity;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'holdAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.holdAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'unclearFundsAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.unclearFundsAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'averageMonthlyBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.averageMonthlyBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'netWithdrawableBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.netWithdrawableBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalTenure' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.totalTenure;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'remainingTenure' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.remainingTenure;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'debitAccountNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.debitAccountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lateFee' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.lateFee;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'bounceCharge' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.bounceCharge;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalCharges' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.totalCharges;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'overDueAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.overDueAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardDetails' as type array'`, function() {\n                    const value = accountsArray[iterator]?.cardDetails;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the accountsArray[${iterator}].cardDetails field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(accountsArray[iterator]).to.have.nested.property(`cardDetails`)) {\n                      let cardDetailsArray = ld.get(accountsArray[iterator], `cardDetails`, []);\n                      if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                          let iterator = cardDetails_it;\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardName;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardNumber;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardStatus;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardImage' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardImage;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardType;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.expDate;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'displayCardStatus' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.displayCardStatus;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'primaryCard' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.primaryCard;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardChannelInfo' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardChannelInfo;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: ATM\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has ATM that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`ATM`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.ATM;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.ATM`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: offline\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has offline that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`offline`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.offline;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.offline`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.offline?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.offline?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: international\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has international that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`international`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.international;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.international`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.international?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.international?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: online\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has online that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`online`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.online;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.online`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.online?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.online?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: contactless\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has contactless that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`contactless`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.contactless;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.contactless`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardRestrictions' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardRestrictions;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // array condition and parent property is not an array\n                            pm.test(`'Response has the `\n                              cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                              function() {\n                                if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                                  const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                                  if (value !== null && value !== undefined) {\n                                    pm.expect(Array.isArray(value)).to.equal(true);\n                                  }\n\n                                }\n                              })\n\n                            pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.countries field has all the required fields and correct data-types`, function() {\n                              if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`countries`)) {\n                                let countriesArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `countries`, []);\n                                if (Array.isArray(countriesArray)) {\n                                  for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                                    let iterator = countries_it;\n                                    if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at countriesArray[${iterator}]' has 'countrycode' as type 'string'`, function() {\n                                        const value = countriesArray[iterator]?.countrycode;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                  }\n                                }\n                              }\n                            })\n\n                            // array condition and parent property is not an array\n                            pm.test(`'Response has the `\n                              cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                              function() {\n                                if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                                  const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                                  if (value !== null && value !== undefined) {\n                                    pm.expect(Array.isArray(value)).to.equal(true);\n                                  }\n\n                                }\n                              })\n\n                            pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.MCC field has all the required fields and correct data-types`, function() {\n                              if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`MCC`)) {\n                                let MCCArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `MCC`, []);\n                                if (Array.isArray(MCCArray)) {\n                                  for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                                    let iterator = MCC_it;\n                                    if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at MCCArray[${iterator}]' has 'name' as type 'string'`, function() {\n                                        const value = MCCArray[iterator]?.name;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                    if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at MCCArray[${iterator}]' has 'description' as type 'string'`, function() {\n                                        const value = MCCArray[iterator]?.description;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                  }\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'blockReason' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.blockReason;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'nameOnCard' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.nameOnCard;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNetwork' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardNetwork;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'autopay' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.autopay;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: enabled\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has enabled that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enabled`)) {\n                                const value = cardDetailsArray[iterator].autopay?.enabled;\n                                console.log(`cardDetailsArray[iterator].autopay?.enabled`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: sourceAccountId\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has sourceAccountId that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`sourceAccountId`)) {\n                                const value = cardDetailsArray[iterator].autopay?.sourceAccountId;\n                                console.log(`cardDetailsArray[iterator].autopay?.sourceAccountId`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: paymentType\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has paymentType that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`paymentType`)) {\n                                const value = cardDetailsArray[iterator].autopay?.paymentType;\n                                console.log(`cardDetailsArray[iterator].autopay?.paymentType`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: onStatementDate\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has onStatementDate that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`onStatementDate`)) {\n                                const value = cardDetailsArray[iterator].autopay?.onStatementDate;\n                                console.log(`cardDetailsArray[iterator].autopay?.onStatementDate`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: dayOfMonth\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has dayOfMonth that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`dayOfMonth`)) {\n                                const value = cardDetailsArray[iterator].autopay?.dayOfMonth;\n                                console.log(`cardDetailsArray[iterator].autopay?.dayOfMonth`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.dueAmount;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.dueDate;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'minimumPaymentDue' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.minimumPaymentDue;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'partialPaymentPaid' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.partialPaymentPaid;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'IsCrossAccount' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.IsCrossAccount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetAccountInfo_POST_af6f2391b3","jsonData":"[\n  {\n    \"customerId_1\": 1045300,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_2\": 2277,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_3\": 4007,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_4\": 5000,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_5\": 6000,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_6\": \"invalid\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_7\": null,\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_8\": 7000,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  }\n]"}},"GetAccountDetails":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_get_the_details_of_the_mentioned_customer_accou.json","feedback":[],"name":"to get the details of the mentioned customer account","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountDetails for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountName\n\n              pm.test(`'item field has accountName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountName`)) {\n                  const value = item?.accountName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNickname\n\n              pm.test(`'item field has accountNickname that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNickname`)) {\n                  const value = item?.accountNickname;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountType\n\n              pm.test(`'item field has accountType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountType`)) {\n                  const value = item?.accountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: activatedDate\n\n              pm.test(`'item field has activatedDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`activatedDate`)) {\n                  const value = item?.activatedDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableBalance\n\n              pm.test(`'item field has availableBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableBalance`)) {\n                  const value = item?.availableBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCash\n\n              pm.test(`'item field has availableCash that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCash`)) {\n                  const value = item?.availableCash;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCashLimit\n\n              pm.test(`'item field has availableCashLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCashLimit`)) {\n                  const value = item?.availableCashLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCredit\n\n              pm.test(`'item field has availableCredit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCredit`)) {\n                  const value = item?.availableCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: bankName\n\n              pm.test(`'item field has bankName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`bankName`)) {\n                  const value = item?.bankName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: branchName\n\n              pm.test(`'item field has branchName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`branchName`)) {\n                  const value = item?.branchName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardName\n\n              pm.test(`'item field has cardName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardName`)) {\n                  const value = item?.cardName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardNumber\n\n              pm.test(`'item field has cardNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                  const value = item?.cardNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardStatus\n\n              pm.test(`'item field has cardStatus that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardStatus`)) {\n                  const value = item?.cardStatus;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardType\n\n              pm.test(`'item field has cardType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardType`)) {\n                  const value = item?.cardType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: creditLimit\n\n              pm.test(`'item field has creditLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`creditLimit`)) {\n                  const value = item?.creditLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currentBalance\n\n              pm.test(`'item field has currentBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currentBalance`)) {\n                  const value = item?.currentBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: deactivatedDate\n\n              pm.test(`'item field has deactivatedDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`deactivatedDate`)) {\n                  const value = item?.deactivatedDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: dueAmount\n\n              pm.test(`'item field has dueAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`dueAmount`)) {\n                  const value = item?.dueAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: dueDate\n\n              pm.test(`'item field has dueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`dueDate`)) {\n                  const value = item?.dueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: earlyWithdrawalPenalty\n\n              pm.test(`'item field has earlyWithdrawalPenalty that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`earlyWithdrawalPenalty`)) {\n                  const value = item?.earlyWithdrawalPenalty;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: email\n\n              pm.test(`'item field has email that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`email`)) {\n                  const value = item?.email;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: expDate\n\n              pm.test(`'item field has expDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`expDate`)) {\n                  const value = item?.expDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: fdType\n\n              pm.test(`'item field has fdType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`fdType`)) {\n                  const value = item?.fdType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: image\n\n              pm.test(`'item field has image that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`image`)) {\n                  const value = item?.image;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: interestRate\n\n              pm.test(`'item field has interestRate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`interestRate`)) {\n                  const value = item?.interestRate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: internalTransferFromEnabled\n\n              pm.test(`'item field has internalTransferFromEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`internalTransferFromEnabled`)) {\n                  const value = item?.internalTransferFromEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: internalTransferToEnabled\n\n              pm.test(`'item field has internalTransferToEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`internalTransferToEnabled`)) {\n                  const value = item?.internalTransferToEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isPrimaryMobile\n\n              pm.test(`'item field has isPrimaryMobile that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isPrimaryMobile`)) {\n                  const value = item?.isPrimaryMobile;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isAlternateMobileNumber\n\n              pm.test(`'item field has isAlternateMobileNumber that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n                  const value = item?.isAlternateMobileNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isStatement\n\n              pm.test(`'item field has isStatement that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isStatement`)) {\n                  const value = item?.isStatement;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lastDrawDate\n\n              pm.test(`'item field has lastDrawDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lastDrawDate`)) {\n                  const value = item?.lastDrawDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: loanMaturityDate\n\n              pm.test(`'item field has loanMaturityDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`loanMaturityDate`)) {\n                  const value = item?.loanMaturityDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: loanOriginationDate\n\n              pm.test(`'item field has loanOriginationDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`loanOriginationDate`)) {\n                  const value = item?.loanOriginationDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: location\n\n              pm.test(`'item field has location that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`location`)) {\n                  const value = item?.location;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lastUpdated\n\n              pm.test(`'item field has lastUpdated that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lastUpdated`)) {\n                  const value = item?.lastUpdated;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: maxTransactionLimit\n\n              pm.test(`'item field has maxTransactionLimit that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maxTransactionLimit`)) {\n                  const value = item?.maxTransactionLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: maturityDate\n\n              pm.test(`'item field has maturityDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maturityDate`)) {\n                  const value = item?.maturityDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: minimumPaymentDue\n\n              pm.test(`'item field has minimumPaymentDue that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`minimumPaymentDue`)) {\n                  const value = item?.minimumPaymentDue;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: minimumBalance\n\n              pm.test(`'item field has minimumBalance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`minimumBalance`)) {\n                  const value = item?.minimumBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: monthlyPayment\n\n              pm.test(`'item field has monthlyPayment that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthlyPayment`)) {\n                  const value = item?.monthlyPayment;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: openingBalance\n\n              pm.test(`'item field has openingBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`openingBalance`)) {\n                  const value = item?.openingBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: originalLoanAmount\n\n              pm.test(`'item field has originalLoanAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`originalLoanAmount`)) {\n                  const value = item?.originalLoanAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: P2PLimit\n\n              pm.test(`'item field has P2PLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`P2PLimit`)) {\n                  const value = item?.P2PLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: p2pEnabled\n\n              pm.test(`'item field has p2pEnabled that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`p2pEnabled`)) {\n                  const value = item?.p2pEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: paybillEnabled\n\n              pm.test(`'item field has paybillEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`paybillEnabled`)) {\n                  const value = item?.paybillEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: payoffAmount\n\n              pm.test(`'item field has payoffAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`payoffAmount`)) {\n                  const value = item?.payoffAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: personalBankerName\n\n              pm.test(`'item field has personalBankerName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`personalBankerName`)) {\n                  const value = item?.personalBankerName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: personalBankerContact\n\n              pm.test(`'item field has personalBankerContact that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`personalBankerContact`)) {\n                  const value = item?.personalBankerContact;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.personalBankerContact\n              // subKey: email\n\n              pm.test(`'item.personalBankerContact field has email that is of type string'`, function() {\n                let parent = item.personalBankerContact;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`email`)) {\n                  const value = item.personalBankerContact?.email;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.personalBankerContact\n              // subKey: mobileNumber\n\n              pm.test(`'item.personalBankerContact field has mobileNumber that is of type string'`, function() {\n                let parent = item.personalBankerContact;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n                  const value = item.personalBankerContact?.mobileNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: phone\n\n              pm.test(`'item field has phone that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`phone`)) {\n                  const value = item?.phone;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: postedBalance\n\n              pm.test(`'item field has postedBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`postedBalance`)) {\n                  const value = item?.postedBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: principalBalance\n\n              pm.test(`'item field has principalBalance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`principalBalance`)) {\n                  const value = item?.principalBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: productCode\n\n              pm.test(`'item field has productCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`productCode`)) {\n                  const value = item?.productCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: productName\n\n              pm.test(`'item field has productName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`productName`)) {\n                  const value = item?.productName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: propertyAddress\n\n              pm.test(`'item field has propertyAddress that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`propertyAddress`)) {\n                  const value = item?.propertyAddress;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: rewardPoints\n\n              pm.test(`'item field has rewardPoints that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`rewardPoints`)) {\n                  const value = item?.rewardPoints;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: routingNumber\n\n              pm.test(`'item field has routingNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`routingNumber`)) {\n                  const value = item?.routingNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: statementDate\n\n              pm.test(`'item field has statementDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`statementDate`)) {\n                  const value = item?.statementDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: swiftCode\n\n              pm.test(`'item field has swiftCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`swiftCode`)) {\n                  const value = item?.swiftCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalBalance\n\n              pm.test(`'item field has totalBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalBalance`)) {\n                  const value = item?.totalBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: unbilledAmount\n\n              pm.test(`'item field has unbilledAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`unbilledAmount`)) {\n                  const value = item?.unbilledAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: valueAtMaturity\n\n              pm.test(`'item field has valueAtMaturity that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`valueAtMaturity`)) {\n                  const value = item?.valueAtMaturity;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: holdAmount\n\n              pm.test(`'item field has holdAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`holdAmount`)) {\n                  const value = item?.holdAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: unclearFundsAmount\n\n              pm.test(`'item field has unclearFundsAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`unclearFundsAmount`)) {\n                  const value = item?.unclearFundsAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: averageMonthlyBalance\n\n              pm.test(`'item field has averageMonthlyBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`averageMonthlyBalance`)) {\n                  const value = item?.averageMonthlyBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: netWithdrawableBalance\n\n              pm.test(`'item field has netWithdrawableBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`netWithdrawableBalance`)) {\n                  const value = item?.netWithdrawableBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalTenure\n\n              pm.test(`'item field has totalTenure that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalTenure`)) {\n                  const value = item?.totalTenure;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: remainingTenure\n\n              pm.test(`'item field has remainingTenure that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`remainingTenure`)) {\n                  const value = item?.remainingTenure;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: debitAccountNumber\n\n              pm.test(`'item field has debitAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`debitAccountNumber`)) {\n                  const value = item?.debitAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lateFee\n\n              pm.test(`'item field has lateFee that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lateFee`)) {\n                  const value = item?.lateFee;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: bounceCharge\n\n              pm.test(`'item field has bounceCharge that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`bounceCharge`)) {\n                  const value = item?.bounceCharge;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalCharges\n\n              pm.test(`'item field has totalCharges that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalCharges`)) {\n                  const value = item?.totalCharges;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: overDueAmount\n\n              pm.test(`'item field has overDueAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`overDueAmount`)) {\n                  const value = item?.overDueAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // array condition without arrayName and parent property is an array\n              pm.test(`'item has 'cardDetails' as type array'`, function() {\n                const value = item?.cardDetails;\n\n                if (value !== null && value !== undefined) {\n                  pm.expect(Array.isArray(value)).to.equal(true);\n                }\n\n              })\n\n\n              pm.test(`Each object in the item.cardDetails field has all the required fields and correct data-types`, function() {\n                if (pm.expect(item).to.have.nested.property(`cardDetails`)) {\n                  let cardDetailsArray = ld.get(item, `cardDetails`, []);\n                  if (Array.isArray(cardDetailsArray)) {\n                    for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                      let iterator = cardDetails_it;\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardName;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardNumber;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardStatus;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardImage' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardImage;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardType;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.expDate;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'displayCardStatus' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.displayCardStatus;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'primaryCard' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.primaryCard;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardChannelInfo' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardChannelInfo;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: ATM\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has ATM that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`ATM`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.ATM;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.ATM`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: offline\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has offline that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`offline`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.offline;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.offline`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.offline?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.offline?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: international\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has international that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`international`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.international;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.international`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.international?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.international?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: online\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has online that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`online`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.online;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.online`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.online?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.online?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: contactless\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has contactless that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`contactless`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.contactless;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.contactless`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardRestrictions' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardRestrictions;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // array condition and parent property is not an array\n                        pm.test(`'Response has the `\n                          cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                          function() {\n                            if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                              const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                              if (value !== null && value !== undefined) {\n                                pm.expect(Array.isArray(value)).to.equal(true);\n                              }\n\n                            }\n                          })\n\n                        pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.countries field has all the required fields and correct data-types`, function() {\n                          if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`countries`)) {\n                            let countriesArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `countries`, []);\n                            if (Array.isArray(countriesArray)) {\n                              for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                                let iterator = countries_it;\n                                if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at countriesArray[${iterator}]' has 'countrycode' as type 'string'`, function() {\n                                    const value = countriesArray[iterator]?.countrycode;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                              }\n                            }\n                          }\n                        })\n\n                        // array condition and parent property is not an array\n                        pm.test(`'Response has the `\n                          cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                          function() {\n                            if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                              const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                              if (value !== null && value !== undefined) {\n                                pm.expect(Array.isArray(value)).to.equal(true);\n                              }\n\n                            }\n                          })\n\n                        pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.MCC field has all the required fields and correct data-types`, function() {\n                          if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`MCC`)) {\n                            let MCCArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `MCC`, []);\n                            if (Array.isArray(MCCArray)) {\n                              for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                                let iterator = MCC_it;\n                                if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at MCCArray[${iterator}]' has 'name' as type 'string'`, function() {\n                                    const value = MCCArray[iterator]?.name;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                                if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at MCCArray[${iterator}]' has 'description' as type 'string'`, function() {\n                                    const value = MCCArray[iterator]?.description;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                              }\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'blockReason' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.blockReason;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'nameOnCard' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.nameOnCard;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNetwork' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardNetwork;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'autopay' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.autopay;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: enabled\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has enabled that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enabled`)) {\n                            const value = cardDetailsArray[iterator].autopay?.enabled;\n                            console.log(`cardDetailsArray[iterator].autopay?.enabled`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: sourceAccountId\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has sourceAccountId that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`sourceAccountId`)) {\n                            const value = cardDetailsArray[iterator].autopay?.sourceAccountId;\n                            console.log(`cardDetailsArray[iterator].autopay?.sourceAccountId`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: paymentType\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has paymentType that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`paymentType`)) {\n                            const value = cardDetailsArray[iterator].autopay?.paymentType;\n                            console.log(`cardDetailsArray[iterator].autopay?.paymentType`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: onStatementDate\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has onStatementDate that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`onStatementDate`)) {\n                            const value = cardDetailsArray[iterator].autopay?.onStatementDate;\n                            console.log(`cardDetailsArray[iterator].autopay?.onStatementDate`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: dayOfMonth\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has dayOfMonth that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`dayOfMonth`)) {\n                            const value = cardDetailsArray[iterator].autopay?.dayOfMonth;\n                            console.log(`cardDetailsArray[iterator].autopay?.dayOfMonth`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.dueAmount;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.dueDate;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'minimumPaymentDue' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.minimumPaymentDue;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'partialPaymentPaid' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.partialPaymentPaid;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                    }\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: IsCrossAccount\n\n              pm.test(`'item field has IsCrossAccount that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`IsCrossAccount`)) {\n                  const value = item?.IsCrossAccount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetAccountDetails_POST_7d7c0019af","jsonData":"[\n  {\n    \"customerId\": 541138,\n    \"accountInfo_0\": {\n      \"accountType\": \"Savings\",\n      \"accountNumber\": \"SAV123456789\",\n      \"cardNumber\": \"1234567890123456\"\n    },\n    \"accountInfo_1\": {\n      \"accountType\": \"Checking\",\n      \"accountNumber\": \"CHK987654321\",\n      \"cardNumber\": \"6543210987654321\"\n    },\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId\": 541139,\n    \"accountInfo_0\": {\n      \"accountType\": \"Savings\",\n      \"accountNumber\": \"SAV987654321\",\n      \"cardNumber\": \"9876543210987654\"\n    },\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId\": 541140,\n    \"accountInfo_0\": {\n      \"accountType\": \"Savings\",\n      \"accountNumber\": \"SAV123456789\",\n      \"cardNumber\": \"1234567890123456\"\n    },\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId\": 541141,\n    \"accountInfo_0\": {\n      \"accountType\": \"Savings\",\n      \"accountNumber\": \"SAV987654321\",\n      \"cardNumber\": \"9876543210987654\"\n    },\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId\": 541142,\n    \"accountInfo_0\": {\n      \"accountType\": \"Savings\",\n      \"accountNumber\": \"SAV123456789\",\n      \"cardNumber\": \"1234567890123456\"\n    },\n    \"accountInfo_1\": {\n      \"accountType\": \"Checking\",\n      \"accountNumber\": \"CHK987654321\",\n      \"cardNumber\": \"6543210987654321\"\n    },\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId\": 541143,\n    \"accountInfo_0\": {\n      \"accountType\": \"Savings\",\n      \"accountNumber\": \"SAV987654321\",\n      \"cardNumber\": \"9876543210987654\"\n    },\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"GetAccountsLimit":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_get_the_limits_of_customer_accounts.json","feedback":[],"name":"to get the limits of customer accounts","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountsLimit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountName\n\n              pm.test(`'item field has accountName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountName`)) {\n                  const value = item?.accountName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNickname\n\n              pm.test(`'item field has accountNickname that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNickname`)) {\n                  const value = item?.accountNickname;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountType\n\n              pm.test(`'item field has accountType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountType`)) {\n                  const value = item?.accountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: balance\n\n              pm.test(`'item field has balance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`balance`)) {\n                  const value = item?.balance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardName\n\n              pm.test(`'item field has cardName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardName`)) {\n                  const value = item?.cardName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardNumber\n\n              pm.test(`'item field has cardNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                  const value = item?.cardNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: perTxn\n\n              pm.test(`'item field has perTxn that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`perTxn`)) {\n                  const value = item?.perTxn;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCashLimit\n\n              pm.test(`'item field has availableCashLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCashLimit`)) {\n                  const value = item?.availableCashLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: creditLimit\n\n              pm.test(`'item field has creditLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`creditLimit`)) {\n                  const value = item?.creditLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCredit\n\n              pm.test(`'item field has availableCredit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCredit`)) {\n                  const value = item?.availableCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: purchase\n\n              pm.test(`'item field has purchase that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`purchase`)) {\n                  const value = item?.purchase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: limits\n\n              pm.test(`'item.purchase field has limits that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.purchase?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: monthly\n\n              pm.test(`'item.purchase.limits field has monthly that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: daily\n\n              pm.test(`'item.purchase.limits field has daily that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: transactions\n\n              pm.test(`'item.purchase field has transactions that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.purchase?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: monthly\n\n              pm.test(`'item.purchase.transactions field has monthly that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: daily\n\n              pm.test(`'item.purchase.transactions field has daily that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: txnsPerDay\n\n              pm.test(`'item field has txnsPerDay that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`txnsPerDay`)) {\n                  const value = item?.txnsPerDay;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: available\n\n              pm.test(`'item.txnsPerDay field has available that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.txnsPerDay?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: maximum\n\n              pm.test(`'item.txnsPerDay field has maximum that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.txnsPerDay?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: usedup\n\n              pm.test(`'item.txnsPerDay field has usedup that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.txnsPerDay?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: amountperday\n\n              pm.test(`'item.txnsPerDay field has amountperday that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amountperday`)) {\n                  const value = item.txnsPerDay?.amountperday;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: withdrawal\n\n              pm.test(`'item field has withdrawal that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`withdrawal`)) {\n                  const value = item?.withdrawal;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: limits\n\n              pm.test(`'item.withdrawal field has limits that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.withdrawal?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.limits field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.limits field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: transactions\n\n              pm.test(`'item.withdrawal field has transactions that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.withdrawal?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.transactions field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.transactions field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetAccountsLimit_POST_891351a57e","jsonData":"[\n  {\n    \"customerId_1\": 1045300,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_2\": 1045301,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_3\": 1045302,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_4\": 1045303,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_5\": 1045304,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_6\": 1045305,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"GetAccountSpecificLimitsInfo":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_get_the_limits_of_customer_accounts.json","feedback":[],"name":"to get the limits of customer accounts","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountSpecificLimitsInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: perTxn\n\n              pm.test(`'item field has perTxn that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`perTxn`)) {\n                  const value = item?.perTxn;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: purchase\n\n              pm.test(`'item field has purchase that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`purchase`)) {\n                  const value = item?.purchase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: limits\n\n              pm.test(`'item.purchase field has limits that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.purchase?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: monthly\n\n              pm.test(`'item.purchase.limits field has monthly that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: daily\n\n              pm.test(`'item.purchase.limits field has daily that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: transactions\n\n              pm.test(`'item.purchase field has transactions that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.purchase?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: monthly\n\n              pm.test(`'item.purchase.transactions field has monthly that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: daily\n\n              pm.test(`'item.purchase.transactions field has daily that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: txnsPerDay\n\n              pm.test(`'item field has txnsPerDay that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`txnsPerDay`)) {\n                  const value = item?.txnsPerDay;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: available\n\n              pm.test(`'item.txnsPerDay field has available that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.txnsPerDay?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: maximum\n\n              pm.test(`'item.txnsPerDay field has maximum that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.txnsPerDay?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: usedup\n\n              pm.test(`'item.txnsPerDay field has usedup that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.txnsPerDay?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: amount\n\n              pm.test(`'item.txnsPerDay field has amount that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amount`)) {\n                  const value = item.txnsPerDay?.amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: withdrawal\n\n              pm.test(`'item field has withdrawal that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`withdrawal`)) {\n                  const value = item?.withdrawal;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: limits\n\n              pm.test(`'item.withdrawal field has limits that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.withdrawal?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.limits field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.limits field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: transactions\n\n              pm.test(`'item.withdrawal field has transactions that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.withdrawal?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.transactions field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.transactions field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetAccountSpecificLimitsInfo_POST_fd14b7cfb3","jsonData":"[\n  {\n    \"customerId_1045300\": 1045300,\n    \"accountNumber_0_123456789\": \"123456789\",\n    \"accountNumber_1_987654321\": \"987654321\",\n    \"cardNumber_0_1111222233334444\": \"1111222233334444\",\n    \"cardNumber_1_5555666677778888\": \"5555666677778888\",\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_1045301\": 1045301,\n    \"accountNumber_0_123456780\": \"123456780\",\n    \"accountNumber_1_987654320\": \"987654320\",\n    \"cardNumber_0_1111222233334445\": \"1111222233334445\",\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_1045302\": 1045302,\n    \"accountNumber_0_123456781\": \"123456781\",\n    \"accountNumber_1_987654319\": \"987654319\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_1045303\": 1045303,\n    \"accountNumber_0_123456782\": \"123456782\",\n    \"cardNumber_0_1111222233334446\": \"1111222233334446\",\n    \"cardNumber_1_5555666677778889\": \"5555666677778889\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_1045304\": 1045304,\n    \"accountNumber_0_123456783\": \"123456783\",\n    \"accountNumber_1_987654318\": \"987654318\",\n    \"cardNumber_0_1111222233334447\": \"1111222233334447\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_1045305\": 1045305,\n    \"accountNumber_0_123456784\": \"123456784\",\n    \"cardNumber_0_1111222233334448\": \"1111222233334448\",\n    \"cardNumber_1_5555666677778880\": \"5555666677778880\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"UpdateAccountInfo":{"PUT":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/UpdateAccountInfo.json","feedback":[],"name":"UpdateAccountInfo","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateAccountInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"UpdateAccountInfo_PUT_b851afa414","jsonData":"[\n  {\n    \"accountNumber_*string\": \"1042345\",\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"accountNumber_*string\": \"1042345\",\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"alternatePhoneNumber_*number\": 1234567890,\n    \"isAlternateMobileNumber_*boolean\": true,\n    \"phone_*number\": 9876543210,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"New York\",\n    \"isStatement_*boolean\": true,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"alternatePhoneNumber_*number\": 1234567890,\n    \"isAlternateMobileNumber_*boolean\": true,\n    \"phone_*number\": 9876543210,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"New York\",\n    \"isStatement_*boolean\": true,\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"accountNumber_*string\": \"1042345\",\n    \"customerId_*number\": \"1045300\",\n    \"email_*string\": \"John@gmail.com\",\n    \"alternatePhoneNumber_*number\": 1234567890,\n    \"isAlternateMobileNumber_*boolean\": \"true\",\n    \"phone_*number\": 9876543210,\n    \"isPrimaryMobileNumber_*boolean\": \"true\",\n    \"location_*string\": \"New York\",\n    \"isStatement_*boolean\": \"true\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"accountNumber_*string\": \"1042345\",\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"alternatePhoneNumber_*number\": 1234567890,\n    \"isAlternateMobileNumber_*boolean\": true,\n    \"phone_*number\": 9876543210,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"New York\",\n    \"isStatement_*boolean\": true,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"accountNumber_*string\": \"1042345\",\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"alternatePhoneNumber_*number\": 1234567890,\n    \"isAlternateMobileNumber_*boolean\": true,\n    \"phone_*number\": 9876543210,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"New York\",\n    \"isStatement_*boolean\": true,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  }\n]"}},"GetCustomerInfo":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/GetCustomerInfo.json","feedback":[],"name":"GetCustomerInfo","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCustomerInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alternatePhoneNumber\n\n        pm.test(`'responseData field has alternatePhoneNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alternatePhoneNumber`)) {\n            const value = responseData?.alternatePhoneNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: email\n\n        pm.test(`'responseData field has email that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationNumber\n\n        pm.test(`'responseData field has identificationNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationNumber`)) {\n            const value = responseData?.identificationNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationType\n\n        pm.test(`'responseData field has identificationType that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationType`)) {\n            const value = responseData?.identificationType;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: image\n\n        pm.test(`'responseData field has image that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`image`)) {\n            const value = responseData?.image;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isAlternateMobileNumber\n\n        pm.test(`'responseData field has isAlternateMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n            const value = responseData?.isAlternateMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isPrimaryMobileNumber\n\n        pm.test(`'responseData field has isPrimaryMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isPrimaryMobileNumber`)) {\n            const value = responseData?.isPrimaryMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: firstName\n\n        pm.test(`'responseData field has firstName that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`firstName`)) {\n            const value = responseData?.firstName;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: lastName\n\n        pm.test(`'responseData field has lastName that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lastName`)) {\n            const value = responseData?.lastName;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalBanker\n\n        pm.test(`'responseData field has personalBanker that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalBanker`)) {\n            const value = responseData?.personalBanker;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: name\n\n        pm.test(`'responseData.personalBanker field has name that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.personalBanker?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: email\n\n        pm.test(`'responseData.personalBanker field has email that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData.personalBanker?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: mobileNumber\n\n        pm.test(`'responseData.personalBanker field has mobileNumber that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n            const value = responseData.personalBanker?.mobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: phone\n\n        pm.test(`'responseData field has phone that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`phone`)) {\n            const value = responseData?.phone;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'securityQuestions' as type array'`, function() {\n          const value = responseData?.securityQuestions;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: segmentId\n\n        pm.test(`'responseData field has segmentId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`segmentId`)) {\n            const value = responseData?.segmentId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetCustomerInfo_POST_33372ddd2b","jsonData":"[\n  {\n    \"customerId_1\": 1045300,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_2\": 1045301,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_3\": 1045302,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_4\": 1045303,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_5\": 1045304,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_6\": 1045305,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_7\": 1045306,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_8\": 1045307,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_9\": 1045308,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"UpdateCustomerInfo":{"PUT":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/UpdateCustomerInfo.json","feedback":[],"name":"UpdateCustomerInfo","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateCustomerInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"UpdateCustomerInfo_PUT_a00483e597","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"phone_*number\": 1234567890,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"alternatePhoneNumber_*number\": 9876543210,\n    \"isAlternateMobileNumber_*boolean\": true,\n    \"phone_*number\": 1234567890,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"email_*string\": \"John@gmail.com\",\n    \"phone_*number\": 1234567890,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"New York\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"alternatePhoneNumber_*number\": \"invalid_number\",\n    \"isAlternateMobileNumber_*boolean\": true,\n    \"phone_*number\": 1234567890,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"New York\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"phone_*number\": 1234567890,\n    \"isPrimaryMobileNumber_*boolean\": \"invalid_boolean\",\n    \"location_*string\": \"New York\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"alternatePhoneNumber_*number\": 9876543210,\n    \"isAlternateMobileNumber_*boolean\": true,\n    \"phone_*number\": 1234567890,\n    \"isPrimaryMobileNumber_*boolean\": true,\n    \"location_*string\": \"invalid_location\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  }\n]"}},"GetTransactions":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/GetTransactions.json","feedback":[],"name":"GetTransactions","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetTransactions for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: transactionId\n\n              pm.test(`'item field has transactionId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactionId`)) {\n                  const value = item?.transactionId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: timestamp\n\n              pm.test(`'item field has timestamp that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`timestamp`)) {\n                  const value = item?.timestamp;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: amount\n\n              pm.test(`'item field has amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amount`)) {\n                  const value = item?.amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: debitOrCredit\n\n              pm.test(`'item field has debitOrCredit that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`debitOrCredit`)) {\n                  const value = item?.debitOrCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: description\n\n              pm.test(`'item field has description that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`description`)) {\n                  const value = item?.description;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: paymentMode\n\n              pm.test(`'item field has paymentMode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`paymentMode`)) {\n                  const value = item?.paymentMode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DBANames\n\n              pm.test(`'item field has DBANames that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DBANames`)) {\n                  const value = item?.DBANames;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: closingBalance\n\n              pm.test(`'item field has closingBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`closingBalance`)) {\n                  const value = item?.closingBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: transacitonType\n\n              pm.test(`'item field has transacitonType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transacitonType`)) {\n                  const value = item?.transacitonType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ACHCode\n\n              pm.test(`'item field has ACHCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ACHCode`)) {\n                  const value = item?.ACHCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: MCCCode\n\n              pm.test(`'item field has MCCCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`MCCCode`)) {\n                  const value = item?.MCCCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SICCode\n\n              pm.test(`'item field has SICCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SICCode`)) {\n                  const value = item?.SICCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: name\n\n              pm.test(`'item field has name that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`name`)) {\n                  const value = item?.name;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: address\n\n              pm.test(`'item field has address that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`address`)) {\n                  const value = item?.address;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: street\n\n              pm.test(`'item field has street that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`street`)) {\n                  const value = item?.street;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: city\n\n              pm.test(`'item field has city that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`city`)) {\n                  const value = item?.city;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: state\n\n              pm.test(`'item field has state that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`state`)) {\n                  const value = item?.state;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: zip\n\n              pm.test(`'item field has zip that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`zip`)) {\n                  const value = item?.zip;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: country\n\n              pm.test(`'item field has country that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`country`)) {\n                  const value = item?.country;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: phoneNumber\n\n              pm.test(`'item field has phoneNumber that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`phoneNumber`)) {\n                  const value = item?.phoneNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // array condition without arrayName and parent property is an array\n              pm.test(`'item has 'metaInfo' as type array'`, function() {\n                const value = item?.metaInfo;\n\n                if (value !== null && value !== undefined) {\n                  pm.expect(Array.isArray(value)).to.equal(true);\n                }\n\n              })\n\n\n              pm.test(`Each object in the item.metaInfo field has all the required fields and correct data-types`, function() {\n                if (pm.expect(item).to.have.nested.property(`metaInfo`)) {\n                  let metaInfoArray = ld.get(item, `metaInfo`, []);\n                  if (Array.isArray(metaInfoArray)) {\n                    for (let metaInfo_it = 0; metaInfo_it < metaInfoArray.length; metaInfo_it++) {\n                      let iterator = metaInfo_it;\n                      // Condition: Raw data type with defined arrayName and parent property is an array\n                      pm.test(`'Item at metaInfoArray[${iterator}]' has 'name' as type 'string'`, function() {\n                        const value = metaInfoArray[iterator]?.name;\n\n                        pm.expect(typeof value).to.equal(\"string\");\n\n                      })\n\n\n                      // Condition: Raw data type with defined arrayName and parent property is an array\n                      pm.test(`'Item at metaInfoArray[${iterator}]' has 'value' as type 'string'`, function() {\n                        const value = metaInfoArray[iterator]?.value;\n\n                        pm.expect(typeof value).to.equal(\"string\");\n\n                      })\n\n\n                    }\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetTransactions_POST_61ffb60c9e","jsonData":"[\n  {\n    \"accountNumber_0_*string\": \"ACC123456\",\n    \"accountNumber_1_*string\": \"ACC654321\",\n    \"customerId_*string\": \"CUST789456\",\n    \"numOfTransactions_*number\": 10,\n    \"status_*string\": \"active\",\n    \"startDate_*date\": \"2022-01-01\",\n    \"endDate_*date\": \"2022-01-31\",\n    \"sort.type_*string\": \"date\",\n    \"sort.value_*string\": \"desc\",\n    \"transactionAmount.amount1_*number\": 1000,\n    \"transactionAmount.currency_*string\": \"USD\",\n    \"category_0.codeType_*string\": \"type1\",\n    \"category_0.value_0_*string\": \"value1\",\n    \"category_0.value_1_*string\": \"value2\",\n    \"category_0.source_*string\": \"source1\",\n    \"debitOrCredit_*string\": \"debit\",\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"accountNumber_0_*string\": \"ACC789012\",\n    \"accountNumber_1_*string\": \"ACC210987\",\n    \"customerId_*string\": \"CUST345678\",\n    \"numOfTransactions_*number\": 5,\n    \"status_*string\": \"inactive\",\n    \"startDate_*date\": \"2022-02-01\",\n    \"endDate_*date\": \"2022-02-28\",\n    \"sort.type_*string\": \"amount\",\n    \"sort.value_*string\": \"asc\",\n    \"transactionAmount.amount1_*number\": 500,\n    \"transactionAmount.currency_*string\": \"EUR\",\n    \"category_1.codeType_*string\": \"type2\",\n    \"category_1.value_0_*string\": \"value3\",\n    \"category_1.value_1_*string\": \"value4\",\n    \"category_1.source_*string\": \"source2\",\n    \"debitOrCredit_*string\": \"credit\",\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"accountNumber_0_*string\": \"ACC345678\",\n    \"customerId_*string\": \"CUST123456\",\n    \"numOfTransactions_*number\": 15,\n    \"status_*string\": \"pending\",\n    \"startDate_*date\": \"2022-03-01\",\n    \"endDate_*date\": \"2022-03-31\",\n    \"sort.type_*string\": \"status\",\n    \"sort.value_*string\": \"desc\",\n    \"transactionAmount.amount1_*number\": 1500,\n    \"transactionAmount.currency_*string\": \"GBP\",\n    \"category_0.codeType_*string\": \"type3\",\n    \"category_0.value_0_*string\": \"value5\",\n    \"category_0.value_1_*string\": \"value6\",\n    \"category_0.source_*string\": \"source3\",\n    \"debitOrCredit_*string\": \"debit\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"accountNumber_0_*string\": \"ACC901234\",\n    \"accountNumber_1_*string\": \"ACC432109\",\n    \"customerId_*string\": \"CUST987654\",\n    \"numOfTransactions_*number\": 20,\n    \"status_*string\": \"closed\",\n    \"startDate_*date\": \"2022-04-01\",\n    \"endDate_*date\": \"2022-04-30\",\n    \"sort.type_*string\": \"customer\",\n    \"sort.value_*string\": \"asc\",\n    \"transactionAmount.amount1_*number\": 2000,\n    \"transactionAmount.currency_*string\": \"JPY\",\n    \"category_1.codeType_*string\": \"type4\",\n    \"category_1.value_0_*string\": \"value7\",\n    \"category_1.value_1_*string\": \"value8\",\n    \"category_1.source_*string\": \"source4\",\n    \"debitOrCredit_*string\": \"credit\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  }\n]"}},"TransferFunds":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/TransferFunds.json","feedback":[],"name":"TransferFunds","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for TransferFunds for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Transaction success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"TransferFunds_POST_a9cc4fa75c","jsonData":"[\n  {\n    \"amount_*number\": 5000,\n    \"currency_*string\": \"USD\",\n    \"customerId_*number\": 1045300,\n    \"date_*string\": \"03-15-2021\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"statusCode\": 200,\n    \"scenario\": \"Transaction success\"\n  },\n  {\n    \"amount_*number\": 7000,\n    \"currency_*string\": \"USD\",\n    \"customerId_*number\": 1045300,\n    \"date_*string\": \"03-16-2021\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"description_*string\": \"Internal Transfer\",\n    \"TransactionType_*string\": \"1063\",\n    \"PaymentType_*string\": \"Minimum Payment\",\n    \"statusCode\": 200,\n    \"scenario\": \"Transaction success\"\n  },\n  {\n    \"currency_*string\": \"USD\",\n    \"customerId_*number\": 1045300,\n    \"date_*string\": \"03-17-2021\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"amount_*number\": 8000,\n    \"currency_*string\": \"EUR\",\n    \"customerId_*number\": 1045300,\n    \"date_*string\": \"03-18-2021\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"amount_*number\": 9000,\n    \"currency_*string\": \"USD\",\n    \"customerId_*number\": 1045301,\n    \"date_*string\": \"03-19-2021\",\n    \"sourceAccountId_*string\": \"1042346\",\n    \"targetAccountId_*string\": \"1042223\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"GetScheduleTransfers":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/GetScheduleTransfers.json","feedback":[],"name":"GetScheduleTransfers","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: InvoiceNumber\n\n              pm.test(`'item field has InvoiceNumber that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`InvoiceNumber`)) {\n                  const value = item?.InvoiceNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ScheduledDate\n\n              pm.test(`'item field has ScheduledDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ScheduledDate`)) {\n                  const value = item?.ScheduledDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: NextScheduleDate\n\n              pm.test(`'item field has NextScheduleDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`NextScheduleDate`)) {\n                  const value = item?.NextScheduleDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetScheduleTransfers_POST_8432d40a7b","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"status_*string\": \"Active\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer list response\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"status_*string\": \"Inactive\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer list response\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"status_*string\": \"InvalidStatus\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"status_*string\": \"Active\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045305,\n    \"status_*string\": \"Inactive\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"UpdateScheduleTransfers":{"PUT":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/UpdateScheduleTransfers.json","feedback":[],"name":"UpdateScheduleTransfers","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateScheduleTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Scheduled transfer updated successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"UpdateScheduleTransfers_PUT_b82a748b75","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"paymentId_*string\": \"PAY12345\",\n    \"sourceAccountId_*string\": \"ACC12345\",\n    \"amount_*number\": 5000,\n    \"scheduledDate_*number\": 20220220,\n    \"targetAccountId_*string\": \"ACC54321\",\n    \"statusCode\": 200,\n    \"scenario\": \"Scheduled transfer updated successfully\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"paymentId_*string\": \"PAY12346\",\n    \"sourceAccountId_*string\": \"ACC12346\",\n    \"amount_*number\": 6000,\n    \"scheduledDate_*number\": 20220221,\n    \"targetAccountId_*string\": \"ACC54322\",\n    \"statusCode\": 200,\n    \"scenario\": \"Scheduled transfer updated successfully\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"paymentId_*string\": \"PAY12347\",\n    \"sourceAccountId_*string\": \"ACC12347\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"paymentId_*string\": \"PAY12348\",\n    \"sourceAccountId_*string\": \"ACC12348\",\n    \"amount_*number\": 7000,\n    \"scheduledDate_*number\": 20220222,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"paymentId_*string\": \"PAY12349\",\n    \"sourceAccountId_*string\": \"ACC12349\",\n    \"amount_*number\": 8000,\n    \"scheduledDate_*number\": 20220223,\n    \"targetAccountId_*string\": \"ACC54324\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  }\n]"}},"DeleteScheduleTransfers":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/DeleteScheduleTransfers.json","feedback":[],"name":"DeleteScheduleTransfers","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Scheduled transfer deleted successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"DeleteScheduleTransfers_POST_2739010641","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"paymentId_*string\": \"PAY123456\",\n    \"updateTransferType_*string\": \"all\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"statusCode\": 200,\n    \"scenario\": \"Scheduled transfer deleted successfully\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"paymentId_*string\": \"PAY123457\",\n    \"updateTransferType_*string\": \"specific\",\n    \"sourceAccountId_*string\": \"1042346\",\n    \"statusCode\": 200,\n    \"scenario\": \"Scheduled transfer deleted successfully\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"paymentId_*string\": \"PAY123458\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"paymentId_*string\": \"PAY123459\",\n    \"updateTransferType_*string\": \"all\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"paymentId_*string\": \"PAY123460\",\n    \"updateTransferType_*string\": \"invalid\",\n    \"sourceAccountId_*string\": \"1042347\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_*number\": 1045305,\n    \"paymentId_*string\": \"PAY123461\",\n    \"updateTransferType_*string\": \"all\",\n    \"sourceAccountId_*string\": \"invalid\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"AddRecurringTransfers":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/AddRecurringTransfers.json","feedback":[],"name":"AddRecurringTransfers","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for AddRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer added successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"AddRecurringTransfers_POST_1d4809a545","jsonData":"[\n  {\n    \"amount_*number\": 5000,\n    \"currency_*string\": \"USD\",\n    \"customerId_*number\": 1045300,\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer added successfully\"\n  },\n  {\n    \"amount_*number\": 10000,\n    \"currency_*string\": \"EUR\",\n    \"customerId_*number\": 1045301,\n    \"sourceAccountId_*string\": \"1042346\",\n    \"targetAccountId_*string\": \"1042223\",\n    \"status_*string\": \"completed\",\n    \"scheduledDate_*number\": 20220202,\n    \"recurringOptions.amountType_*string\": \"fixed\",\n    \"recurringOptions.frequency.iterate_*string\": \"weekly\",\n    \"recurringOptions.frequency.duration.untilStop_*string\": \"no\",\n    \"recurringOptions.frequency.duration.untilDate_*number\": 20221231,\n    \"recurringOptions.frequency.duration.numberOfTransfers_*number\": 52,\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer added successfully\"\n  },\n  {\n    \"currency_*string\": \"GBP\",\n    \"customerId_*number\": 1045302,\n    \"sourceAccountId_*string\": \"1042347\",\n    \"targetAccountId_*string\": \"1042224\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"amount_*number\": 15000,\n    \"currency_*string\": \"XYZ\",\n    \"customerId_*number\": 1045303,\n    \"sourceAccountId_*string\": \"1042348\",\n    \"targetAccountId_*string\": \"1042225\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"amount_*number\": 20000,\n    \"currency_*string\": \"JPY\",\n    \"customerId_*number\": 9999999,\n    \"sourceAccountId_*string\": \"9999999\",\n    \"targetAccountId_*string\": \"9999999\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"amount_*number\": 25000,\n    \"currency_*string\": \"CAD\",\n    \"customerId_*number\": 1045304,\n    \"sourceAccountId_*string\": \"1042349\",\n    \"targetAccountId_*string\": \"1042226\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  }\n]"}},"GetRecurringTransfers":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/GetRecurringTransfers.json","feedback":[],"name":"GetRecurringTransfers","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ScheduledDate\n\n              pm.test(`'item field has ScheduledDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ScheduledDate`)) {\n                  const value = item?.ScheduledDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: recurringOptions\n\n              pm.test(`'item field has recurringOptions that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`recurringOptions`)) {\n                  const value = item?.recurringOptions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions\n              // subKey: amountType\n\n              pm.test(`'item.recurringOptions field has amountType that is of type string'`, function() {\n                let parent = item.recurringOptions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amountType`)) {\n                  const value = item.recurringOptions?.amountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions\n              // subKey: frequency\n\n              pm.test(`'item.recurringOptions field has frequency that is of type object'`, function() {\n                let parent = item.recurringOptions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`frequency`)) {\n                  const value = item.recurringOptions?.frequency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency\n              // subKey: duration\n\n              pm.test(`'item.recurringOptions.frequency field has duration that is of type object'`, function() {\n                let parent = item.recurringOptions.frequency;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`duration`)) {\n                  const value = item.recurringOptions.frequency?.duration;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: untilStop\n\n              pm.test(`'item.recurringOptions.frequency.duration field has untilStop that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`untilStop`)) {\n                  const value = item.recurringOptions.frequency.duration?.untilStop;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: untilDate\n\n              pm.test(`'item.recurringOptions.frequency.duration field has untilDate that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`untilDate`)) {\n                  const value = item.recurringOptions.frequency.duration?.untilDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: numberOfPayments\n\n              pm.test(`'item.recurringOptions.frequency.duration field has numberOfPayments that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`numberOfPayments`)) {\n                  const value = item.recurringOptions.frequency.duration?.numberOfPayments;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency\n              // subKey: iterate\n\n              pm.test(`'item.recurringOptions.frequency field has iterate that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`iterate`)) {\n                  const value = item.recurringOptions.frequency?.iterate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetRecurringTransfers_POST_b8e8a63a1a","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"status_*string\": \"Active\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer list response\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"status_*string\": \"Inactive\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer list response\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"status_*string\": \"Pending\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"status_*string\": \"Completed\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"status_*string\": \"Active\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer list response\"\n  },\n  {\n    \"customerId_*number\": 1045305,\n    \"status_*string\": \"Inactive\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer list response\"\n  },\n  {\n    \"customerId_*number\": 1045306,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"status_*string\": \"Pending\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045307,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"status_*string\": \"Completed\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"UpdateRecurringTransfers":{"PUT":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/UpdateRecurringTransfers.json","feedback":[],"name":"UpdateRecurringTransfers","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateRecurringTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Recurring transfer updated successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"UpdateRecurringTransfers_PUT_d2d219dab7","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"paymentId_*string\": \"PAY12345\",\n    \"sourceAccountId_*string\": \"ACC12345\",\n    \"amount_*number\": 5000,\n    \"scheduledDate_*number\": 20220215,\n    \"targetAccountId_*string\": \"ACC54321\",\n    \"statusCode\": 200,\n    \"scenario\": \"Recurring transfer updated successfully\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"paymentId_*string\": \"PAY12346\",\n    \"sourceAccountId_*string\": \"ACC12346\",\n    \"amount_*number\": 6000,\n    \"scheduledDate_*number\": 20220216,\n    \"targetAccountId_*string\": \"ACC54322\",\n    \"recurringOptions.amountType_*string\": \"Fixed\",\n    \"recurringOptions.frequency.duration.untilStop_*string\": \"20230215\",\n    \"recurringOptions.frequency.duration.untilDate_*number\": 20230215,\n    \"recurringOptions.frequency.duration.numberOfTransfers_*number\": 12,\n    \"recurringOptions.frequency.iterate_*string\": \"Monthly\",\n    \"recurringOptions.updateTransferType_*string\": \"Immediate\",\n    \"statusCode\": 200,\n    \"scenario\": \"Recurring transfer updated successfully\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"paymentId_*string\": \"PAY12347\",\n    \"sourceAccountId_*string\": \"ACC12347\",\n    \"amount_*number\": 7000,\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"paymentId_*string\": \"PAY12348\",\n    \"sourceAccountId_*string\": \"ACC12348\",\n    \"amount_*number\": 8000,\n    \"scheduledDate_*number\": 20220218,\n    \"targetAccountId_*string\": \"ACC54324\",\n    \"recurringOptions.amountType_*string\": \"Variable\",\n    \"recurringOptions.frequency.duration.untilStop_*string\": \"20230218\",\n    \"recurringOptions.frequency.duration.untilDate_*number\": 20230218,\n    \"recurringOptions.frequency.duration.numberOfTransfers_*number\": 24,\n    \"recurringOptions.frequency.iterate_*string\": \"Weekly\",\n    \"recurringOptions.updateTransferType_*string\": \"Delayed\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"paymentId_*string\": \"PAY12349\",\n    \"sourceAccountId_*string\": \"ACC12349\",\n    \"amount_*number\": 9000,\n    \"scheduledDate_*number\": 20220219,\n    \"targetAccountId_*string\": \"ACC54325\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"DeleteRecurringTransfers":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/DeleteRecurringTransfers.json","feedback":[],"name":"DeleteRecurringTransfers","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Recurring transfer deleted successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"DeleteRecurringTransfers_POST_41c9f309c1","jsonData":"[\n  {\n    \"customerId_1045300\": 1045300,\n    \"paymentId_123456\": \"123456\",\n    \"updateTransferType_all\": \"all\",\n    \"sourceAccountId_1042345\": \"1042345\",\n    \"statusCode\": 200,\n    \"scenario\": \"Recurring transfer deleted successfully\"\n  },\n  {\n    \"customerId_1045301\": 1045301,\n    \"paymentId_123457\": \"123457\",\n    \"updateTransferType_all\": \"all\",\n    \"sourceAccountId_1042346\": \"1042346\",\n    \"statusCode\": 200,\n    \"scenario\": \"Recurring transfer deleted successfully\"\n  },\n  {\n    \"customerId_1045302\": 1045302,\n    \"paymentId_123458\": \"123458\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"paymentId_123459\": \"123459\",\n    \"updateTransferType_all\": \"all\",\n    \"sourceAccountId_1042347\": \"1042347\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_1045303\": 1045303,\n    \"paymentId_123460\": \"123460\",\n    \"updateTransferType_invalid\": \"invalid\",\n    \"sourceAccountId_1042348\": \"1042348\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_1045304\": 1045304,\n    \"paymentId_123461\": \"123461\",\n    \"updateTransferType_all\": \"all\",\n    \"sourceAccountId_invalid\": \"invalid\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"resetPassword":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/resetPassword.json","feedback":[],"name":"resetPassword","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for resetPassword for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"password has been updated successfully.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"resetPassword_POST_19f0f0004f","jsonData":"[\n  {\n    \"password_*string\": \"password123\",\n    \"username_*string\": \"John\",\n    \"statusCode\": 200,\n    \"scenario\": \"password has been updated successfully.\"\n  },\n  {\n    \"password_*string\": \"password123\",\n    \"username_*string\": \"JohnDoe\",\n    \"statusCode\": 200,\n    \"scenario\": \"password has been updated successfully.\"\n  },\n  {\n    \"username_*string\": \"John\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"password_*string\": \"password123\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"password_*string\": \"password123\",\n    \"username_*string\": \"NonExistentUser\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"password_*string\": \"InvalidPassword\",\n    \"username_*string\": \"John\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"debitcardInfoValidation":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/debitcardInfoValidation.json","feedback":[],"name":"debitcardInfoValidation","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for debitcardInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Validated Successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"debitcardInfoValidation_POST_6fc40c92f0","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"cvv_*string\": \"123\",\n    \"debitCardNumber_*string\": \"1234456778901690\",\n    \"expiryDate_*string\": \"2025-01-01T00:00:00.000+0000\",\n    \"pin_*string\": \"1111\",\n    \"statusCode\": 200,\n    \"scenario\": \"Validated Successfully\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"cvv_*string\": \"456\",\n    \"debitCardNumber_*string\": \"9876543210123456\",\n    \"expiryDate_*string\": \"2024-12-31T00:00:00.000+0000\",\n    \"pin_*string\": \"2222\",\n    \"statusCode\": 200,\n    \"scenario\": \"Validated Successfully\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"cvv_*string\": \"789\",\n    \"debitCardNumber_*string\": \"1234567890123456\",\n    \"expiryDate_*string\": \"2023-12-31T00:00:00.000+0000\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"cvv_*string\": \"012\",\n    \"expiryDate_*string\": \"2022-12-31T00:00:00.000+0000\",\n    \"pin_*string\": \"3333\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"cvv_*string\": \"345\",\n    \"debitCardNumber_*string\": \"6543210987654321\",\n    \"pin_*string\": \"4444\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045305,\n    \"cvv_*string\": \"678\",\n    \"expiryDate_*string\": \"2021-12-31T00:00:00.000+0000\",\n    \"pin_*string\": \"5555\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"personalInfoValidation":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/personalInfoValidation.json","feedback":[],"name":"personalInfoValidation","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for personalInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Validated Successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"personalInfoValidation_POST_0f9a1fde55","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"dob_*string\": \"1999-05-05T00:00:00.000+0000\",\n    \"ssn_*number\": 104531234,\n    \"secrectPassword_*string\": \"Sam\",\n    \"AccNumber_*string\": \"1042345\",\n    \"lastDepositAmt_*number\": 500,\n    \"statusCode\": 200,\n    \"scenario\": \"Validated Successfully\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"dob_*string\": \"1999-05-06T00:00:00.000+0000\",\n    \"ssn_*number\": 104531235,\n    \"secrectPassword_*string\": \"John\",\n    \"AccNumber_*string\": \"1042346\",\n    \"lastDepositAmt_*number\": 600,\n    \"statusCode\": 200,\n    \"scenario\": \"Validated Successfully\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"dob_*string\": \"1999-05-07T00:00:00.000+0000\",\n    \"ssn_*number\": 104531236,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"dob_*string\": \"1999-05-08T00:00:00.000+0000\",\n    \"ssn_*number\": 104531237,\n    \"secrectPassword_*string\": \"InvalidPassword\",\n    \"AccNumber_*string\": \"1042347\",\n    \"lastDepositAmt_*number\": 700,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"dob_*string\": \"1999-05-09T00:00:00.000+0000\",\n    \"ssn_*number\": 104531238,\n    \"secrectPassword_*string\": \"Sam\",\n    \"AccNumber_*string\": \"InvalidAccNumber\",\n    \"lastDepositAmt_*number\": 800,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045305,\n    \"dob_*string\": \"1999-05-10T00:00:00.000+0000\",\n    \"ssn_*number\": 104531239,\n    \"secrectPassword_*string\": \"John\",\n    \"AccNumber_*string\": \"1042348\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"disputeTransaction":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/disputeTransaction.json","feedback":[],"name":"disputeTransaction","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for disputeTransaction for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Dispute Transactions reported successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"disputeTransaction_POST_9a148e1934","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"transactionsData_0.reasonCode_*string\": \"Transaction Successful\",\n    \"transactionsData_0.transactionId_*number\": 123456,\n    \"transactionsData_1.reasonCode_*string\": \"Transaction Successful\",\n    \"transactionsData_1.transactionId_*number\": 789012,\n    \"emailId_*string\": \"John@yahoo.com\",\n    \"statusCode\": 200,\n    \"scenario\": \"Dispute Transactions reported successfully\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"transactionsData_0.reasonCode_*string\": \"Transaction Failed\",\n    \"transactionsData_0.transactionId_*number\": 123457,\n    \"transactionsData_1.reasonCode_*string\": \"Transaction Failed\",\n    \"transactionsData_1.transactionId_*number\": 789013,\n    \"emailId_*string\": \"Jane@yahoo.com\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"transactionsData_0.reasonCode_*string\": \"Transaction Pending\",\n    \"transactionsData_0.transactionId_*number\": 123458,\n    \"transactionsData_1.reasonCode_*string\": \"Transaction Pending\",\n    \"transactionsData_1.transactionId_*number\": 789014,\n    \"emailId_*string\": \"Mike@yahoo.com\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"transactionsData_0.reasonCode_*string\": \"Transaction Successful\",\n    \"transactionsData_0.transactionId_*number\": 123459,\n    \"transactionsData_1.reasonCode_*string\": \"Transaction Failed\",\n    \"transactionsData_1.transactionId_*number\": 789015,\n    \"emailId_*string\": \"Emma@yahoo.com\",\n    \"statusCode\": 200,\n    \"scenario\": \"Dispute Transactions reported successfully\"\n  },\n  {\n    \"customerId_*number\": 1045304,\n    \"transactionsData_0.reasonCode_*string\": \"Transaction Failed\",\n    \"transactionsData_0.transactionId_*number\": 123460,\n    \"transactionsData_1.reasonCode_*string\": \"Transaction Pending\",\n    \"transactionsData_1.transactionId_*number\": 789016,\n    \"emailId_*string\": \"Oliver@yahoo.com\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  }\n]"}},"ccPay":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/ccPay.json","feedback":[],"name":"ccPay","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for ccPay for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Credit Card payment scheduled successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"ccPay_POST_20cb3aea10","jsonData":"[\n  {\n    \"amount_*number\": 5000,\n    \"currency_*string\": \"USD\",\n    \"customerId_*number\": 1045300,\n    \"dueDate_*string\": \"2022-12-31\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"transactionType_*number\": 1,\n    \"statusCode\": 200,\n    \"scenario\": \"Credit Card payment scheduled successfully\"\n  },\n  {\n    \"amount_*number\": 7000,\n    \"currency_*string\": \"EUR\",\n    \"customerId_*number\": 1045300,\n    \"dueDate_*string\": \"2022-12-31\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"transactionType_*number\": 2,\n    \"statusCode\": 200,\n    \"scenario\": \"Credit Card payment scheduled successfully\"\n  },\n  {\n    \"amount_*number\": 5000,\n    \"currency_*string\": \"USD\",\n    \"dueDate_*string\": \"2022-12-31\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"transactionType_*number\": 1,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"amount_*number\": 5000,\n    \"currency_*string\": \"USD\",\n    \"customerId_*number\": 1045300,\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"transactionType_*number\": 1,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"amount_*number\": 5000,\n    \"currency_*string\": \"XYZ\",\n    \"customerId_*number\": 1045300,\n    \"dueDate_*string\": \"2022-12-31\",\n    \"sourceAccountId_*string\": \"1042345\",\n    \"targetAccountId_*string\": \"1042222\",\n    \"transactionType_*number\": 1,\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  }\n]"}},"GetCCSchedule":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/GetCCSchedule.json","feedback":[],"name":"GetCCSchedule","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCCSchedule for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"GetCCSchedule_POST_d792df95fb","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"status_*string\": \"Active\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer list response\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"status_*string\": \"Inactive\",\n    \"statusCode\": 200,\n    \"scenario\": \"schedule transfer list response\"\n  },\n  {\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"status_*string\": \"InvalidStatus\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  }\n]"}},"sendsecuremessage":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/sendsecuremessage.json","feedback":[],"name":"sendsecuremessage","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendsecuremessage for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"sendsecuremessage_POST_b7e4e848a7","jsonData":"[\n  {\n    \"authType_*string\": \"Authorized\",\n    \"firstName_*string\": \"James\",\n    \"lastName_*string\": \"William\",\n    \"email_*string\": \"John@gmail.com\",\n    \"phoneNumber_*number\": 9787643445,\n    \"topic_*string\": \"Routing and Account Number\",\n    \"message_*string\": \"Unable to find my routing number.\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"authType_*string\": \"Authorized\",\n    \"firstName_*string\": \"James\",\n    \"lastName_*string\": \"William\",\n    \"email_*string\": \"John@gmail.com\",\n    \"phoneNumber_*number\": 9787643445,\n    \"topic_*string\": \"Routing and Account Number\",\n    \"message_*string\": \"Unable to find my routing number.\",\n    \"availableTime_*string\": \"nighttime\",\n    \"chatHistory_*string\": \"html formatted message sent as string\",\n    \"cif_*number\": 1045310,\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"authType_*string\": \"Unauthorized\",\n    \"firstName_*string\": \"James\",\n    \"lastName_*string\": \"William\",\n    \"email_*string\": \"John@gmail.com\",\n    \"phoneNumber_*number\": 9787643445,\n    \"topic_*string\": \"Routing and Account Number\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"authType_*string\": \"Authorized\",\n    \"firstName_*string\": \"James\",\n    \"lastName_*string\": \"William\",\n    \"email_*string\": \"John@gmail.com\",\n    \"phoneNumber_*number\": 9787643445,\n    \"topic_*string\": \"Invalid Topic\",\n    \"message_*string\": \"Unable to find my routing number.\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"authType_*string\": \"Authorized\",\n    \"firstName_*string\": \"James\",\n    \"lastName_*string\": \"William\",\n    \"email_*string\": \"Invalid Email\",\n    \"phoneNumber_*number\": 9787643445,\n    \"topic_*string\": \"Routing and Account Number\",\n    \"message_*string\": \"Unable to find my routing number.\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"locateProfile":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/locateProfile.json","feedback":[],"name":"locateProfile","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for locateProfile for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: accountNumber\n\n        pm.test(`'responseData field has accountNumber that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n            const value = responseData?.accountNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: cardDetails\n\n        pm.test(`'responseData field has cardDetails that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cardDetails`)) {\n            const value = responseData?.cardDetails;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: cardNumber\n\n        pm.test(`'responseData.cardDetails field has cardNumber that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n            const value = responseData.cardDetails?.cardNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: expiryDate\n\n        pm.test(`'responseData.cardDetails field has expiryDate that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`expiryDate`)) {\n            const value = responseData.cardDetails?.expiryDate;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: cvv\n\n        pm.test(`'responseData.cardDetails field has cvv that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cvv`)) {\n            const value = responseData.cardDetails?.cvv;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: pin\n\n        pm.test(`'responseData.cardDetails field has pin that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pin`)) {\n            const value = responseData.cardDetails?.pin;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalQuestions\n\n        pm.test(`'responseData field has personalQuestions that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalQuestions`)) {\n            const value = responseData?.personalQuestions;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: DOB\n\n        pm.test(`'responseData.personalQuestions field has DOB that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`DOB`)) {\n            const value = responseData.personalQuestions?.DOB;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: SSN\n\n        pm.test(`'responseData.personalQuestions field has SSN that is of type number'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`SSN`)) {\n            const value = responseData.personalQuestions?.SSN;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: SecretPassword\n\n        pm.test(`'responseData.personalQuestions field has SecretPassword that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`SecretPassword`)) {\n            const value = responseData.personalQuestions?.SecretPassword;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: LDAmount\n\n        pm.test(`'responseData.personalQuestions field has LDAmount that is of type number'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`LDAmount`)) {\n            const value = responseData.personalQuestions?.LDAmount;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: AccNumber\n\n        pm.test(`'responseData.personalQuestions field has AccNumber that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`AccNumber`)) {\n            const value = responseData.personalQuestions?.AccNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ssNumber\n\n        pm.test(`'responseData field has ssNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ssNumber`)) {\n            const value = responseData?.ssNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ssnShort\n\n        pm.test(`'responseData field has ssnShort that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ssnShort`)) {\n            const value = responseData?.ssnShort;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alternatePhoneNumber\n\n        pm.test(`'responseData field has alternatePhoneNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alternatePhoneNumber`)) {\n            const value = responseData?.alternatePhoneNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: email\n\n        pm.test(`'responseData field has email that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationNumber\n\n        pm.test(`'responseData field has identificationNumber that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationNumber`)) {\n            const value = responseData?.identificationNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationType\n\n        pm.test(`'responseData field has identificationType that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationType`)) {\n            const value = responseData?.identificationType;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: image\n\n        pm.test(`'responseData field has image that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`image`)) {\n            const value = responseData?.image;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isAlternateMobileNumber\n\n        pm.test(`'responseData field has isAlternateMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n            const value = responseData?.isAlternateMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isPrimaryMobileNumber\n\n        pm.test(`'responseData field has isPrimaryMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isPrimaryMobileNumber`)) {\n            const value = responseData?.isPrimaryMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalBanker\n\n        pm.test(`'responseData field has personalBanker that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalBanker`)) {\n            const value = responseData?.personalBanker;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: name\n\n        pm.test(`'responseData.personalBanker field has name that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.personalBanker?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: email\n\n        pm.test(`'responseData.personalBanker field has email that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData.personalBanker?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: mobileNumber\n\n        pm.test(`'responseData.personalBanker field has mobileNumber that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n            const value = responseData.personalBanker?.mobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: phone\n\n        pm.test(`'responseData field has phone that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`phone`)) {\n            const value = responseData?.phone;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'securityQuestions' as type array'`, function() {\n          const value = responseData?.securityQuestions;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: segmentId\n\n        pm.test(`'responseData field has segmentId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`segmentId`)) {\n            const value = responseData?.segmentId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'multiAccounts' as type array'`, function() {\n          const value = responseData?.multiAccounts;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.multiAccounts field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`multiAccounts`)) {\n            let multiAccountsArray = ld.get(responseData, `multiAccounts`, []);\n            if (Array.isArray(multiAccountsArray)) {\n              for (let multiAccounts_it = 0; multiAccounts_it < multiAccountsArray.length; multiAccounts_it++) {\n                let iterator = multiAccounts_it;\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'accountNumber' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.accountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'cardDetails' as type 'object'`, function() {\n                    const value = multiAccountsArray[iterator]?.cardDetails;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: cardNumber\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has cardNumber that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.cardNumber;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.cardNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: expiryDate\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has expiryDate that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`expiryDate`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.expiryDate;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.expiryDate`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: cvv\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has cvv that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`cvv`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.cvv;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.cvv`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: pin\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has pin that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`pin`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.pin;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.pin`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'personalQuestions' as type 'object'`, function() {\n                    const value = multiAccountsArray[iterator]?.personalQuestions;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: DOB\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has DOB that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`DOB`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.DOB;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.DOB`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: SSN\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has SSN that is of type number'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`SSN`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.SSN;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.SSN`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: SecretPassword\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has SecretPassword that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`SecretPassword`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.SecretPassword;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.SecretPassword`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: LDAmount\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has LDAmount that is of type number'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`LDAmount`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.LDAmount;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.LDAmount`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: AccNumber\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has AccNumber that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`AccNumber`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.AccNumber;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.AccNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'ssNumber' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.ssNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'ssnShort' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.ssnShort;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'alternatePhoneNumber' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.alternatePhoneNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'customerId' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.customerId;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'email' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.email;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'identificationNumber' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.identificationNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'identificationType' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.identificationType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'location' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.location;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'name' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.name;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'phone' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.phone;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'warningCodes' as type array'`, function() {\n          const value = responseData?.warningCodes;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.warningCodes field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`warningCodes`)) {\n            let warningCodesArray = ld.get(responseData, `warningCodes`, []);\n            if (Array.isArray(warningCodesArray)) {\n              for (let warningCodes_it = 0; warningCodes_it < warningCodesArray.length; warningCodes_it++) {\n                let iterator = warningCodes_it;\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'code' as type 'number'`, function() {\n                    const value = warningCodesArray[iterator]?.code;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'level' as type 'string'`, function() {\n                    const value = warningCodesArray[iterator]?.level;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'description' as type 'string'`, function() {\n                    const value = warningCodesArray[iterator]?.description;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"locateProfile_POST_5f16724a1e","jsonData":"[\n  {\n    \"accountNumber_*string\": \"ACC123456\",\n    \"customerId_*string\": \"CUST78910\",\n    \"ssNumber_*string\": \"SSN111213\",\n    \"ssnShort_*string\": \"SSNS1415\",\n    \"statusCode\": 200,\n    \"scenario\": \"success\"\n  },\n  {\n    \"accountNumber_*string\": \"ACC234567\",\n    \"customerId_*string\": \"CUST891011\",\n    \"ssNumber_*string\": \"SSN121314\",\n    \"statusCode\": 200,\n    \"scenario\": \"success\"\n  },\n  {\n    \"accountNumber_*string\": \"ACC345678\",\n    \"customerId_*string\": \"CUST9101112\",\n    \"ssnShort_*string\": \"SSNS1516\",\n    \"statusCode\": 200,\n    \"scenario\": \"success\"\n  },\n  {\n    \"accountNumber_*string\": \"ACC456789\",\n    \"ssNumber_*string\": \"SSN131415\",\n    \"ssnShort_*string\": \"SSNS1617\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*string\": \"CUST10111213\",\n    \"ssNumber_*string\": \"SSN141516\",\n    \"ssnShort_*string\": \"SSNS1718\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"accountNumber_*string\": \"ACC567890\",\n    \"customerId_*string\": \"CUST11121314\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"accountNumber_*string\": \"ACC678901\",\n    \"customerId_*string\": \"CUST12131415\",\n    \"ssNumber_*string\": \"SSN151617\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"accountNumber_*string\": \"ACC789012\",\n    \"ssnShort_*string\": \"SSNS1819\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*string\": \"CUST13141516\",\n    \"ssNumber_*string\": \"SSN161718\",\n    \"ssnShort_*string\": \"SSNS1920\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"validateUser":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_validate_the_exiting_user.json","feedback":[],"name":"to validate the exiting user","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validateUser for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PINs matched\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"validateUser_POST_8499332c16","jsonData":"[\n  {\n    \"sourcePin_*string\": \"1234\",\n    \"targetPin_*string\": \"5678\",\n    \"statusCode\": 200,\n    \"scenario\": \"PINs matched\"\n  },\n  {\n    \"sourcePin_*string\": \"4321\",\n    \"targetPin_*string\": \"8765\",\n    \"statusCode\": 200,\n    \"scenario\": \"PINs matched\"\n  },\n  {\n    \"sourcePin_*string\": \"1111\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"targetPin_*string\": \"2222\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"sourcePin_*string\": \"3333\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"targetPin_*string\": \"4444\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"sourcePin_*string\": \"5555\",\n    \"targetPin_*string\": \"6666\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"sourcePin_*string\": \"7777\",\n    \"targetPin_*string\": \"8888\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  }\n]"}},"validatePIN":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_validate_the_pins_entered_by_the_new_user.json","feedback":[],"name":"to validate the pins entered by the new user","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePIN for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PINs matched\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"validatePIN_POST_6008bf4553","jsonData":"[\n  {\n    \"sourcePin_*string\": \"1234\",\n    \"targetPin_*string\": \"5678\",\n    \"profileInfo.customerId_*string\": \"CUST123\",\n    \"profileInfo.accountNumber_*string\": \"ACC456\",\n    \"profileInfo.ssn_*string\": \"SSN789\",\n    \"statusCode\": 200,\n    \"scenario\": \"PINs matched\"\n  },\n  {\n    \"sourcePin_*string\": \"2345\",\n    \"targetPin_*string\": \"6789\",\n    \"profileInfo.customerId_*string\": \"CUST234\",\n    \"profileInfo.accountNumber_*string\": \"ACC567\",\n    \"profileInfo.ssn_*string\": \"SSN890\",\n    \"statusCode\": 200,\n    \"scenario\": \"PINs matched\"\n  },\n  {\n    \"sourcePin_*string\": \"3456\",\n    \"targetPin_*string\": \"7890\",\n    \"profileInfo.customerId_*string\": \"CUST345\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"sourcePin_*string\": \"4567\",\n    \"targetPin_*string\": \"8901\",\n    \"profileInfo.accountNumber_*string\": \"ACC678\",\n    \"profileInfo.ssn_*string\": \"SSN901\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"sourcePin_*string\": \"5678\",\n    \"targetPin_*string\": \"9012\",\n    \"profileInfo.customerId_*string\": \"CUST456\",\n    \"profileInfo.accountNumber_*string\": \"ACC789\",\n    \"profileInfo.ssn_*string\": \"SSN012\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"sourcePin_*string\": \"6789\",\n    \"targetPin_*string\": \"0123\",\n    \"profileInfo.customerId_*string\": \"CUST567\",\n    \"profileInfo.accountNumber_*string\": \"ACC890\",\n    \"profileInfo.ssn_*string\": \"SSN123\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"validatePINRules":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_validate_if_pin_entered_by_new_user_follows_pin.json","feedback":[],"name":"to validate if pin entered by new user follows pin rules","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePINRules for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PIN rules satisfied\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"validatePINRules_POST_a87e701c05","jsonData":"[\n  {\n    \"sourcePin_*string\": \"1234AB\",\n    \"statusCode\": 200,\n    \"scenario\": \"PIN rules satisfied\"\n  },\n  {\n    \"sourcePin_*string\": \"5678CD\",\n    \"statusCode\": 200,\n    \"scenario\": \"PIN rules satisfied\"\n  },\n  {\n    \"sourcePin_*string\": \"9012EF\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"sourcePin_*string\": \"3456GH\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"sourcePin_*string\": \"7890IJ\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"sourcePin_*string\": \"2345KL\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"getRequestStatus":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_fetch_the_account_closure_status.json","feedback":[],"name":"to fetch the account closure status","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for getRequestStatus for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"getRequestStatus_POST_ee52ef511c","jsonData":"[\n  {\n    \"_0.accountName_*string\": \"John Doe\",\n    \"_0.accountNumber_*string\": \"ACC123456\",\n    \"_0.customerId_*number\": 123456,\n    \"_0.description_*string\": \"Account details for John Doe\",\n    \"_0.estimation_*number\": 1000,\n    \"_0.modifyDate_*number\": 20220215,\n    \"_0.requestDate_*number\": 20220214,\n    \"_0.requestId_*string\": \"REQ123456\",\n    \"_0.requestSubType_*string\": \"Account\",\n    \"_0.requestType_*string\": \"Update\",\n    \"_0.status_*string\": \"Active\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"_0.accountName_*string\": \"John Doe\",\n    \"_0.accountNumber_*string\": \"ACC123456\",\n    \"_0.customerId_*number\": 123456,\n    \"_0.description_*string\": \"Account details for John Doe\",\n    \"_0.estimation_*number\": 1000,\n    \"_0.modifyDate_*number\": 20220215,\n    \"_0.requestDate_*number\": 20220214,\n    \"_0.requestId_*string\": \"REQ123456\",\n    \"_0.requestSubType_*string\": \"Account\",\n    \"_0.requestType_*string\": \"Update\",\n    \"_0.status_*string\": \"Active\",\n    \"_1.accountName_*string\": \"Jane Doe\",\n    \"_1.accountNumber_*string\": \"ACC654321\",\n    \"_1.customerId_*number\": 654321,\n    \"_1.description_*string\": \"Account details for Jane Doe\",\n    \"_1.estimation_*number\": 2000,\n    \"_1.modifyDate_*number\": 20220215,\n    \"_1.requestDate_*number\": 20220214,\n    \"_1.requestId_*string\": \"REQ654321\",\n    \"_1.requestSubType_*string\": \"Account\",\n    \"_1.requestType_*string\": \"Update\",\n    \"_1.status_*string\": \"Active\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"_0.accountName_*string\": \"John Doe\",\n    \"_0.accountNumber_*string\": \"ACC123456\",\n    \"_0.customerId_*number\": 123456,\n    \"_0.description_*string\": \"Account details for John Doe\",\n    \"_0.estimation_*number\": 1000,\n    \"_0.modifyDate_*number\": 20220215,\n    \"_0.requestDate_*number\": 20220214,\n    \"_0.requestId_*string\": \"REQ123456\",\n    \"_0.requestSubType_*string\": \"Account\",\n    \"_0.requestType_*string\": \"Update\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"_0.accountName_*string\": \"John Doe\",\n    \"_0.accountNumber_*string\": \"ACC123456\",\n    \"_0.customerId_*number\": 123456,\n    \"_0.description_*string\": \"Account details for John Doe\",\n    \"_0.estimation_*number\": 1000,\n    \"_0.modifyDate_*number\": 20220215,\n    \"_0.requestDate_*number\": 20220214,\n    \"_0.requestId_*string\": \"REQ123456\",\n    \"_0.requestSubType_*string\": \"Account\",\n    \"_0.requestType_*string\": \"Update\",\n    \"_0.status_*string\": \"Inactive\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"_0.accountName_*string\": \"John Doe\",\n    \"_0.accountNumber_*string\": \"ACC123456\",\n    \"_0.customerId_*number\": 123456,\n    \"_0.description_*string\": \"Account details for John Doe\",\n    \"_0.estimation_*number\": 1000,\n    \"_0.modifyDate_*number\": 20220215,\n    \"_0.requestDate_*number\": 20220214,\n    \"_0.requestId_*string\": \"REQ123456\",\n    \"_0.requestSubType_*string\": \"Account\",\n    \"_0.requestType_*string\": \"Update\",\n    \"_0.status_*string\": \"Active\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"request":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_place_the_request.json","feedback":[],"name":"to place the request","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for request for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"request_POST_cf0bbf823c","jsonData":"[\n  {\n    \"accountName_*string\": \"John Doe\",\n    \"accountNumber_*string\": \"1234567890\",\n    \"customerId_*number\": 12345,\n    \"cardNumber_*string\": \"9876543210\",\n    \"description_*string\": \"Money Transfer\",\n    \"requestSubType_*string\": \"Online\",\n    \"requestType_*string\": \"Immediate\",\n    \"serviceType_*string\": \"Banking\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"accountName_*string\": \"Jane Doe\",\n    \"accountNumber_*string\": \"0987654321\",\n    \"customerId_*number\": 67890,\n    \"cardNumber_*string\": \"1234567890\",\n    \"description_*string\": \"Bill Payment\",\n    \"requestSubType_*string\": \"Mobile\",\n    \"requestType_*string\": \"Scheduled\",\n    \"serviceType_*string\": \"Banking\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"accountName_*string\": \"John Doe\",\n    \"accountNumber_*string\": \"1234567890\",\n    \"customerId_*number\": 12345,\n    \"description_*string\": \"Money Transfer\",\n    \"requestSubType_*string\": \"Online\",\n    \"requestType_*string\": \"Immediate\",\n    \"serviceType_*string\": \"Banking\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"accountName_*string\": \"Jane Doe\",\n    \"accountNumber_*string\": \"0987654321\",\n    \"customerId_*number\": 67890,\n    \"cardNumber_*string\": \"1234567890\",\n    \"description_*string\": \"Bill Payment\",\n    \"requestSubType_*string\": \"Mobile\",\n    \"requestType_*string\": \"Scheduled\",\n    \"serviceType_*string\": \"Banking\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"accountName_*string\": \"John Doe\",\n    \"accountNumber_*string\": \"1234567890\",\n    \"customerId_*number\": 12345,\n    \"cardNumber_*string\": \"9876543210\",\n    \"description_*string\": \"Money Transfer\",\n    \"requestSubType_*string\": \"Online\",\n    \"requestType_*string\": \"Immediate\",\n    \"serviceType_*string\": \"Banking\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"enableEStatement":{"PUT":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_enable_or_disable_e_or_paper_statements_at_prof.json","feedback":[],"name":"to enable or disable e or paper statements at profile level","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for enableEStatement for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"enableEStatement_PUT_f5b18e780a","jsonData":"[\n  {\n    \"customerId_*number\": 1045300,\n    \"email_*string\": \"John@gmail.com\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"customerId_*number\": 1045301,\n    \"email_*string\": \"John@gmail.com\",\n    \"secondaryEmail_*string\": \"John1@gmail.com\",\n    \"subscribe_*boolean\": true,\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"email_*string\": \"John@gmail.com\",\n    \"secondaryEmail_*string\": \"John1@gmail.com\",\n    \"subscribe_*boolean\": true,\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_*number\": 1045302,\n    \"email_*string\": \"John@gmail.com\",\n    \"secondaryEmail_*string\": \"John1@gmail.com\",\n    \"subscribe_*boolean\": \"invalid_boolean\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"customerId_*number\": \"invalid_number\",\n    \"email_*string\": \"John@gmail.com\",\n    \"secondaryEmail_*string\": \"John1@gmail.com\",\n    \"subscribe_*boolean\": true,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"email_*string\": \"John@gmail.com\",\n    \"secondaryEmail_*string\": \"John1@gmail.com\",\n    \"subscribe_*boolean\": true,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  }\n]"}},"RequestChequeBook":{"PUT":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_update_the_cheque_book_details_of_customer_acco.json","feedback":[],"name":"to update the cheque book details of customer accounts","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for RequestChequeBook for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"RequestChequeBook_PUT_53e88e310b","jsonData":"[\n  {\n    \"accountNumber_*string\": \"1042345\",\n    \"customerId_*number\": 1045300,\n    \"numberOfChequeBooks_*number\": 2,\n    \"numberOfLeaves_*number\": 50,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"accountNumber_*string\": \"1042346\",\n    \"customerId_*number\": 1045301,\n    \"numberOfChequeBooks_*number\": 3,\n    \"statusCode\": 200,\n    \"scenario\": \"successful operation\"\n  },\n  {\n    \"accountNumber_*string\": \"1042347\",\n    \"customerId_*number\": 1045302,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"accountNumber_*string\": \"1042348\",\n    \"numberOfChequeBooks_*number\": 4,\n    \"numberOfLeaves_*number\": 100,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_*number\": 1045303,\n    \"numberOfChequeBooks_*number\": 5,\n    \"numberOfLeaves_*number\": 150,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"accountNumber_*string\": \"1042349\",\n    \"customerId_*number\": 1045304,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"sendOTP":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/sendOTP.json","feedback":[],"name":"sendOTP","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"verification code has been sent to your mobile number\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"sendOTP_POST_bd4bbafd53","jsonData":"[\n  {\n    \"customerId_number\": 1045300,\n    \"statusCode\": 200,\n    \"scenario\": \"verification code has been sent to your mobile number\"\n  },\n  {\n    \"customerId_number\": 1045301,\n    \"statusCode\": 200,\n    \"scenario\": \"verification code has been sent to your mobile number\"\n  },\n  {\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_number\": 1045302,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_number\": 1045303,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"verifyOTP":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/verifyOTP.json","feedback":[],"name":"verifyOTP","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for verifyOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"OTP verifid successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"verifyOTP_POST_a28d82fa8b","jsonData":"[\n  {\n    \"code_1\": 1234,\n    \"customerId_1\": 1045300,\n    \"statusCode\": 200,\n    \"scenario\": \"OTP verified successfully\"\n  },\n  {\n    \"code_2\": 5678,\n    \"customerId_2\": 1045301,\n    \"statusCode\": 200,\n    \"scenario\": \"OTP verified successfully\"\n  },\n  {\n    \"code_3\": 9012,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"customerId_3\": 1045302,\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  },\n  {\n    \"code_4\": 3456,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"customerId_4\": 1045303,\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  }\n]"}},"deeplink":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/pw-api-openai-github-1763639890489/swagger/datasets/to_fetch_the_deeplink.json","feedback":[],"name":"to fetch the deeplink","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deeplink for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: usecase\n\n              pm.test(`'item field has usecase that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usecase`)) {\n                  const value = item?.usecase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: link\n\n              pm.test(`'item field has link that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`link`)) {\n                  const value = item?.link;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: linkType\n\n              pm.test(`'item field has linkType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`linkType`)) {\n                  const value = item?.linkType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"deeplink_POST_6d171bfc26","jsonData":"[\n  {\n    \"usecase_0_*string\": \"Test Case 1\",\n    \"usecase_1_*string\": \"API Testing\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"usecase_0_*string\": \"Test Case 2\",\n    \"usecase_1_*string\": \"API Testing with optional fields\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"usecase_0_*string\": \"Test Case 3\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"usecase_0_*string\": \"Test Case 4\",\n    \"usecase_1_*string\": \"Invalid API Testing\",\n    \"statusCode\": 400,\n    \"scenario\": \"Bad Request\"\n  },\n  {\n    \"usecase_0_*string\": \"Test Case 5\",\n    \"usecase_1_*string\": \"Invalid API Testing with invalid request params\",\n    \"statusCode\": 404,\n    \"scenario\": \"Error: Not Found\"\n  },\n  {\n    \"usecase_0_*string\": \"Test Case 6\",\n    \"usecase_1_*string\": \"API Testing without authorization\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error: Authorisation failed.\"\n  }\n]"}},"testFilePath":"/var/tmp/Roost/RoostGPT/pw-api-openai-github-1763639890489/458a3327-63a1-4cdb-bea8-38de438a6be3/source/api-spec/postman_collections/pw-api-openai-github-1763639890489/swagger/roost_postman_swagger_1763640455.json"}}}