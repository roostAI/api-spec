{"postmanCollection":{"filePaths":["/var/tmp/Roost/RoostGPT/Oct-24-Gemini-org/77ecdff9-7e8f-455a-af8f-1233678fce31/source/api-spec/postman_collections/modified_postman_Experian Address Validation.postman_collection.json"]},"headBranch":"roost-77ecdff9-7e8f-455a-af8f-1233678fce31","reportHeadBranch":"roost-report","aiUsage":{"promptTokens":9230,"completionTokens":5294,"apiCallsToAI":9},"repoPath":"/var/tmp/Roost/RoostGPT/Oct-24-Gemini-org/77ecdff9-7e8f-455a-af8f-1233678fce31/source/api-spec","errorMsg":"","gitPrUrl":"","status":"","statusDetails":"","coverageReportURL":{},"testReportURL":{},"testMetrics":{"filesScanned":1,"totalFiles":1,"totalTestFiles":9,"successfulTests":9,"testWithCompilationErrors":0,"skippedMethods":3,"toBeProcessed":3,"testswithRunTimeErrors":0,"existingTestPresent":0,"notSupported":0,"methodsScanned":12,"methodsSuccess":9},"advancedDetails":{"/var/tmp/Roost/RoostGPT/Oct-24-Gemini-org/77ecdff9-7e8f-455a-af8f-1233678fce31/Experian Address Validation.postman_collection.json":{"address/format/v1/{global_address_key}":{"GET":{"status":"to_be_processed","description":"method not processed yet","jsonFilePath":"","feedback":[],"name":"Format the address with the supplied key."},"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Format_the_address_with_the_supplied_key_using_a_c.json","feedback":[],"name":"Format the address with the supplied key using a custom layout.","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/format/v1/{global_address_key} for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.global_address_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.global_address_key`)) {\n                    const value = ld.get(jsonResponse, `result.global_address_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.global_address_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address`)) {\n                    const value = ld.get(jsonResponse, `result.address`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.address:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_1` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_1`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_1`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.address_line_1:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_2`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_3` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_3`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.locality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.locality`)) {\n                    const value = ld.get(jsonResponse, `result.address.locality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.locality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.region`)) {\n                    const value = ld.get(jsonResponse, `result.address.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.postal_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.postal_code`)) {\n                    const value = ld.get(jsonResponse, `result.address.postal_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.postal_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.country`)) {\n                    const value = ld.get(jsonResponse, `result.address.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components`)) {\n                    const value = ld.get(jsonResponse, `result.components`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_name`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_iso_3` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_iso_3`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_iso_3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_3 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_3 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_iso_3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_iso_2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_iso_2`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_iso_2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_iso_2:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_2 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_2`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_iso_2:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_2 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_2`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_iso_2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.postal_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.postal_code`)) {\n                    const value = ld.get(jsonResponse, `result.components.postal_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.postal_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.sub_building` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.sub_building`)) {\n                    const value = ld.get(jsonResponse, `result.components.sub_building`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.sub_building:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.building` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.building`)) {\n                    const value = ld.get(jsonResponse, `result.components.building`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.building:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.street` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.street`)) {\n                    const value = ld.get(jsonResponse, `result.components.street`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.street:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.locality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.locality`)) {\n                    const value = ld.get(jsonResponse, `result.components.locality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.locality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata`)) {\n                    const value = ld.get(jsonResponse, `metadata`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_info` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_info`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_info`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_info:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_info.identifier` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_info.identifier`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_info.identifier`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_info.identifier:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.barcode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode.delivery_point_barcode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode.delivery_point_barcode`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode.delivery_point_barcode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.delivery_point_barcode length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.delivery_point_barcode`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.delivery_point_barcode length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.delivery_point_barcode`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode.sort_plan_number` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode.sort_plan_number`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode.sort_plan_number`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.sort_plan_number length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.sort_plan_number`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.sort_plan_number length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.sort_plan_number`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_classification` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_classification`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_classification`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_classification:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_classification.delivery_type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_classification.delivery_type`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_classification.delivery_type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.address_classification.delivery_type length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.address_classification.delivery_type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.address_classification.delivery_type length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.address_classification.delivery_type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/format/v1/{global_address_key}_POST_238c0380e6","jsonData":"[\n  {\n    \"global_address_key\": \"QVVTfjcuNzMwak9BVVNIQXpsQndBQUFBQUJBd0VBQUFBQk9uQ09FWUFoQUFJUUNDQUFBQUFBQVFBMk5UUTVBRFlBQVAuLlFnQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBVENBMk5UUTVJRk4wSUV0cGJHUmhJRkprSURVME9RQUFBQUFBfjIy\",\n    \"layouts_0_*string\": \"AddressLine1,Locality,Region,PostalCode\",\n    \"layout_format_*string\": \"Default\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"global_address_key\": \"USAfjE5Mwak9BVVNIQXpsQndBQUFBQUJBd0VBQUFBQk9uQ09FWUFoQUFJUUNDQUFBQUFBQVFBMk5UUTVBRFlBQVAuLlFnQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBVENBMk5UUTVJRk4wSUV0cGJHUmhJRkprSURVME9RQUFBQUFBfjM0\",\n    \"layouts_0_*string\": \"Street,City,State,ZipCode\",\n    \"layout_format_*string\": \"Standard\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"global_address_key\": \"CANfjA4Nzak9BVVNIQXpsQndBQUFBQUJBd0VBQUFBQk9uQ09FWUFoQUFJUUNDQUFBQUFBQVFBMk5UUTVBRFlBQVAuLlFnQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBVENBMk5UUTVJRk4wSUV0cGJHUmhJRkprSURVME9RQUFBQUFBfjU5\",\n    \"layouts_0_*string\": \"BuildingNumber,StreetName,City,Province,PostalCode\",\n    \"layout_format_*string\": \"International\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"global_address_key\": \"GBRfjI2ODak9BVVNIQXpsQndBQUFBQUJBd0VBQUFBQk9uQ09FWUFoQUFJUUNDQUFBQUFBQVFBMk5UUTVBRFlBQVAuLlFnQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBVENBMk5UUTVJRk4wSUV0cGJHUmhJRkprSURVME9RQUFBQUFBfjEx\",\n    \"layouts_0_*string\": \"Locality,PostalCode,Country\",\n    \"layout_format_*string\": \"Compact\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"address/suggestions/stepin/v1/{global_address_key}":{"GET":{"status":"to_be_processed","description":"method not processed yet","jsonFilePath":"","feedback":[],"name":"Step into a suggestion."}},"address/suggestions/refine/v1/{key}":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Refine_a_suggestion.json","feedback":[],"name":"Refine a suggestion.","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/suggestions/refine/v1/{key} for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_key`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_prompt` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_prompt`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_prompt`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.suggestions[${suggestions_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'additional_attributes' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].additional_attributes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].additional_attributes`)) {\n                    let additional_attributesArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].additional_attributes`, []);\n                    if (Array.isArray(additional_attributesArray)) {\n                        for (let additional_attributes_it = 0; additional_attributes_it < additional_attributesArray.length; additional_attributes_it++) {\n                            let iterator = additional_attributes_it;\n                            if (additional_attributesArray[additional_attributes_it] !== null && additional_attributesArray[additional_attributes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value' has 'value' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/suggestions/refine/v1/{key}_POST_7d5e3d0797","jsonData":"[\n  {\n    \"key\": \"R0JSfjcuNzMwUk1HQlJGQWpsQndBQUFBQUJBUUVBQVFBQUFBQ0ltWHVSZ0NFd2doTUFJQUFBQUFBQkFFRndZWEowYldWdWRDQXhOUUEzT1FBQS4uOVFBQUFBQVAuLi4uOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUEtLX40Mg\",\n    \"refinement_*string\": \"Apartment 15\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"key\": \"R0JSfjcuNzMwVU9HQlJGQWpsQndBQUFBQUJBd0VBQUFBQWlKbDdrWUFoTUlJVEFDQUFBQUFBQVFCQmNHRnlkRzFsYm5RZ01UVUFOemtBQVAuLlVBQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBUVhCaGNuUnRaVzUwSURFMUxDQTNPU0JUZEdGMGFXOXVJRkp2WVdRc0lFdEZURlJaTENCR2FXWmxBQUFBQUFBLX40Mg\",\n    \"refinement_*string\": \"79 Station Road\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"key\": \"R0JSfjcuNzMwUk1HQlJGQWpsQndBQUFBQUJBUUVBQVFBQUFBQ0ltWHVSZ0NFd2doTUFJQUFBQUFBQkFFRndZWEowYldWdWRDQXhOUUEzT1FBQS4uOVFBQUFBQVAuLi4uOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUEtLX40Mg\",\n    \"refinement_*string\": \"KELTY\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"key\": \"R0JSfjcuNzMwVU9HQlJGQWpsQndBQUFBQUJBd0VBQUFBQWlKbDdrWUFoTUlJVEFDQUFBQUFBQVFCQmNHRnlkRzFsYm5RZ01UVUFOemtBQVAuLlVBQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBUVhCaGNuUnRaVzUwSURFMUxDQTNPU0JUZEdGMGFXOXVJRkp2WVdRc0lFdEZURlJaTENCR2FXWmxBQUFBQUFBLX40Mg\",\n    \"refinement_*string\": \"Fife KY4 0BL\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"address/suggestions/format/v1":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Search_and_format_a_list_of_suggestions.json","feedback":[],"name":"Search and format a list of suggestions.","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/suggestions/format/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'addresses_formatted' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].addresses_formatted`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].addresses_formatted:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].addresses_formatted length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].addresses_formatted`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].addresses_formatted:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].addresses_formatted length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].addresses_formatted`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].addresses_formatted:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].addresses_formatted field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].addresses_formatted`)) {\n                    let addresses_formattedArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].addresses_formatted`, []);\n                    if (Array.isArray(addresses_formattedArray)) {\n                        for (let addresses_formatted_it = 0; addresses_formatted_it < addresses_formattedArray.length; addresses_formatted_it++) {\n                            let iterator = addresses_formatted_it;\n                            if (addresses_formattedArray[addresses_formatted_it] !== null && addresses_formattedArray[addresses_formatted_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name' has 'layout_name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].address' has 'address' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].address`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].address:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].addresses_formatted:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/suggestions/format/v1_POST_e044638dd0","jsonData":"[\n  {\n    \"country_iso_*string\": \"GBR\",\n    \"datasets_0_*string\": \"GBR_Postcode-Address-File\",\n    \"max_suggestions_*number\": 10,\n    \"components.unspecified_0_*string\": \"Axon Communications, 160 Blackfriars Road\",\n    \"layouts_0_*string\": \"default_classic\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"USA\",\n    \"datasets_0_*string\": \"USA_Zip-Address-File\",\n    \"max_suggestions_*number\": 5,\n    \"components.unspecified_0_*string\": \"1600 Pennsylvania Avenue NW\",\n    \"layouts_0_*string\": \"default_vanilla\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"AUS\",\n    \"datasets_0_*string\": \"AUS_G-NAF\",\n    \"max_suggestions_*number\": 15,\n    \"components.unspecified_0_*string\": \"Sydney Opera House\",\n    \"layouts_0_*string\": \"default_typedown\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"CAN\",\n    \"datasets_0_*string\": \"CAN_Address-Complete\",\n    \"max_suggestions_*number\": 8,\n    \"components.unspecified_0_*string\": \"123 Main Street, Toronto\",\n    \"layouts_0_*string\": \"default_classic\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"address/datasets/v1?country_iso={{country_iso}}":{"GET":{"status":"to_be_processed","description":"method not processed yet","jsonFilePath":"","feedback":[],"name":"Get the available datasets for the supplied country."}},"address/layouts/v1":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Get_the_available_layouts_for_the_supplied_country.json","feedback":[],"name":"Get the available layouts for the supplied country.","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/layouts/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result:\", error.message);\n            }\n        })\n  \n        pm.test(`result length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result:\", error.message);\n            }\n        })\n  \n        pm.test(`result length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    let resultArray = ld.get(jsonResponse, `result`, []);\n                    if (Array.isArray(resultArray)) {\n                        for (let result_it = 0; result_it < resultArray.length; result_it++) {\n                            let iterator = result_it;\n                            if (resultArray[result_it] !== null && resultArray[result_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result[${result_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result[${result_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result[${result_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result[${result_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result[${result_it}].country_iso_3' has 'country_iso_3' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].country_iso_3 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].country_iso_3 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultArray' has 'datasets' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result[${result_it}].datasets:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].datasets length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result[${result_it}].datasets:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].datasets length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result[${result_it}].datasets:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/layouts/v1_POST_a5e3dd2c7f","jsonData":"[\n  {\n    \"country_iso_*string\": \"USA\",\n    \"datasets_0_*string\": \"population_estimates\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"CAN\",\n    \"datasets_0_*string\": \"gdp_growth_rate\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"GBR\",\n    \"datasets_0_*string\": \"unemployment_rate\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"IND\",\n    \"datasets_0_*string\": \"inflation_consumer_prices\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"AUS\",\n    \"datasets_0_*string\": \"life_expectancy_at_birth\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"address/lookup/v1":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Lookup_an_address_based_on_a_key.json","feedback":[],"name":"Lookup an address based on a key.","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/lookup/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_key`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_prompt` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_prompt`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_prompt`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.suggestions[${suggestions_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'additional_attributes' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].additional_attributes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].additional_attributes`)) {\n                    let additional_attributesArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].additional_attributes`, []);\n                    if (Array.isArray(additional_attributesArray)) {\n                        for (let additional_attributes_it = 0; additional_attributes_it < additional_attributesArray.length; additional_attributes_it++) {\n                            let iterator = additional_attributes_it;\n                            if (additional_attributesArray[additional_attributes_it] !== null && additional_attributesArray[additional_attributes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value' has 'value' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/lookup/v1_POST_9f5659155d","jsonData":"[\n  {\n    \"country_iso_*string\": \"GBR\",\n    \"datasets_0_*string\": \"address\",\n    \"key.type_*string\": \"udprn\",\n    \"key.value_*number\": 83937362,\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"USA\",\n    \"datasets_0_*string\": \"contact_details\",\n    \"key.type_*string\": \"customer_id\",\n    \"key.value_*number\": 10293847,\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"CAN\",\n    \"datasets_0_*string\": \"demographics\",\n    \"key.type_*string\": \"household_id\",\n    \"key.value_*number\": 56473829,\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"AUS\",\n    \"datasets_0_*string\": \"property_info\",\n    \"key.type_*string\": \"property_ref\",\n    \"key.value_*number\": 77889901,\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"NZL\",\n    \"datasets_0_*string\": \"address_verification\",\n    \"key.type_*string\": \"address_key\",\n    \"key.value_*number\": 99123456,\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"address/lookup/v2":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Lookup_an_address_based_on_a_key_V2.json","feedback":[],"name":"Lookup an address based on a key V2","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/lookup/v2 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].locality' has 'locality' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].locality`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].locality:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].locality.town' has 'town' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].locality.town`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].locality.town:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].locality.town.name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].locality.town.name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].locality.town.name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].locality.town.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].locality.town.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].locality.town.name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].locality.town.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].locality.town.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].locality.town.name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].postal_code' has 'postal_code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].postal_code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].postal_code:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].postal_code.full_name' has 'full_name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].postal_code.full_name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].postal_code.full_name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].postal_code.full_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].postal_code.full_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].postal_code.full_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].postal_code.full_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].postal_code.full_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].postal_code.full_name:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.addresses` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.addresses`)) {\n                    const value = ld.get(jsonResponse, `result.addresses`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.addresses:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.addresses:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.addresses:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.addresses field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.addresses`)) {\n                    let addressesArray = ld.get(jsonResponse, `result.addresses`, []);\n                    if (Array.isArray(addressesArray)) {\n                        for (let addresses_it = 0; addresses_it < addressesArray.length; addresses_it++) {\n                            let iterator = addresses_it;\n                            if (addressesArray[addresses_it] !== null && addressesArray[addresses_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.addresses[${addresses_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.addresses[${addresses_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.addresses[${addresses_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.addresses[${addresses_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.addresses[${addresses_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses[${addresses_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.addresses[${addresses_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'addressesArray' has 'matched' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.addresses[${addresses_it}].matched`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.addresses[${addresses_it}].matched:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.addresses[${addresses_it}].matched length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].matched`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.addresses[${addresses_it}].matched:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses[${addresses_it}].matched length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].matched`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.addresses[${addresses_it}].matched:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.addresses[${addresses_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.addresses[${addresses_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.addresses[${addresses_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.addresses[${addresses_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.addresses[${addresses_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses[${addresses_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.addresses[${addresses_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.addresses[${addresses_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.addresses[${addresses_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.addresses[${addresses_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.addresses[${addresses_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.addresses[${addresses_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses[${addresses_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.addresses[${addresses_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.addresses[${addresses_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.addresses[${addresses_it}].format:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.addresses:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/lookup/v2_POST_a002ae2a3c","jsonData":"[\n  {\n    \"country_iso_*string\": \"GBR\",\n    \"max_addresses_*number\": 10,\n    \"datasets_0_*string\": \"GBR_PAF\",\n    \"key.type_*string\": \"API_KEY\",\n    \"key.value_*string\": \"ak_live_aBcDeFgHiJkLmNoPqRsTuVwXyZ12345\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"USA\",\n    \"max_addresses_*number\": 5,\n    \"datasets_0_*string\": \"USA_PRO\",\n    \"key.type_*string\": \"API_KEY\",\n    \"key.value_*string\": \"ak_live_zYxWvUtSrQpOnMlKjIhGfEdCbA54321\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"AUS\",\n    \"max_addresses_*number\": 15,\n    \"datasets_0_*string\": \"AUS_PAF\",\n    \"key.type_*string\": \"AuthToken\",\n    \"key.value_*string\": \"auth_tkn_98765fedcbaZYXWVUTSRQPONMLKJIHG\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"CAN\",\n    \"max_addresses_*number\": 8,\n    \"datasets_0_*string\": \"CAN_PRO\",\n    \"key.type_*string\": \"API_KEY\",\n    \"key.value_*string\": \"ak_live_mNbVcXzLkJhGfDsApOiUyTrEwQ12345\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"NZL\",\n    \"max_addresses_*number\": 20,\n    \"datasets_0_*string\": \"NZL_PAF\",\n    \"key.type_*string\": \"API_KEY\",\n    \"key.value_*string\": \"ak_live_qWeRtYuIoPaSdFgHjKlZxCvBnM67890\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"address/promptsets/v1":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Get_the_available_prompt_sets.json","feedback":[],"name":"Get the available prompt sets.","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/promptsets/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.lines` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.lines`)) {\n                    const value = ld.get(jsonResponse, `result.lines`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.lines:\", error.message);\n            }\n        })\n  \n        pm.test(`result.lines length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.lines:\", error.message);\n            }\n        })\n  \n        pm.test(`result.lines length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.lines:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.lines field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.lines`)) {\n                    let linesArray = ld.get(jsonResponse, `result.lines`, []);\n                    if (Array.isArray(linesArray)) {\n                        for (let lines_it = 0; lines_it < linesArray.length; lines_it++) {\n                            let iterator = lines_it;\n                            if (linesArray[lines_it] !== null && linesArray[lines_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.lines[${lines_it}].prompt' has 'prompt' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.lines[${lines_it}].prompt`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.lines[${lines_it}].prompt:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.lines[${lines_it}].prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.lines[${lines_it}].prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.lines[${lines_it}].prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.lines[${lines_it}].prompt:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'linesArray' has 'suggested_input_length' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].suggested_input_length`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for result.lines[${lines_it}].suggested_input_length:\", error.message);\n            }\n        })\n  \n        pm.test('result.lines[${lines_it}].suggested_input_length maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `result.lines[${lines_it}].suggested_input_length`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for result.lines[${lines_it}].suggested_input_length:\", error.message);\n            }\n        })\n  \n        pm.test('result.lines[${lines_it}].suggested_input_length minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `result.lines[${lines_it}].suggested_input_length`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-960);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for result.lines[${lines_it}].suggested_input_length:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.lines[${lines_it}].example' has 'example' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.lines[${lines_it}].example`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.lines[${lines_it}].example:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.lines[${lines_it}].example length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].example`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.lines[${lines_it}].example:\", error.message);\n            }\n        })\n  \n        pm.test(`result.lines[${lines_it}].example length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].example`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.lines[${lines_it}].example:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.lines:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/promptsets/v1_POST_e061c9dfb0","jsonData":"[\n  {\n    \"country_iso_*string\": \"USA\",\n    \"datasets_0_*string\": \"address_data_us\",\n    \"search_type_*string\": \"address_verification\",\n    \"prompt_set_*string\": \"default_us_address\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"GBR\",\n    \"datasets_0_*string\": \"uk_postcode_database\",\n    \"search_type_*string\": \"postcode_lookup\",\n    \"prompt_set_*string\": \"uk_standard_address\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"CAN\",\n    \"datasets_0_*string\": \"canadian_business_registry\",\n    \"search_type_*string\": \"business_name_search\",\n    \"prompt_set_*string\": \"ca_business_prompts\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"AUS\",\n    \"datasets_0_*string\": \"australian_geo_data\",\n    \"search_type_*string\": \"suburb_search\",\n    \"prompt_set_*string\": \"au_location_prompts\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"DEU\",\n    \"datasets_0_*string\": \"german_address_directory\",\n    \"search_type_*string\": \"street_level_search\",\n    \"prompt_set_*string\": \"de_address_format\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"address/search/v1":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Search_for_an_address.json","feedback":[],"name":"Search for an address.","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/search/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_key`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_prompt` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_prompt`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_prompt`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.suggestions[${suggestions_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'additional_attributes' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].additional_attributes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].additional_attributes`)) {\n                    let additional_attributesArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].additional_attributes`, []);\n                    if (Array.isArray(additional_attributesArray)) {\n                        for (let additional_attributes_it = 0; additional_attributes_it < additional_attributesArray.length; additional_attributes_it++) {\n                            let iterator = additional_attributes_it;\n                            if (additional_attributesArray[additional_attributes_it] !== null && additional_attributesArray[additional_attributes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value' has 'value' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/search/v1_POST_30f2033bd6","jsonData":"[\n  {\n    \"country_iso_*string\": \"AUS\",\n    \"datasets_0_*string\": \"AUS\",\n    \"max_suggestions_*number\": 10,\n    \"components.unspecified_0_*string\": \"8 Main Avenue, LIDCOMBE\",\n    \"options_0.name_*string\": \"flatten\",\n    \"options_0.value_*string\": \"true\",\n    \"options_1.name_*string\": \"intensity\",\n    \"options_1.value_*boolean\": true,\n    \"options_2.name_*string\": \"timeout\",\n    \"options_2.value_*string\": \"10000\",\n    \"options_3.name_*string\": \"search_type\",\n    \"options_3.value_*string\": \"singleline\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"GBR\",\n    \"datasets_0_*string\": \"GBR\",\n    \"max_suggestions_*number\": 5,\n    \"components.unspecified_0_*string\": \"Experian, Nottingham\",\n    \"options_0.name_*string\": \"flatten\",\n    \"options_0.value_*string\": \"false\",\n    \"options_1.name_*string\": \"intensity\",\n    \"options_1.value_*boolean\": false,\n    \"options_2.name_*string\": \"timeout\",\n    \"options_2.value_*string\": \"5000\",\n    \"options_3.name_*string\": \"search_type\",\n    \"options_3.value_*string\": \"address\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"USA\",\n    \"datasets_0_*string\": \"USA\",\n    \"max_suggestions_*number\": 15,\n    \"components.unspecified_0_*string\": \"123 Main Street, Beverly Hills\",\n    \"options_0.name_*string\": \"flatten\",\n    \"options_0.value_*string\": \"true\",\n    \"options_1.name_*string\": \"intensity\",\n    \"options_1.value_*boolean\": true,\n    \"options_2.name_*string\": \"timeout\",\n    \"options_2.value_*string\": \"15000\",\n    \"options_3.name_*string\": \"search_type\",\n    \"options_3.value_*string\": \"locality\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"NZL\",\n    \"datasets_0_*string\": \"NZL\",\n    \"max_suggestions_*number\": 8,\n    \"components.unspecified_0_*string\": \"23 Queen Street, Auckland\",\n    \"options_0.name_*string\": \"flatten\",\n    \"options_0.value_*string\": \"true\",\n    \"options_1.name_*string\": \"intensity\",\n    \"options_1.value_*boolean\": false,\n    \"options_2.name_*string\": \"timeout\",\n    \"options_2.value_*string\": \"8000\",\n    \"options_3.name_*string\": \"search_type\",\n    \"options_3.value_*string\": \"singleline\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"address/validate/v1":{"POST":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/Oct-24-Gemini-org/Validate_an_address.json","feedback":[],"name":"Validate an address.","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Oct-24-Gemini-org using AI Type Gemini AI and AI Model gemini-2.5-pro\n\n\nTest generated for address/validate/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function () {\n      pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address`)) {\n                    const value = ld.get(jsonResponse, `result.address`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.address:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_1` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_1`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_1`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.address_line_1:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_2`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_3` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_3`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.locality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.locality`)) {\n                    const value = ld.get(jsonResponse, `result.address.locality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.locality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.region`)) {\n                    const value = ld.get(jsonResponse, `result.address.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.postal_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.postal_code`)) {\n                    const value = ld.get(jsonResponse, `result.address.postal_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.postal_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.country`)) {\n                    const value = ld.get(jsonResponse, `result.address.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.country:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"address/validate/v1_POST_31fae44026","jsonData":"[\n  {\n    \"country_iso_*string\": \"USA\",\n    \"datasets_0_*string\": \"USPS\",\n    \"components.unspecified_0_*string\": \"1600 Pennsylvania Ave NW, Washington, DC 20500\",\n    \"options_0.name_*string\": \"outputCasing\",\n    \"options_0.value_*string\": \"upper\",\n    \"options_1.name_*string\": \"includeUnmatched\",\n    \"options_1.value_*boolean\": true,\n    \"options_2.name_*string\": \"maxResults\",\n    \"options_2.value_*string\": \"10\",\n    \"layouts_0_*string\": \"default-v1\",\n    \"layout_format_*string\": \"json\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"GBR\",\n    \"datasets_0_*string\": \"RoyalMail\",\n    \"components.unspecified_0_*string\": \"10 Downing Street, London\",\n    \"options_0.name_*string\": \"outputGeocodes\",\n    \"options_0.value_*string\": \"extended\",\n    \"options_1.name_*string\": \"matchOnAlias\",\n    \"options_1.value_*boolean\": false,\n    \"options_2.name_*string\": \"minConfidence\",\n    \"options_2.value_*string\": \"0.85\",\n    \"layouts_0_*string\": \"address-detail\",\n    \"layout_format_*string\": \"xml\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"CAN\",\n    \"datasets_0_*string\": \"CanadaPost\",\n    \"components.unspecified_0_*string\": \"24 Sussex Drive, Ottawa, ON\",\n    \"options_0.name_*string\": \"language\",\n    \"options_0.value_*string\": \"en-CA\",\n    \"options_1.name_*string\": \"useAlternate\",\n    \"options_1.value_*boolean\": true,\n    \"options_2.name_*string\": \"outputFields\",\n    \"options_2.value_*string\": \"all\",\n    \"layouts_0_*string\": \"postal-label\",\n    \"layout_format_*string\": \"text\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"AUS\",\n    \"datasets_0_*string\": \"G-NAF\",\n    \"components.unspecified_0_*string\": \"1 Bligh Street, Sydney, NSW 2000\",\n    \"options_0.name_*string\": \"outputScript\",\n    \"options_0.value_*string\": \"Latn\",\n    \"options_1.name_*string\": \"includeGeometry\",\n    \"options_1.value_*boolean\": false,\n    \"options_2.name_*string\": \"filter\",\n    \"options_2.value_*string\": \"locality='Sydney'\",\n    \"layouts_0_*string\": \"geocoding-standard\",\n    \"layout_format_*string\": \"json\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"country_iso_*string\": \"DEU\",\n    \"datasets_0_*string\": \"DeutschePost\",\n    \"components.unspecified_0_*string\": \"Platz der Republik 1, 11011 Berlin\",\n    \"options_0.name_*string\": \"outputFormat\",\n    \"options_0.value_*string\": \"detailed\",\n    \"options_1.name_*string\": \"verify\",\n    \"options_1.value_*boolean\": true,\n    \"options_2.name_*string\": \"timeout\",\n    \"options_2.value_*string\": \"5000\",\n    \"layouts_0_*string\": \"international-v2\",\n    \"layout_format_*string\": \"json\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  }\n]"}},"testFilePath":"/var/tmp/Roost/RoostGPT/Oct-24-Gemini-org/77ecdff9-7e8f-455a-af8f-1233678fce31/source/api-spec/postman_collections/modified_postman_Experian Address Validation.postman_collection.json"}}}