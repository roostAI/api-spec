{"postmanCollection":{"filePaths":["/var/tmp/Roost/RoostGPT/weather_api_test/74259bb4-9a5e-4bb6-84f8-1f9bbc5db48f/source/api-spec/postman_collections/weather_api_test/weather/roost_postman_weather_1763461760.json"]},"headBranch":"roost-74259bb4-9a5e-4bb6-84f8-1f9bbc5db48f","reportHeadBranch":"roost-report","aiUsage":{"promptTokens":0,"completionTokens":0,"apiCallsToAI":0},"repoPath":"/var/tmp/Roost/RoostGPT/weather_api_test/74259bb4-9a5e-4bb6-84f8-1f9bbc5db48f/source/api-spec","errorMsg":"","gitPrUrl":"","status":"","statusDetails":"","coverageReportURL":{},"testReportURL":{},"testMetrics":{"filesScanned":1,"totalFiles":1,"totalTestFiles":9,"successfulTests":9,"testWithCompilationErrors":0,"skippedMethods":0,"toBeProcessed":0,"testswithRunTimeErrors":0,"existingTestPresent":0,"notSupported":0,"methodsScanned":9,"methodsSuccess":9},"advancedDetails":{"/var/tmp/Roost/RoostGPT/weather_api_test/74259bb4-9a5e-4bb6-84f8-1f9bbc5db48f/weather.yaml":{"current.json?q={{q}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Realtime_API.json","feedback":[],"name":"Realtime API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for current.json?q={{q}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: name\n\n        pm.test(`'responseData.location field has name that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.location?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: region\n\n        pm.test(`'responseData.location field has region that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`region`)) {\n            const value = responseData.location?.region;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: country\n\n        pm.test(`'responseData.location field has country that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country`)) {\n            const value = responseData.location?.country;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lat\n\n        pm.test(`'responseData.location field has lat that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lat`)) {\n            const value = responseData.location?.lat;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lon\n\n        pm.test(`'responseData.location field has lon that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lon`)) {\n            const value = responseData.location?.lon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: tz_id\n\n        pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n            const value = responseData.location?.tz_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime_epoch\n\n        pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n            const value = responseData.location?.localtime_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime\n\n        pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n            const value = responseData.location?.localtime;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: current\n\n        pm.test(`'responseData field has current that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`current`)) {\n            const value = responseData?.current;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: last_updated_epoch\n\n        pm.test(`'responseData.current field has last_updated_epoch that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`last_updated_epoch`)) {\n            const value = responseData.current?.last_updated_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: last_updated\n\n        pm.test(`'responseData.current field has last_updated that is of type string'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`last_updated`)) {\n            const value = responseData.current?.last_updated;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: temp_c\n\n        pm.test(`'responseData.current field has temp_c that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`temp_c`)) {\n            const value = responseData.current?.temp_c;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: temp_f\n\n        pm.test(`'responseData.current field has temp_f that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`temp_f`)) {\n            const value = responseData.current?.temp_f;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: is_day\n\n        pm.test(`'responseData.current field has is_day that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`is_day`)) {\n            const value = responseData.current?.is_day;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: condition\n\n        pm.test(`'responseData.current field has condition that is of type object'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`condition`)) {\n            const value = responseData.current?.condition;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.condition\n        // subKey: text\n\n        pm.test(`'responseData.current.condition field has text that is of type string'`, function() {\n          let parent = responseData.current.condition;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`text`)) {\n            const value = responseData.current.condition?.text;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.condition\n        // subKey: icon\n\n        pm.test(`'responseData.current.condition field has icon that is of type string'`, function() {\n          let parent = responseData.current.condition;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`icon`)) {\n            const value = responseData.current.condition?.icon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.condition\n        // subKey: code\n\n        pm.test(`'responseData.current.condition field has code that is of type number'`, function() {\n          let parent = responseData.current.condition;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData.current.condition?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: wind_mph\n\n        pm.test(`'responseData.current field has wind_mph that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`wind_mph`)) {\n            const value = responseData.current?.wind_mph;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: wind_kph\n\n        pm.test(`'responseData.current field has wind_kph that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`wind_kph`)) {\n            const value = responseData.current?.wind_kph;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: wind_degree\n\n        pm.test(`'responseData.current field has wind_degree that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`wind_degree`)) {\n            const value = responseData.current?.wind_degree;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: wind_dir\n\n        pm.test(`'responseData.current field has wind_dir that is of type string'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`wind_dir`)) {\n            const value = responseData.current?.wind_dir;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: pressure_mb\n\n        pm.test(`'responseData.current field has pressure_mb that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pressure_mb`)) {\n            const value = responseData.current?.pressure_mb;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: pressure_in\n\n        pm.test(`'responseData.current field has pressure_in that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pressure_in`)) {\n            const value = responseData.current?.pressure_in;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: precip_mm\n\n        pm.test(`'responseData.current field has precip_mm that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`precip_mm`)) {\n            const value = responseData.current?.precip_mm;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: precip_in\n\n        pm.test(`'responseData.current field has precip_in that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`precip_in`)) {\n            const value = responseData.current?.precip_in;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: humidity\n\n        pm.test(`'responseData.current field has humidity that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`humidity`)) {\n            const value = responseData.current?.humidity;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: cloud\n\n        pm.test(`'responseData.current field has cloud that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cloud`)) {\n            const value = responseData.current?.cloud;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: feelslike_c\n\n        pm.test(`'responseData.current field has feelslike_c that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`feelslike_c`)) {\n            const value = responseData.current?.feelslike_c;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: feelslike_f\n\n        pm.test(`'responseData.current field has feelslike_f that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`feelslike_f`)) {\n            const value = responseData.current?.feelslike_f;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: vis_km\n\n        pm.test(`'responseData.current field has vis_km that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`vis_km`)) {\n            const value = responseData.current?.vis_km;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: vis_miles\n\n        pm.test(`'responseData.current field has vis_miles that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`vis_miles`)) {\n            const value = responseData.current?.vis_miles;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: uv\n\n        pm.test(`'responseData.current field has uv that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`uv`)) {\n            const value = responseData.current?.uv;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: gust_mph\n\n        pm.test(`'responseData.current field has gust_mph that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`gust_mph`)) {\n            const value = responseData.current?.gust_mph;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: gust_kph\n\n        pm.test(`'responseData.current field has gust_kph that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`gust_kph`)) {\n            const value = responseData.current?.gust_kph;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: air_quality\n\n        pm.test(`'responseData.current field has air_quality that is of type object'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`air_quality`)) {\n            const value = responseData.current?.air_quality;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: co\n\n        pm.test(`'responseData.current.air_quality field has co that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`co`)) {\n            const value = responseData.current.air_quality?.co;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: no2\n\n        pm.test(`'responseData.current.air_quality field has no2 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`no2`)) {\n            const value = responseData.current.air_quality?.no2;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: o3\n\n        pm.test(`'responseData.current.air_quality field has o3 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`o3`)) {\n            const value = responseData.current.air_quality?.o3;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: so2\n\n        pm.test(`'responseData.current.air_quality field has so2 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`so2`)) {\n            const value = responseData.current.air_quality?.so2;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: pm2_5\n\n        pm.test(`'responseData.current.air_quality field has pm2_5 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pm2_5`)) {\n            const value = responseData.current.air_quality?.pm2_5;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: pm10\n\n        pm.test(`'responseData.current.air_quality field has pm10 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pm10`)) {\n            const value = responseData.current.air_quality?.pm10;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: us-epa-index\n\n        pm.test(`'responseData.current.air_quality field has us-epa-index that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`us-epa-index`)) {\n            const value = responseData.current.air_quality?.us - epa - index;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: gb-defra-index\n\n        pm.test(`'responseData.current.air_quality field has gb-defra-index that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`gb-defra-index`)) {\n            const value = responseData.current.air_quality?.gb - defra - index;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"current.json?q={{q}}&lang={{lang}}_GET_11ef9fbb39","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"lang\": \"invalid_lang\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation\",\n    \"lang\": \"xx\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"lang\": \"fr\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"lang\": \"ja\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  }\n]"}},"forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Forecast_API.json","feedback":[],"name":"Forecast API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: name\n\n        pm.test(`'responseData.location field has name that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.location?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: region\n\n        pm.test(`'responseData.location field has region that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`region`)) {\n            const value = responseData.location?.region;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: country\n\n        pm.test(`'responseData.location field has country that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country`)) {\n            const value = responseData.location?.country;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lat\n\n        pm.test(`'responseData.location field has lat that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lat`)) {\n            const value = responseData.location?.lat;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lon\n\n        pm.test(`'responseData.location field has lon that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lon`)) {\n            const value = responseData.location?.lon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: tz_id\n\n        pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n            const value = responseData.location?.tz_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime_epoch\n\n        pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n            const value = responseData.location?.localtime_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime\n\n        pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n            const value = responseData.location?.localtime;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: current\n\n        pm.test(`'responseData field has current that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`current`)) {\n            const value = responseData?.current;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: last_updated_epoch\n\n        pm.test(`'responseData.current field has last_updated_epoch that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`last_updated_epoch`)) {\n            const value = responseData.current?.last_updated_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: last_updated\n\n        pm.test(`'responseData.current field has last_updated that is of type string'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`last_updated`)) {\n            const value = responseData.current?.last_updated;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: temp_c\n\n        pm.test(`'responseData.current field has temp_c that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`temp_c`)) {\n            const value = responseData.current?.temp_c;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: temp_f\n\n        pm.test(`'responseData.current field has temp_f that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`temp_f`)) {\n            const value = responseData.current?.temp_f;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: is_day\n\n        pm.test(`'responseData.current field has is_day that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`is_day`)) {\n            const value = responseData.current?.is_day;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: condition\n\n        pm.test(`'responseData.current field has condition that is of type object'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`condition`)) {\n            const value = responseData.current?.condition;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.condition\n        // subKey: text\n\n        pm.test(`'responseData.current.condition field has text that is of type string'`, function() {\n          let parent = responseData.current.condition;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`text`)) {\n            const value = responseData.current.condition?.text;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.condition\n        // subKey: icon\n\n        pm.test(`'responseData.current.condition field has icon that is of type string'`, function() {\n          let parent = responseData.current.condition;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`icon`)) {\n            const value = responseData.current.condition?.icon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.condition\n        // subKey: code\n\n        pm.test(`'responseData.current.condition field has code that is of type number'`, function() {\n          let parent = responseData.current.condition;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData.current.condition?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: wind_mph\n\n        pm.test(`'responseData.current field has wind_mph that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`wind_mph`)) {\n            const value = responseData.current?.wind_mph;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: wind_kph\n\n        pm.test(`'responseData.current field has wind_kph that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`wind_kph`)) {\n            const value = responseData.current?.wind_kph;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: wind_degree\n\n        pm.test(`'responseData.current field has wind_degree that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`wind_degree`)) {\n            const value = responseData.current?.wind_degree;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: wind_dir\n\n        pm.test(`'responseData.current field has wind_dir that is of type string'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`wind_dir`)) {\n            const value = responseData.current?.wind_dir;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: pressure_mb\n\n        pm.test(`'responseData.current field has pressure_mb that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pressure_mb`)) {\n            const value = responseData.current?.pressure_mb;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: pressure_in\n\n        pm.test(`'responseData.current field has pressure_in that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pressure_in`)) {\n            const value = responseData.current?.pressure_in;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: precip_mm\n\n        pm.test(`'responseData.current field has precip_mm that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`precip_mm`)) {\n            const value = responseData.current?.precip_mm;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: precip_in\n\n        pm.test(`'responseData.current field has precip_in that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`precip_in`)) {\n            const value = responseData.current?.precip_in;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: humidity\n\n        pm.test(`'responseData.current field has humidity that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`humidity`)) {\n            const value = responseData.current?.humidity;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: cloud\n\n        pm.test(`'responseData.current field has cloud that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cloud`)) {\n            const value = responseData.current?.cloud;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: feelslike_c\n\n        pm.test(`'responseData.current field has feelslike_c that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`feelslike_c`)) {\n            const value = responseData.current?.feelslike_c;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: feelslike_f\n\n        pm.test(`'responseData.current field has feelslike_f that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`feelslike_f`)) {\n            const value = responseData.current?.feelslike_f;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: vis_km\n\n        pm.test(`'responseData.current field has vis_km that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`vis_km`)) {\n            const value = responseData.current?.vis_km;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: vis_miles\n\n        pm.test(`'responseData.current field has vis_miles that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`vis_miles`)) {\n            const value = responseData.current?.vis_miles;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: uv\n\n        pm.test(`'responseData.current field has uv that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`uv`)) {\n            const value = responseData.current?.uv;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: gust_mph\n\n        pm.test(`'responseData.current field has gust_mph that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`gust_mph`)) {\n            const value = responseData.current?.gust_mph;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: gust_kph\n\n        pm.test(`'responseData.current field has gust_kph that is of type number'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`gust_kph`)) {\n            const value = responseData.current?.gust_kph;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current\n        // subKey: air_quality\n\n        pm.test(`'responseData.current field has air_quality that is of type object'`, function() {\n          let parent = responseData.current;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`air_quality`)) {\n            const value = responseData.current?.air_quality;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: co\n\n        pm.test(`'responseData.current.air_quality field has co that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`co`)) {\n            const value = responseData.current.air_quality?.co;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: no2\n\n        pm.test(`'responseData.current.air_quality field has no2 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`no2`)) {\n            const value = responseData.current.air_quality?.no2;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: o3\n\n        pm.test(`'responseData.current.air_quality field has o3 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`o3`)) {\n            const value = responseData.current.air_quality?.o3;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: so2\n\n        pm.test(`'responseData.current.air_quality field has so2 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`so2`)) {\n            const value = responseData.current.air_quality?.so2;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: pm2_5\n\n        pm.test(`'responseData.current.air_quality field has pm2_5 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pm2_5`)) {\n            const value = responseData.current.air_quality?.pm2_5;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: pm10\n\n        pm.test(`'responseData.current.air_quality field has pm10 that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pm10`)) {\n            const value = responseData.current.air_quality?.pm10;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: us-epa-index\n\n        pm.test(`'responseData.current.air_quality field has us-epa-index that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`us-epa-index`)) {\n            const value = responseData.current.air_quality?.us - epa - index;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.current.air_quality\n        // subKey: gb-defra-index\n\n        pm.test(`'responseData.current.air_quality field has gb-defra-index that is of type number'`, function() {\n          let parent = responseData.current.air_quality;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`gb-defra-index`)) {\n            const value = responseData.current.air_quality?.gb - defra - index;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: forecast\n\n        pm.test(`'responseData field has forecast that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n            const value = responseData?.forecast;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n                      console.log(`forecastdayArray[iterator].day?.maxtemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n                      console.log(`forecastdayArray[iterator].day?.maxtemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n                      console.log(`forecastdayArray[iterator].day?.mintemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n                      console.log(`forecastdayArray[iterator].day?.mintemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n                      console.log(`forecastdayArray[iterator].day?.avgtemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n                      console.log(`forecastdayArray[iterator].day?.avgtemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n                      console.log(`forecastdayArray[iterator].day?.maxwind_mph`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n                      console.log(`forecastdayArray[iterator].day?.maxwind_kph`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n                      console.log(`forecastdayArray[iterator].day?.totalprecip_mm`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n                      console.log(`forecastdayArray[iterator].day?.totalprecip_in`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n                      console.log(`forecastdayArray[iterator].day?.avgvis_km`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n                      console.log(`forecastdayArray[iterator].day?.avgvis_miles`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n                      console.log(`forecastdayArray[iterator].day?.avghumidity`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n                      console.log(`forecastdayArray[iterator].day?.daily_will_it_rain`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n                      console.log(`forecastdayArray[iterator].day?.daily_chance_of_rain`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n                      console.log(`forecastdayArray[iterator].day?.daily_will_it_snow`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n                      console.log(`forecastdayArray[iterator].day?.daily_chance_of_snow`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n                      console.log(`forecastdayArray[iterator].day?.condition`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n                      console.log(`forecastdayArray[iterator].day.condition?.text`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n                      console.log(`forecastdayArray[iterator].day.condition?.icon`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n                      console.log(`forecastdayArray[iterator].day.condition?.code`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n                      console.log(`forecastdayArray[iterator].day?.uv`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n                      console.log(`forecastdayArray[iterator].astro?.sunrise`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n                      console.log(`forecastdayArray[iterator].astro?.sunset`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n                      console.log(`forecastdayArray[iterator].astro?.moonrise`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n                      console.log(`forecastdayArray[iterator].astro?.moonset`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n                      console.log(`forecastdayArray[iterator].astro?.moon_phase`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n                      console.log(`forecastdayArray[iterator].astro?.moon_illumination`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n                                console.log(`hourArray[iterator].condition?.text`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n                                console.log(`hourArray[iterator].condition?.icon`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n                                console.log(`hourArray[iterator].condition?.code`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alerts\n\n        pm.test(`'responseData field has alerts that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alerts`)) {\n            const value = responseData?.alerts;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.alerts` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.alerts`)) {\n              const value = responseData?.responseData.alerts;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.alerts.alert field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.alerts).to.have.nested.property(`alert`)) {\n            let alertArray = ld.get(responseData.alerts, `alert`, []);\n            if (Array.isArray(alertArray)) {\n              for (let alert_it = 0; alert_it < alertArray.length; alert_it++) {\n                let iterator = alert_it;\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'headline' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.headline;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'msgtype' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.msgtype;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'severity' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.severity;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'urgency' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.urgency;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'areas' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.areas;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'category' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.category;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'certainty' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.certainty;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'event' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.event;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'note' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.note;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'effective' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.effective;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('alertArray[${iterator}] format to be date-time', function() {\n                    const value = ld.get(responseData, `alertArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                    }\n                  })\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'expires' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.expires;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('alertArray[${iterator}] format to be date-time', function() {\n                    const value = ld.get(responseData, `alertArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                    }\n                  })\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'desc' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.desc;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'instruction' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.instruction;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}}_GET_b96c60d479","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"days\": 5,\n    \"dt\": \"2023-10-01\",\n    \"unixdt\": 1696156800,\n    \"hour\": 14,\n    \"lang\": \"en\",\n    \"alerts\": \"none\",\n    \"aqi\": \"good\",\n    \"tp\": 23,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"days\": 0,\n    \"dt\": \"invalid-date\",\n    \"unixdt\": -1,\n    \"hour\": 25,\n    \"lang\": \"\",\n    \"alerts\": \"invalid\",\n    \"aqi\": \"unknown\",\n    \"tp\": -5,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"days\": 3,\n    \"dt\": \"2023-10-02\",\n    \"unixdt\": 1696243200,\n    \"hour\": 10,\n    \"lang\": \"es\",\n    \"alerts\": \"flood\",\n    \"aqi\": \"moderate\",\n    \"tp\": 28,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidCity\",\n    \"days\": 15,\n    \"dt\": \"2023-13-01\",\n    \"unixdt\": 9999999999,\n    \"hour\": 99,\n    \"lang\": \"xx\",\n    \"alerts\": \"none\",\n    \"aqi\": \"bad\",\n    \"tp\": 999,\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"days\": 7,\n    \"dt\": \"2023-10-03\",\n    \"unixdt\": 1696329600,\n    \"hour\": 16,\n    \"lang\": \"fr\",\n    \"alerts\": \"storm\",\n    \"aqi\": \"unhealthy\",\n    \"tp\": 30,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"London\",\n    \"days\": 2,\n    \"dt\": \"2023-10-04\",\n    \"unixdt\": 1696416000,\n    \"hour\": 8,\n    \"lang\": \"de\",\n    \"alerts\": \"rain\",\n    \"aqi\": \"good\",\n    \"tp\": 15,\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"future.json?q={{q}}&dt={{dt}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Future_API.json","feedback":[],"name":"Future API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for future.json?q={{q}}&dt={{dt}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: name\n\n        pm.test(`'responseData.location field has name that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.location?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: region\n\n        pm.test(`'responseData.location field has region that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`region`)) {\n            const value = responseData.location?.region;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: country\n\n        pm.test(`'responseData.location field has country that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country`)) {\n            const value = responseData.location?.country;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lat\n\n        pm.test(`'responseData.location field has lat that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lat`)) {\n            const value = responseData.location?.lat;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lon\n\n        pm.test(`'responseData.location field has lon that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lon`)) {\n            const value = responseData.location?.lon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: tz_id\n\n        pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n            const value = responseData.location?.tz_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime_epoch\n\n        pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n            const value = responseData.location?.localtime_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime\n\n        pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n            const value = responseData.location?.localtime;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: forecast\n\n        pm.test(`'responseData field has forecast that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n            const value = responseData?.forecast;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n                      console.log(`forecastdayArray[iterator].day?.maxtemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n                      console.log(`forecastdayArray[iterator].day?.maxtemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n                      console.log(`forecastdayArray[iterator].day?.mintemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n                      console.log(`forecastdayArray[iterator].day?.mintemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n                      console.log(`forecastdayArray[iterator].day?.avgtemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n                      console.log(`forecastdayArray[iterator].day?.avgtemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n                      console.log(`forecastdayArray[iterator].day?.maxwind_mph`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n                      console.log(`forecastdayArray[iterator].day?.maxwind_kph`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n                      console.log(`forecastdayArray[iterator].day?.totalprecip_mm`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n                      console.log(`forecastdayArray[iterator].day?.totalprecip_in`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n                      console.log(`forecastdayArray[iterator].day?.avgvis_km`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n                      console.log(`forecastdayArray[iterator].day?.avgvis_miles`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n                      console.log(`forecastdayArray[iterator].day?.avghumidity`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n                      console.log(`forecastdayArray[iterator].day?.daily_will_it_rain`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n                      console.log(`forecastdayArray[iterator].day?.daily_chance_of_rain`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n                      console.log(`forecastdayArray[iterator].day?.daily_will_it_snow`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n                      console.log(`forecastdayArray[iterator].day?.daily_chance_of_snow`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n                      console.log(`forecastdayArray[iterator].day?.condition`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n                      console.log(`forecastdayArray[iterator].day.condition?.text`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n                      console.log(`forecastdayArray[iterator].day.condition?.icon`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n                      console.log(`forecastdayArray[iterator].day.condition?.code`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n                      console.log(`forecastdayArray[iterator].day?.uv`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n                      console.log(`forecastdayArray[iterator].astro?.sunrise`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n                      console.log(`forecastdayArray[iterator].astro?.sunset`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n                      console.log(`forecastdayArray[iterator].astro?.moonrise`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n                      console.log(`forecastdayArray[iterator].astro?.moonset`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n                      console.log(`forecastdayArray[iterator].astro?.moon_phase`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n                      console.log(`forecastdayArray[iterator].astro?.moon_illumination`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n                                console.log(`hourArray[iterator].condition?.text`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n                                console.log(`hourArray[iterator].condition?.icon`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n                                console.log(`hourArray[iterator].condition?.code`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"future.json?q={{q}}&dt={{dt}}&lang={{lang}}_GET_4ece0fa346","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"dt\": \"invalid-date\",\n    \"lang\": \"unknown\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation\",\n    \"dt\": \"2023-13-01\",\n    \"lang\": \"xx\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"dt\": \"2023-01-01\",\n    \"lang\": \"fr\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"dt\": \"2023-05-15\",\n    \"lang\": \"ja\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  }\n]"}},"history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/History_API.json","feedback":[],"name":"History API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: name\n\n        pm.test(`'responseData.location field has name that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.location?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: region\n\n        pm.test(`'responseData.location field has region that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`region`)) {\n            const value = responseData.location?.region;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: country\n\n        pm.test(`'responseData.location field has country that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country`)) {\n            const value = responseData.location?.country;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lat\n\n        pm.test(`'responseData.location field has lat that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lat`)) {\n            const value = responseData.location?.lat;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lon\n\n        pm.test(`'responseData.location field has lon that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lon`)) {\n            const value = responseData.location?.lon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: tz_id\n\n        pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n            const value = responseData.location?.tz_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime_epoch\n\n        pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n            const value = responseData.location?.localtime_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime\n\n        pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n            const value = responseData.location?.localtime;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: forecast\n\n        pm.test(`'responseData field has forecast that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n            const value = responseData?.forecast;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n                      console.log(`forecastdayArray[iterator].day?.maxtemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n                      console.log(`forecastdayArray[iterator].day?.maxtemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n                      console.log(`forecastdayArray[iterator].day?.mintemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n                      console.log(`forecastdayArray[iterator].day?.mintemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n                      console.log(`forecastdayArray[iterator].day?.avgtemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n                      console.log(`forecastdayArray[iterator].day?.avgtemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n                      console.log(`forecastdayArray[iterator].day?.maxwind_mph`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n                      console.log(`forecastdayArray[iterator].day?.maxwind_kph`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n                      console.log(`forecastdayArray[iterator].day?.totalprecip_mm`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n                      console.log(`forecastdayArray[iterator].day?.totalprecip_in`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n                      console.log(`forecastdayArray[iterator].day?.avgvis_km`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n                      console.log(`forecastdayArray[iterator].day?.avgvis_miles`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n                      console.log(`forecastdayArray[iterator].day?.avghumidity`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n                      console.log(`forecastdayArray[iterator].day?.daily_will_it_rain`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n                      console.log(`forecastdayArray[iterator].day?.daily_chance_of_rain`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n                      console.log(`forecastdayArray[iterator].day?.daily_will_it_snow`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n                      console.log(`forecastdayArray[iterator].day?.daily_chance_of_snow`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n                      console.log(`forecastdayArray[iterator].day?.condition`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n                      console.log(`forecastdayArray[iterator].day.condition?.text`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n                      console.log(`forecastdayArray[iterator].day.condition?.icon`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n                      console.log(`forecastdayArray[iterator].day.condition?.code`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n                      console.log(`forecastdayArray[iterator].day?.uv`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n                      console.log(`forecastdayArray[iterator].astro?.sunrise`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n                      console.log(`forecastdayArray[iterator].astro?.sunset`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n                      console.log(`forecastdayArray[iterator].astro?.moonrise`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n                      console.log(`forecastdayArray[iterator].astro?.moonset`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n                      console.log(`forecastdayArray[iterator].astro?.moon_phase`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n                      console.log(`forecastdayArray[iterator].astro?.moon_illumination`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n                                console.log(`hourArray[iterator].condition?.text`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n                                console.log(`hourArray[iterator].condition?.icon`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n                                console.log(`hourArray[iterator].condition?.code`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}}_GET_e2512939af","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": 1658448000,\n    \"end_dt\": \"2022-07-23\",\n    \"unixend_dt\": 1658534400,\n    \"hour\": \"16\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidCity\",\n    \"dt\": \"invalid-date\",\n    \"unixdt\": -1,\n    \"end_dt\": \"invalid-date\",\n    \"unixend_dt\": -1,\n    \"hour\": \"invalid-hour\",\n    \"lang\": \"invalid-lang\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"AnotherInvalidCity\",\n    \"dt\": \"another-invalid-date\",\n    \"unixdt\": -2,\n    \"end_dt\": \"another-invalid-date\",\n    \"unixend_dt\": -2,\n    \"hour\": \"another-invalid-hour\",\n    \"lang\": \"another-invalid-lang\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"YetAnotherInvalidCity\",\n    \"dt\": \"yet-another-invalid-date\",\n    \"unixdt\": -3,\n    \"end_dt\": \"yet-another-invalid-date\",\n    \"unixend_dt\": -3,\n    \"hour\": \"yet-another-invalid-hour\",\n    \"lang\": \"yet-another-invalid-lang\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2022-07-23\",\n    \"unixdt\": 1658534400,\n    \"end_dt\": \"2022-07-24\",\n    \"unixend_dt\": 1658620800,\n    \"hour\": \"10\",\n    \"lang\": \"es\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  }\n]"}},"marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Marine_Weather_API.json","feedback":[],"name":"Marine Weather API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: name\n\n        pm.test(`'responseData.location field has name that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.location?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: region\n\n        pm.test(`'responseData.location field has region that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`region`)) {\n            const value = responseData.location?.region;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: country\n\n        pm.test(`'responseData.location field has country that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country`)) {\n            const value = responseData.location?.country;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lat\n\n        pm.test(`'responseData.location field has lat that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lat`)) {\n            const value = responseData.location?.lat;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lon\n\n        pm.test(`'responseData.location field has lon that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lon`)) {\n            const value = responseData.location?.lon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: tz_id\n\n        pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n            const value = responseData.location?.tz_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime_epoch\n\n        pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n            const value = responseData.location?.localtime_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime\n\n        pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n            const value = responseData.location?.localtime;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: forecast\n\n        pm.test(`'responseData field has forecast that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n            const value = responseData?.forecast;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n                      console.log(`forecastdayArray[iterator].day?.maxtemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n                      console.log(`forecastdayArray[iterator].day?.maxtemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n                      console.log(`forecastdayArray[iterator].day?.mintemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n                      console.log(`forecastdayArray[iterator].day?.mintemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n                      console.log(`forecastdayArray[iterator].day?.avgtemp_c`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n                      console.log(`forecastdayArray[iterator].day?.avgtemp_f`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n                      console.log(`forecastdayArray[iterator].day?.maxwind_mph`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n                      console.log(`forecastdayArray[iterator].day?.maxwind_kph`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n                      console.log(`forecastdayArray[iterator].day?.totalprecip_mm`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n                      console.log(`forecastdayArray[iterator].day?.totalprecip_in`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n                      console.log(`forecastdayArray[iterator].day?.avgvis_km`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n                      console.log(`forecastdayArray[iterator].day?.avgvis_miles`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n                      console.log(`forecastdayArray[iterator].day?.avghumidity`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n                      console.log(`forecastdayArray[iterator].day?.daily_will_it_rain`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n                      console.log(`forecastdayArray[iterator].day?.daily_chance_of_rain`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n                      console.log(`forecastdayArray[iterator].day?.daily_will_it_snow`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n                      console.log(`forecastdayArray[iterator].day?.daily_chance_of_snow`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n                      console.log(`forecastdayArray[iterator].day?.condition`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n                      console.log(`forecastdayArray[iterator].day.condition?.text`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n                      console.log(`forecastdayArray[iterator].day.condition?.icon`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n                      console.log(`forecastdayArray[iterator].day.condition?.code`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n                      console.log(`forecastdayArray[iterator].day?.uv`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n                      console.log(`forecastdayArray[iterator].astro?.sunrise`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n                      console.log(`forecastdayArray[iterator].astro?.sunset`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n                      console.log(`forecastdayArray[iterator].astro?.moonrise`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n                      console.log(`forecastdayArray[iterator].astro?.moonset`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n                      console.log(`forecastdayArray[iterator].astro?.moon_phase`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n                      console.log(`forecastdayArray[iterator].astro?.moon_illumination`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n                                console.log(`hourArray[iterator].condition?.text`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n                                console.log(`hourArray[iterator].condition?.icon`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n                                console.log(`hourArray[iterator].condition?.code`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'sig_ht_mt' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.sig_ht_mt;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_ht_mt' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_ht_mt;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_ht_ft' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_ht_ft;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_dir' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_dir_16_point' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_dir_16_point;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_period_secs' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_period_secs;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}_GET_3b9375ed0c","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"days\": 3,\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": 1658448000,\n    \"hour\": 16,\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"days\": 15,\n    \"dt\": \"invalid-date\",\n    \"unixdt\": -1,\n    \"hour\": 25,\n    \"lang\": \"\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation\",\n    \"days\": 0,\n    \"dt\": \"2022-13-01\",\n    \"unixdt\": 9999999999,\n    \"hour\": -5,\n    \"lang\": \"xx\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"days\": 7,\n    \"dt\": \"2022-07-25\",\n    \"unixdt\": 1658707200,\n    \"hour\": 10,\n    \"lang\": \"es\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"San Francisco\",\n    \"days\": 5,\n    \"dt\": \"2022-07-30\",\n    \"unixdt\": 1659139200,\n    \"hour\": 14,\n    \"lang\": \"fr\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"search.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Search_Autocomplete_API.json","feedback":[],"name":"Search/Autocomplete API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for search.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: name\n\n              pm.test(`'item field has name that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`name`)) {\n                  const value = item?.name;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: region\n\n              pm.test(`'item field has region that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`region`)) {\n                  const value = item?.region;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: country\n\n              pm.test(`'item field has country that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`country`)) {\n                  const value = item?.country;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lat\n\n              pm.test(`'item field has lat that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                  const value = item?.lat;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lon\n\n              pm.test(`'item field has lon that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                  const value = item?.lon;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: url\n\n              pm.test(`'item field has url that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`url`)) {\n                  const value = item?.url;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"search.json?q={{q}}_GET_d9f22c6255","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"London\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"ip.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/IP_Lookup_API.json","feedback":[],"name":"IP Lookup API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for ip.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ip\n\n        pm.test(`'responseData field has ip that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ip`)) {\n            const value = responseData?.ip;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: type\n\n        pm.test(`'responseData field has type that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`type`)) {\n            const value = responseData?.type;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: continent_code\n\n        pm.test(`'responseData field has continent_code that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`continent_code`)) {\n            const value = responseData?.continent_code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: continent_name\n\n        pm.test(`'responseData field has continent_name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`continent_name`)) {\n            const value = responseData?.continent_name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: country_code\n\n        pm.test(`'responseData field has country_code that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country_code`)) {\n            const value = responseData?.country_code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: country_name\n\n        pm.test(`'responseData field has country_name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country_name`)) {\n            const value = responseData?.country_name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: is_eu\n\n        pm.test(`'responseData field has is_eu that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`is_eu`)) {\n            const value = responseData?.is_eu;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: geoname_id\n\n        pm.test(`'responseData field has geoname_id that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`geoname_id`)) {\n            const value = responseData?.geoname_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: city\n\n        pm.test(`'responseData field has city that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`city`)) {\n            const value = responseData?.city;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: region\n\n        pm.test(`'responseData field has region that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`region`)) {\n            const value = responseData?.region;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: lat\n\n        pm.test(`'responseData field has lat that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lat`)) {\n            const value = responseData?.lat;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: lon\n\n        pm.test(`'responseData field has lon that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lon`)) {\n            const value = responseData?.lon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: tz_id\n\n        pm.test(`'responseData field has tz_id that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n            const value = responseData?.tz_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: localtime_epoch\n\n        pm.test(`'responseData field has localtime_epoch that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n            const value = responseData?.localtime_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: localtime\n\n        pm.test(`'responseData field has localtime that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n            const value = responseData?.localtime;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"ip.json?q={{q}}_GET_d0aefd50f4","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"London\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"NoAPIKey\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"ExceededQuota\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"timezone.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Time_Zone_API.json","feedback":[],"name":"Time Zone API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for timezone.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: region\n\n        pm.test(`'responseData field has region that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`region`)) {\n            const value = responseData?.region;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: country\n\n        pm.test(`'responseData field has country that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country`)) {\n            const value = responseData?.country;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: lat\n\n        pm.test(`'responseData field has lat that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lat`)) {\n            const value = responseData?.lat;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: lon\n\n        pm.test(`'responseData field has lon that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lon`)) {\n            const value = responseData?.lon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: tz_id\n\n        pm.test(`'responseData field has tz_id that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n            const value = responseData?.tz_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: localtime_epoch\n\n        pm.test(`'responseData field has localtime_epoch that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n            const value = responseData?.localtime_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: localtime\n\n        pm.test(`'responseData field has localtime that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n            const value = responseData?.localtime;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"timezone.json?q={{q}}_GET_d8e8991409","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidCityName123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"UnauthorizedAccess\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  }\n]"}},"astronomy.json?q={{q}}&dt={{dt}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Astronomy_API.json","feedback":[],"name":"Astronomy API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for astronomy.json?q={{q}}&dt={{dt}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: name\n\n        pm.test(`'responseData.location field has name that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.location?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: region\n\n        pm.test(`'responseData.location field has region that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`region`)) {\n            const value = responseData.location?.region;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: country\n\n        pm.test(`'responseData.location field has country that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`country`)) {\n            const value = responseData.location?.country;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lat\n\n        pm.test(`'responseData.location field has lat that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lat`)) {\n            const value = responseData.location?.lat;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: lon\n\n        pm.test(`'responseData.location field has lon that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lon`)) {\n            const value = responseData.location?.lon;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: tz_id\n\n        pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n            const value = responseData.location?.tz_id;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime_epoch\n\n        pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n            const value = responseData.location?.localtime_epoch;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.location\n        // subKey: localtime\n\n        pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n          let parent = responseData.location;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n            const value = responseData.location?.localtime;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: astronomy\n\n        pm.test(`'responseData field has astronomy that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`astronomy`)) {\n            const value = responseData?.astronomy;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.astronomy\n        // subKey: astro\n\n        pm.test(`'responseData.astronomy field has astro that is of type object'`, function() {\n          let parent = responseData.astronomy;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`astro`)) {\n            const value = responseData.astronomy?.astro;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.astronomy.astro\n        // subKey: sunrise\n\n        pm.test(`'responseData.astronomy.astro field has sunrise that is of type string'`, function() {\n          let parent = responseData.astronomy.astro;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n            const value = responseData.astronomy.astro?.sunrise;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.astronomy.astro\n        // subKey: sunset\n\n        pm.test(`'responseData.astronomy.astro field has sunset that is of type string'`, function() {\n          let parent = responseData.astronomy.astro;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n            const value = responseData.astronomy.astro?.sunset;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.astronomy.astro\n        // subKey: moonrise\n\n        pm.test(`'responseData.astronomy.astro field has moonrise that is of type string'`, function() {\n          let parent = responseData.astronomy.astro;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n            const value = responseData.astronomy.astro?.moonrise;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.astronomy.astro\n        // subKey: moonset\n\n        pm.test(`'responseData.astronomy.astro field has moonset that is of type string'`, function() {\n          let parent = responseData.astronomy.astro;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n            const value = responseData.astronomy.astro?.moonset;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.astronomy.astro\n        // subKey: moon_phase\n\n        pm.test(`'responseData.astronomy.astro field has moon_phase that is of type string'`, function() {\n          let parent = responseData.astronomy.astro;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n            const value = responseData.astronomy.astro?.moon_phase;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.astronomy.astro\n        // subKey: moon_illumination\n\n        pm.test(`'responseData.astronomy.astro field has moon_illumination that is of type string'`, function() {\n          let parent = responseData.astronomy.astro;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n            const value = responseData.astronomy.astro?.moon_illumination;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: code\n\n        pm.test(`'responseData field has code that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`code`)) {\n            const value = responseData?.code;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: message\n\n        pm.test(`'responseData field has message that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"astronomy.json?q={{q}}&dt={{dt}}_GET_1b9f6b9595","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2023-10-01\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"dt\": \"invalid-date\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2023-10-02\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidLocation\",\n    \"dt\": \"not-a-date\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"dt\": \"2023-10-03\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"UnauthorizedAccess\",\n    \"dt\": \"wrong-format\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"testFilePath":"/var/tmp/Roost/RoostGPT/weather_api_test/74259bb4-9a5e-4bb6-84f8-1f9bbc5db48f/source/api-spec/postman_collections/weather_api_test/weather/roost_postman_weather_1763461760.json"}}}