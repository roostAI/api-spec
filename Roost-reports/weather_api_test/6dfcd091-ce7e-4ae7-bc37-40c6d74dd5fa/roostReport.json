{"postmanCollection":{"filePaths":["/var/tmp/Roost/RoostGPT/weather_api_test/6dfcd091-ce7e-4ae7-bc37-40c6d74dd5fa/source/api-spec/postman_collections/modified_postman_weather.json"]},"headBranch":"roost-6dfcd091-ce7e-4ae7-bc37-40c6d74dd5fa","reportHeadBranch":"roost-report","aiUsage":{"promptTokens":0,"completionTokens":0,"apiCallsToAI":0},"repoPath":"/var/tmp/Roost/RoostGPT/weather_api_test/6dfcd091-ce7e-4ae7-bc37-40c6d74dd5fa/source/api-spec","errorMsg":"","gitPrUrl":"","status":"","statusDetails":"","coverageReportURL":{},"testReportURL":{},"testMetrics":{"filesScanned":1,"totalFiles":1,"totalTestFiles":9,"successfulTests":9,"testWithCompilationErrors":0,"skippedMethods":0,"toBeProcessed":0,"testswithRunTimeErrors":0,"existingTestPresent":0,"notSupported":0,"methodsScanned":9,"methodsSuccess":9},"advancedDetails":{"/var/tmp/Roost/RoostGPT/weather_api_test/6dfcd091-ce7e-4ae7-bc37-40c6d74dd5fa/weather.yaml":{"current.json?q={{q}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/Realtime_API.json","feedback":[],"name":"Realtime API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for current.json?q={{q}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current`)) {\n                    const value = ld.get(jsonResponse, `current`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.last_updated_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.last_updated_epoch`)) {\n                    const value = ld.get(responseData, `current.last_updated_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.last_updated_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('current.last_updated_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.last_updated_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045400);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.last_updated_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.last_updated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.last_updated`)) {\n                    const value = ld.get(jsonResponse, `current.last_updated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`current.last_updated length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`current.last_updated length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.last_updated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.temp_c` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.temp_c`)) {\n                    const value = ld.get(responseData, `current.temp_c`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1034.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-965.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.temp_c:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.temp_f` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.temp_f`)) {\n                    const value = ld.get(responseData, `current.temp_f`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1093.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-906.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.temp_f:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.is_day` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.is_day`)) {\n                    const value = ld.get(responseData, `current.is_day`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.is_day:\", error.message);\n            }\n        })\n  \n        pm.test('current.is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.is_day:\", error.message);\n            }\n        })\n  \n        pm.test('current.is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.is_day:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition`)) {\n                    const value = ld.get(jsonResponse, `current.condition`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current.condition:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.text` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition.text`)) {\n                    const value = ld.get(jsonResponse, `current.condition.text`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.condition.text:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.icon` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition.icon`)) {\n                    const value = ld.get(jsonResponse, `current.condition.icon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.condition.code`)) {\n                    const value = ld.get(responseData, `current.condition.code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.condition.code:\", error.message);\n            }\n        })\n  \n        pm.test('current.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.condition.code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_mph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_mph`)) {\n                    const value = ld.get(responseData, `current.wind_mph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1016.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-983.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_mph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_kph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_kph`)) {\n                    const value = ld.get(responseData, `current.wind_kph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1025.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-974.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_kph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_degree` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_degree`)) {\n                    const value = ld.get(responseData, `current.wind_degree`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1180);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-820);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_degree:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_dir` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.wind_dir`)) {\n                    const value = ld.get(jsonResponse, `current.wind_dir`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`current.wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`current.wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.wind_dir:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.pressure_mb` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.pressure_mb`)) {\n                    const value = ld.get(responseData, `current.pressure_mb`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.pressure_mb:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2022);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.pressure_in` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.pressure_in`)) {\n                    const value = ld.get(responseData, `current.pressure_in`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.85);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.15);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.pressure_in:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.precip_mm` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.precip_mm`)) {\n                    const value = ld.get(responseData, `current.precip_mm`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.precip_mm:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.precip_in` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.precip_in`)) {\n                    const value = ld.get(responseData, `current.precip_in`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.precip_in:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.humidity` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.humidity`)) {\n                    const value = ld.get(responseData, `current.humidity`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.humidity:\", error.message);\n            }\n        })\n  \n        pm.test('current.humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1031);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.humidity:\", error.message);\n            }\n        })\n  \n        pm.test('current.humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.humidity:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.cloud` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.cloud`)) {\n                    const value = ld.get(responseData, `current.cloud`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.cloud:\", error.message);\n            }\n        })\n  \n        pm.test('current.cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1075);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.cloud:\", error.message);\n            }\n        })\n  \n        pm.test('current.cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-925);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.cloud:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.feelslike_c` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.feelslike_c`)) {\n                    const value = ld.get(responseData, `current.feelslike_c`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1037);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-963);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.feelslike_f` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.feelslike_f`)) {\n                    const value = ld.get(responseData, `current.feelslike_f`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1098.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-901.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.vis_km` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.vis_km`)) {\n                    const value = ld.get(responseData, `current.vis_km`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1016);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.vis_km:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.vis_miles` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.vis_miles`)) {\n                    const value = ld.get(responseData, `current.vis_miles`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-991);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.vis_miles:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.uv` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.uv`)) {\n                    const value = ld.get(responseData, `current.uv`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.uv:\", error.message);\n            }\n        })\n  \n        pm.test('current.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.uv:\", error.message);\n            }\n        })\n  \n        pm.test('current.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.uv:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.gust_mph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.gust_mph`)) {\n                    const value = ld.get(responseData, `current.gust_mph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1011.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-988.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.gust_mph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.gust_kph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.gust_kph`)) {\n                    const value = ld.get(responseData, `current.gust_kph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1018.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.gust_kph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.air_quality`)) {\n                    const value = ld.get(jsonResponse, `current.air_quality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current.air_quality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.co` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.co`)) {\n                    const value = ld.get(responseData, `current.air_quality.co`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.co:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.co maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.co`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1293.7000122070312);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.co:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.co minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.co`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-706.2999877929688);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.co:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.no2` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.no2`)) {\n                    const value = ld.get(responseData, `current.air_quality.no2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.no2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.no2 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.no2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1018.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.no2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.no2 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.no2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.no2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.o3` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.o3`)) {\n                    const value = ld.get(responseData, `current.air_quality.o3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.o3:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.o3 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.o3`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1234.6000061035156);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.o3:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.o3 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.o3`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-765.3999938964844);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.o3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.so2` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.so2`)) {\n                    const value = ld.get(responseData, `current.air_quality.so2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.so2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.so2 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.so2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.so2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.so2 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.so2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-988);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.so2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.pm2_5` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.pm2_5`)) {\n                    const value = ld.get(responseData, `current.air_quality.pm2_5`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.pm2_5:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm2_5 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm2_5`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1013.6000003814697);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.pm2_5:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm2_5 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm2_5`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-986.3999996185303);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.pm2_5:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.pm10` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.pm10`)) {\n                    const value = ld.get(responseData, `current.air_quality.pm10`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.pm10:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm10 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm10`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.pm10:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm10 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm10`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.pm10:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.us-epa-index` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.us-epa-index`)) {\n                    const value = ld.get(responseData, `current.air_quality.us-epa-index`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.us-epa-index maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.us-epa-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.us-epa-index minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.us-epa-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.gb-defra-index` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.gb-defra-index`)) {\n                    const value = ld.get(responseData, `current.air_quality.gb-defra-index`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.gb-defra-index maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.gb-defra-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1002);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.gb-defra-index minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.gb-defra-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-998);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"current.json?q={{q}}&lang={{lang}}_GET_11ef9fbb39","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"lang\": \"en\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCityName\",\n    \"lang\": \"xx\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"lang\": \"en\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"lang\": \"en\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/Forecast_API.json","feedback":[],"name":"Forecast API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current`)) {\n                    const value = ld.get(jsonResponse, `current`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.last_updated_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.last_updated_epoch`)) {\n                    const value = ld.get(responseData, `current.last_updated_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.last_updated_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('current.last_updated_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.last_updated_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045400);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.last_updated_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.last_updated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.last_updated`)) {\n                    const value = ld.get(jsonResponse, `current.last_updated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`current.last_updated length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`current.last_updated length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.last_updated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.temp_c` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.temp_c`)) {\n                    const value = ld.get(responseData, `current.temp_c`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1034.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-965.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.temp_c:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.temp_f` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.temp_f`)) {\n                    const value = ld.get(responseData, `current.temp_f`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1093.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-906.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.temp_f:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.is_day` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.is_day`)) {\n                    const value = ld.get(responseData, `current.is_day`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.is_day:\", error.message);\n            }\n        })\n  \n        pm.test('current.is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.is_day:\", error.message);\n            }\n        })\n  \n        pm.test('current.is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.is_day:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition`)) {\n                    const value = ld.get(jsonResponse, `current.condition`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current.condition:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.text` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition.text`)) {\n                    const value = ld.get(jsonResponse, `current.condition.text`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.condition.text:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.icon` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition.icon`)) {\n                    const value = ld.get(jsonResponse, `current.condition.icon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.condition.code`)) {\n                    const value = ld.get(responseData, `current.condition.code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.condition.code:\", error.message);\n            }\n        })\n  \n        pm.test('current.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.condition.code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_mph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_mph`)) {\n                    const value = ld.get(responseData, `current.wind_mph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1016.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-983.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_mph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_kph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_kph`)) {\n                    const value = ld.get(responseData, `current.wind_kph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1025.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-974.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_kph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_degree` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_degree`)) {\n                    const value = ld.get(responseData, `current.wind_degree`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1180);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-820);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_degree:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_dir` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.wind_dir`)) {\n                    const value = ld.get(jsonResponse, `current.wind_dir`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`current.wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`current.wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.wind_dir:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.pressure_mb` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.pressure_mb`)) {\n                    const value = ld.get(responseData, `current.pressure_mb`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.pressure_mb:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2022);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.pressure_in` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.pressure_in`)) {\n                    const value = ld.get(responseData, `current.pressure_in`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.85);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.15);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.pressure_in:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.precip_mm` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.precip_mm`)) {\n                    const value = ld.get(responseData, `current.precip_mm`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.precip_mm:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.precip_in` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.precip_in`)) {\n                    const value = ld.get(responseData, `current.precip_in`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.precip_in:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.humidity` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.humidity`)) {\n                    const value = ld.get(responseData, `current.humidity`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.humidity:\", error.message);\n            }\n        })\n  \n        pm.test('current.humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1031);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.humidity:\", error.message);\n            }\n        })\n  \n        pm.test('current.humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.humidity:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.cloud` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.cloud`)) {\n                    const value = ld.get(responseData, `current.cloud`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.cloud:\", error.message);\n            }\n        })\n  \n        pm.test('current.cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1075);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.cloud:\", error.message);\n            }\n        })\n  \n        pm.test('current.cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-925);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.cloud:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.feelslike_c` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.feelslike_c`)) {\n                    const value = ld.get(responseData, `current.feelslike_c`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1037);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-963);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.feelslike_f` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.feelslike_f`)) {\n                    const value = ld.get(responseData, `current.feelslike_f`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1098.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-901.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.vis_km` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.vis_km`)) {\n                    const value = ld.get(responseData, `current.vis_km`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1016);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.vis_km:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.vis_miles` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.vis_miles`)) {\n                    const value = ld.get(responseData, `current.vis_miles`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-991);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.vis_miles:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.uv` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.uv`)) {\n                    const value = ld.get(responseData, `current.uv`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.uv:\", error.message);\n            }\n        })\n  \n        pm.test('current.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.uv:\", error.message);\n            }\n        })\n  \n        pm.test('current.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.uv:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.gust_mph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.gust_mph`)) {\n                    const value = ld.get(responseData, `current.gust_mph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1011.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-988.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.gust_mph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.gust_kph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.gust_kph`)) {\n                    const value = ld.get(responseData, `current.gust_kph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1018.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.gust_kph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.air_quality`)) {\n                    const value = ld.get(jsonResponse, `current.air_quality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current.air_quality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.co` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.co`)) {\n                    const value = ld.get(responseData, `current.air_quality.co`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.co:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.co maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.co`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1293.7000122070312);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.co:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.co minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.co`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-706.2999877929688);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.co:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.no2` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.no2`)) {\n                    const value = ld.get(responseData, `current.air_quality.no2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.no2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.no2 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.no2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1018.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.no2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.no2 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.no2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.no2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.o3` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.o3`)) {\n                    const value = ld.get(responseData, `current.air_quality.o3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.o3:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.o3 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.o3`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1234.6000061035156);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.o3:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.o3 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.o3`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-765.3999938964844);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.o3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.so2` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.so2`)) {\n                    const value = ld.get(responseData, `current.air_quality.so2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.so2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.so2 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.so2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.so2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.so2 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.so2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-988);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.so2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.pm2_5` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.pm2_5`)) {\n                    const value = ld.get(responseData, `current.air_quality.pm2_5`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.pm2_5:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm2_5 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm2_5`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1013.6000003814697);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.pm2_5:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm2_5 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm2_5`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-986.3999996185303);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.pm2_5:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.pm10` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.pm10`)) {\n                    const value = ld.get(responseData, `current.air_quality.pm10`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.pm10:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm10 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm10`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.pm10:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm10 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm10`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.pm10:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.us-epa-index` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.us-epa-index`)) {\n                    const value = ld.get(responseData, `current.air_quality.us-epa-index`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.us-epa-index maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.us-epa-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.us-epa-index minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.us-epa-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.gb-defra-index` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.gb-defra-index`)) {\n                    const value = ld.get(responseData, `current.air_quality.gb-defra-index`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.gb-defra-index maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.gb-defra-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1002);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.gb-defra-index minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.gb-defra-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-998);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast`)) {\n                    const value = ld.get(jsonResponse, `forecast`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field forecast:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast.forecastday` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    const value = ld.get(jsonResponse, `forecast.forecastday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    let forecastdayArray = ld.get(jsonResponse, `forecast.forecastday`, []);\n                    if (Array.isArray(forecastdayArray)) {\n                        for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                            let iterator = forecastday_it;\n                            if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].date' has 'date' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date format to be date',function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date format for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'date_epoch' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316896000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day' has 'day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1035.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-964.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1096.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-903.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1026.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-973.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1079.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-920.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1087.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-912.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_mph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012.8);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-987.2);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_kph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1020.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-979.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_mm' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_in' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_km' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_miles' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avghumidity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1053);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-947);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.text' has 'text' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.icon' has 'icon' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.code' has 'code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'uv' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro' has 'astro' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].astro:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunrise' has 'sunrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunset' has 'sunset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonrise' has 'moonrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonset' has 'moonset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_phase' has 'moon_phase' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_illumination' has 'moon_illumination' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'hour' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday[${forecastday_it}].hour field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday[${forecastday_it}].hour`)) {\n                    let hourArray = ld.get(jsonResponse, `forecast.forecastday[${forecastday_it}].hour`, []);\n                    if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                            let iterator = hour_it;\n                            if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch' has 'time_epoch' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316924800);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time' has 'time' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c' has 'temp_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f' has 'temp_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day' has 'is_day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph' has 'wind_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph' has 'wind_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree' has 'wind_degree' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1265);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-735);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir' has 'wind_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb' has 'pressure_mb' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in' has 'pressure_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.73);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.27);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm' has 'precip_mm' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in' has 'precip_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity' has 'humidity' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1058);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-942);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud' has 'cloud' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c' has 'feelslike_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f' has 'feelslike_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c' has 'windchill_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f' has 'windchill_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c' has 'heatindex_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f' has 'heatindex_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c' has 'dewpoint_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-980.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f' has 'dewpoint_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1067.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-932.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain' has 'will_it_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain' has 'chance_of_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow' has 'will_it_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow' has 'chance_of_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km' has 'vis_km' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles' has 'vis_miles' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph' has 'gust_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph' has 'gust_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv' has 'uv' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `alerts` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`alerts`)) {\n                    const value = ld.get(jsonResponse, `alerts`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field alerts:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `alerts.alert` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`alerts.alert`)) {\n                    const value = ld.get(jsonResponse, `alerts.alert`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field alerts.alert:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for alerts.alert:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for alerts.alert:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the alerts.alert field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`alerts.alert`)) {\n                    let alertArray = ld.get(jsonResponse, `alerts.alert`, []);\n                    if (Array.isArray(alertArray)) {\n                        for (let alert_it = 0; alert_it < alertArray.length; alert_it++) {\n                            let iterator = alert_it;\n                            if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].headline' has 'headline' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].headline`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].headline:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].headline length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].headline`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].headline:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].headline length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].headline`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].headline:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].msgtype' has 'msgtype' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].msgtype`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].msgtype:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].msgtype length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].msgtype`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].msgtype:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].msgtype length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].msgtype`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].msgtype:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].severity' has 'severity' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].severity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].severity:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].severity length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].severity`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].severity:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].severity length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].severity`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].severity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].urgency' has 'urgency' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].urgency`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].urgency:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].urgency length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].urgency`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].urgency:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].urgency length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].urgency`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].urgency:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].areas' has 'areas' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].areas`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].areas:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].areas length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].areas`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].areas:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].areas length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].areas`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].areas:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].category' has 'category' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].category`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].category:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].category length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].category`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].category:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].category length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].category`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].category:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].certainty' has 'certainty' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].certainty`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].certainty:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].certainty length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].certainty`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].certainty:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].certainty length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].certainty`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].certainty:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].event' has 'event' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].event`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].event:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].event length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].event`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].event:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].event length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].event`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].event:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].note' has 'note' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].note`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].note:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].note length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].note`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].note:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].note length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].note`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].note:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].effective' has 'effective' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].effective`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].effective:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].effective length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].effective`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].effective:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].effective length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].effective`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].effective:\", error.message);\n            }\n        })\n  \n        pm.test('alerts.alert[${alert_it}].effective format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].effective`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for alerts.alert[${alert_it}].effective:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].expires' has 'expires' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].expires`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].expires:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].expires length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].expires`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].expires:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].expires length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].expires`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].expires:\", error.message);\n            }\n        })\n  \n        pm.test('alerts.alert[${alert_it}].expires format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].expires`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for alerts.alert[${alert_it}].expires:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].desc' has 'desc' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].desc`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].desc:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].desc length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].desc`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].desc:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].desc length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].desc`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].desc:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].instruction' has 'instruction' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].instruction`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].instruction:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for alerts.alert:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}}_GET_b96c60d479","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"days\": \"5\",\n    \"dt\": \"2023-10-01\",\n    \"unixdt\": \"1696204800\",\n    \"hour\": \"14\",\n    \"lang\": \"en\",\n    \"alerts\": \"true\",\n    \"aqi\": \"good\",\n    \"tp\": \"C\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"days\": \"invalid_days\",\n    \"dt\": \"invalid_date\",\n    \"unixdt\": \"invalid_unixdt\",\n    \"hour\": \"invalid_hour\",\n    \"lang\": \"invalid_lang\",\n    \"alerts\": \"invalid_alerts\",\n    \"aqi\": \"invalid_aqi\",\n    \"tp\": \"invalid_tp\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"days\": \"3\",\n    \"dt\": \"2023-10-02\",\n    \"unixdt\": \"1696291200\",\n    \"hour\": \"10\",\n    \"lang\": \"es\",\n    \"alerts\": \"false\",\n    \"aqi\": \"moderate\",\n    \"tp\": \"F\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"days\": \"7\",\n    \"dt\": \"2023-10-03\",\n    \"unixdt\": \"1696377600\",\n    \"hour\": \"16\",\n    \"lang\": \"fr\",\n    \"alerts\": \"true\",\n    \"aqi\": \"unhealthy\",\n    \"tp\": \"C\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"San Francisco\",\n    \"days\": \"2\",\n    \"dt\": \"2023-10-04\",\n    \"unixdt\": \"1696464000\",\n    \"hour\": \"8\",\n    \"lang\": \"de\",\n    \"alerts\": \"false\",\n    \"aqi\": \"hazardous\",\n    \"tp\": \"F\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  }\n]"}},"future.json?q={{q}}&dt={{dt}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/Future_API.json","feedback":[],"name":"Future API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for future.json?q={{q}}&dt={{dt}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast`)) {\n                    const value = ld.get(jsonResponse, `forecast`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field forecast:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast.forecastday` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    const value = ld.get(jsonResponse, `forecast.forecastday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    let forecastdayArray = ld.get(jsonResponse, `forecast.forecastday`, []);\n                    if (Array.isArray(forecastdayArray)) {\n                        for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                            let iterator = forecastday_it;\n                            if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].date' has 'date' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date format to be date',function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date format for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'date_epoch' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316896000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day' has 'day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1035.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-964.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1096.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-903.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1026.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-973.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1079.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-920.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1087.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-912.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_mph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012.8);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-987.2);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_kph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1020.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-979.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_mm' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_in' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_km' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_miles' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avghumidity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1053);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-947);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.text' has 'text' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.icon' has 'icon' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.code' has 'code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'uv' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro' has 'astro' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].astro:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunrise' has 'sunrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunset' has 'sunset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonrise' has 'moonrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonset' has 'moonset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_phase' has 'moon_phase' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_illumination' has 'moon_illumination' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'hour' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday[${forecastday_it}].hour field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday[${forecastday_it}].hour`)) {\n                    let hourArray = ld.get(jsonResponse, `forecast.forecastday[${forecastday_it}].hour`, []);\n                    if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                            let iterator = hour_it;\n                            if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch' has 'time_epoch' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316924800);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time' has 'time' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c' has 'temp_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f' has 'temp_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day' has 'is_day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph' has 'wind_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph' has 'wind_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree' has 'wind_degree' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1265);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-735);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir' has 'wind_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb' has 'pressure_mb' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in' has 'pressure_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.73);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.27);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm' has 'precip_mm' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in' has 'precip_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity' has 'humidity' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1058);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-942);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud' has 'cloud' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c' has 'feelslike_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f' has 'feelslike_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c' has 'windchill_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f' has 'windchill_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c' has 'heatindex_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f' has 'heatindex_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c' has 'dewpoint_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-980.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f' has 'dewpoint_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1067.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-932.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain' has 'will_it_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain' has 'chance_of_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow' has 'will_it_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow' has 'chance_of_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km' has 'vis_km' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles' has 'vis_miles' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph' has 'gust_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph' has 'gust_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv' has 'uv' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"future.json?q={{q}}&dt={{dt}}&lang={{lang}}_GET_4ece0fa346","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidLocation\",\n    \"dt\": \"InvalidDate\",\n    \"lang\": \"xx\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2022-08-01\",\n    \"lang\": \"en\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"dt\": \"2022-07-30\",\n    \"lang\": \"en\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"San Francisco\",\n    \"dt\": \"2022-07-25\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  }\n]"}},"history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/History_API.json","feedback":[],"name":"History API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast`)) {\n                    const value = ld.get(jsonResponse, `forecast`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field forecast:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast.forecastday` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    const value = ld.get(jsonResponse, `forecast.forecastday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    let forecastdayArray = ld.get(jsonResponse, `forecast.forecastday`, []);\n                    if (Array.isArray(forecastdayArray)) {\n                        for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                            let iterator = forecastday_it;\n                            if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].date' has 'date' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date format to be date',function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date format for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'date_epoch' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316896000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day' has 'day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1035.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-964.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1096.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-903.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1026.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-973.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1079.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-920.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1087.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-912.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_mph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012.8);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-987.2);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_kph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1020.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-979.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_mm' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_in' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_km' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_miles' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avghumidity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1053);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-947);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.text' has 'text' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.icon' has 'icon' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.code' has 'code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'uv' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro' has 'astro' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].astro:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunrise' has 'sunrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunset' has 'sunset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonrise' has 'moonrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonset' has 'moonset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_phase' has 'moon_phase' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_illumination' has 'moon_illumination' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'hour' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday[${forecastday_it}].hour field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday[${forecastday_it}].hour`)) {\n                    let hourArray = ld.get(jsonResponse, `forecast.forecastday[${forecastday_it}].hour`, []);\n                    if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                            let iterator = hour_it;\n                            if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch' has 'time_epoch' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316924800);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time' has 'time' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c' has 'temp_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f' has 'temp_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day' has 'is_day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph' has 'wind_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph' has 'wind_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree' has 'wind_degree' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1265);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-735);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir' has 'wind_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb' has 'pressure_mb' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in' has 'pressure_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.73);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.27);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm' has 'precip_mm' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in' has 'precip_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity' has 'humidity' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1058);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-942);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud' has 'cloud' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c' has 'feelslike_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f' has 'feelslike_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c' has 'windchill_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f' has 'windchill_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c' has 'heatindex_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f' has 'heatindex_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c' has 'dewpoint_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-980.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f' has 'dewpoint_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1067.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-932.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain' has 'will_it_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain' has 'chance_of_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow' has 'will_it_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow' has 'chance_of_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km' has 'vis_km' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles' has 'vis_miles' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph' has 'gust_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph' has 'gust_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv' has 'uv' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}}_GET_e2512939af","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": \"1658448000\",\n    \"end_dt\": \"2022-07-23\",\n    \"unixend_dt\": \"1658534400\",\n    \"hour\": \"16\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"dt\": \"invalid-date\",\n    \"unixdt\": \"invalid-unix\",\n    \"end_dt\": \"invalid-date\",\n    \"unixend_dt\": \"invalid-unix\",\n    \"hour\": \"invalid-hour\",\n    \"lang\": \"invalid-lang\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": \"1658448000\",\n    \"end_dt\": \"2022-07-23\",\n    \"unixend_dt\": \"1658534400\",\n    \"hour\": \"12\",\n    \"lang\": \"en\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": \"1658448000\",\n    \"end_dt\": \"2022-07-23\",\n    \"unixend_dt\": \"1658534400\",\n    \"hour\": \"10\",\n    \"lang\": \"en\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"San Francisco\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": \"1658448000\",\n    \"end_dt\": \"2022-07-23\",\n    \"unixend_dt\": \"1658534400\",\n    \"hour\": \"14\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  }\n]"}},"marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/Marine_Weather_API.json","feedback":[],"name":"Marine Weather API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast`)) {\n                    const value = ld.get(jsonResponse, `forecast`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field forecast:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast.forecastday` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    const value = ld.get(jsonResponse, `forecast.forecastday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    let forecastdayArray = ld.get(jsonResponse, `forecast.forecastday`, []);\n                    if (Array.isArray(forecastdayArray)) {\n                        for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                            let iterator = forecastday_it;\n                            if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].date' has 'date' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date format to be date',function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date format for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'date_epoch' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316896000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day' has 'day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1035.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-964.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1096.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-903.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1026.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-973.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1079.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-920.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1087.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-912.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_mph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012.8);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-987.2);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_kph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1020.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-979.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_mm' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_in' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_km' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_miles' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avghumidity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1053);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-947);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.text' has 'text' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.icon' has 'icon' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.code' has 'code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'uv' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro' has 'astro' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].astro:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunrise' has 'sunrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunset' has 'sunset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonrise' has 'moonrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonset' has 'moonset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_phase' has 'moon_phase' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_illumination' has 'moon_illumination' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'hour' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday[${forecastday_it}].hour field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday[${forecastday_it}].hour`)) {\n                    let hourArray = ld.get(jsonResponse, `forecast.forecastday[${forecastday_it}].hour`, []);\n                    if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                            let iterator = hour_it;\n                            if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch' has 'time_epoch' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316924800);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time' has 'time' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c' has 'temp_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f' has 'temp_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day' has 'is_day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph' has 'wind_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph' has 'wind_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree' has 'wind_degree' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1265);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-735);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir' has 'wind_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb' has 'pressure_mb' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in' has 'pressure_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.73);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.27);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm' has 'precip_mm' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in' has 'precip_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity' has 'humidity' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1058);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-942);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud' has 'cloud' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c' has 'feelslike_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f' has 'feelslike_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c' has 'windchill_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f' has 'windchill_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c' has 'heatindex_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f' has 'heatindex_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c' has 'dewpoint_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-980.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f' has 'dewpoint_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1067.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-932.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain' has 'will_it_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain' has 'chance_of_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow' has 'will_it_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow' has 'chance_of_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km' has 'vis_km' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles' has 'vis_miles' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph' has 'gust_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph' has 'gust_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt' has 'sig_ht_mt' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt' has 'swell_ht_mt' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft' has 'swell_ht_ft' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir' has 'swell_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point' has 'swell_dir_16_point' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs' has 'swell_period_secs' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv' has 'uv' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}_GET_3b9375ed0c","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"days\": \"5\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": \"1658448000\",\n    \"hour\": \"16\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"days\": \"invalid_days\",\n    \"dt\": \"invalid_date\",\n    \"unixdt\": \"invalid_unixdt\",\n    \"hour\": \"invalid_hour\",\n    \"lang\": \"invalid_lang\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation\",\n    \"days\": \"invalid_days\",\n    \"dt\": \"invalid_date\",\n    \"unixdt\": \"invalid_unixdt\",\n    \"hour\": \"invalid_hour\",\n    \"lang\": \"invalid_lang\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"AnotherInvalidLocation\",\n    \"days\": \"invalid_days\",\n    \"dt\": \"invalid_date\",\n    \"unixdt\": \"invalid_unixdt\",\n    \"hour\": \"invalid_hour\",\n    \"lang\": \"invalid_lang\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"days\": \"3\",\n    \"dt\": \"2022-07-23\",\n    \"unixdt\": \"1658534400\",\n    \"hour\": \"10\",\n    \"lang\": \"es\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  }\n]"}},"search.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/Search_Autocomplete_API.json","feedback":[],"name":"Search/Autocomplete API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for search.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response is an array\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n                    pm.expect(Array.isArray(responseData)).to.be.true;\n                }\n            } catch (error) {\n                console.error('Error validating array response:', error.message);\n            }\n        });\n        pm.test(\"Each array item has correct structure\", function () {\n            try {\n                if (responseData && Array.isArray(responseData) && responseData.length > 0) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test(`${iterator} element of array 'responseData' has 'id' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `item.id`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for item.id:\", error.message);\n            }\n        })\n  \n        pm.test('item.id maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.id`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(5593180);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for item.id:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'item.name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `item.name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for item.name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`item.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `item.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for item.name:\", error.message);\n            }\n        })\n  \n        pm.test(`item.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `item.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for item.name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'item.region' has 'region' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `item.region`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for item.region:\", error.message);\n            }\n        })\n\n  \n        pm.test(`item.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `item.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for item.region:\", error.message);\n            }\n        })\n  \n        pm.test(`item.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `item.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for item.region:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'item.country' has 'country' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `item.country`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for item.country:\", error.message);\n            }\n        })\n\n  \n        pm.test(`item.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `item.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for item.country:\", error.message);\n            }\n        })\n  \n        pm.test(`item.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `item.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for item.country:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'responseData' has 'lat' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `item.lat`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for item.lat:\", error.message);\n            }\n        })\n  \n        pm.test('item.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1051.52);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for item.lat:\", error.message);\n            }\n        })\n  \n        pm.test('item.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-948.48);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for item.lat:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'responseData' has 'lon' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `item.lon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for item.lon:\", error.message);\n            }\n        })\n  \n        pm.test('item.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(999.88);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for item.lon:\", error.message);\n            }\n        })\n  \n        pm.test('item.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000.12);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for item.lon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'item.url' has 'url' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `item.url`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for item.url:\", error.message);\n            }\n        })\n\n  \n        pm.test(`item.url length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `item.url`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for item.url:\", error.message);\n            }\n        })\n  \n        pm.test(`item.url length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `item.url`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for item.url:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            } catch (error) {\n                console.error('Error validating array item structure:', error.message);\n            }\n        });\n        pm.test(\"Array has minimum required items\", function () {\n            try {\n                if (responseData && Array.isArray(responseData)) {\n                    pm.expect(responseData.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.error('Error checking minimum array items:', error.message);\n            }\n        });\n        pm.test(\"Array does not exceed maximum items\", function () {\n            try {\n                if (responseData && Array.isArray(responseData)) {\n                    pm.expect(responseData.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.error('Error checking maximum array items:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"search.json?q={{q}}_GET_d9f22c6255","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidLocation123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"London\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"NoAPIKey\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"ExceededQuota\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"ip.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/IP_Lookup_API.json","feedback":[],"name":"IP Lookup API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for ip.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `ip` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`ip`)) {\n                    const value = ld.get(jsonResponse, `ip`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field ip:\", error.message);\n            }\n        })\n  \n        pm.test(`ip length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `ip`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for ip:\", error.message);\n            }\n        })\n  \n        pm.test(`ip length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `ip`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for ip:\", error.message);\n            }\n        })\n\n        pm.test('ip format to be ipv4',function(){  \n            try {\n                const value = ld.get(responseData, `ip`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(d{1,3}.){3}d{1,3}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking IPv4 format for ip:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`type`)) {\n                    const value = ld.get(jsonResponse, `type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field type:\", error.message);\n            }\n        })\n  \n        pm.test(`type length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for type:\", error.message);\n            }\n        })\n  \n        pm.test(`type length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `continent_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`continent_code`)) {\n                    const value = ld.get(jsonResponse, `continent_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field continent_code:\", error.message);\n            }\n        })\n  \n        pm.test(`continent_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `continent_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for continent_code:\", error.message);\n            }\n        })\n  \n        pm.test(`continent_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `continent_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for continent_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `continent_name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`continent_name`)) {\n                    const value = ld.get(jsonResponse, `continent_name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field continent_name:\", error.message);\n            }\n        })\n  \n        pm.test(`continent_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `continent_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for continent_name:\", error.message);\n            }\n        })\n  \n        pm.test(`continent_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `continent_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for continent_name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country_code`)) {\n                    const value = ld.get(jsonResponse, `country_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country_code:\", error.message);\n            }\n        })\n  \n        pm.test(`country_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `country_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for country_code:\", error.message);\n            }\n        })\n  \n        pm.test(`country_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `country_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for country_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country_name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country_name`)) {\n                    const value = ld.get(jsonResponse, `country_name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`country_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`country_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for country_name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `is_eu` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`is_eu`)) {\n                    const value = ld.get(jsonResponse, `is_eu`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field is_eu:\", error.message);\n            }\n        })\n  \n        pm.test(`is_eu length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `is_eu`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for is_eu:\", error.message);\n            }\n        })\n  \n        pm.test(`is_eu length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `is_eu`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for is_eu:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `geoname_id` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`geoname_id`)) {\n                    const value = ld.get(responseData, `geoname_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field geoname_id:\", error.message);\n            }\n        })\n  \n        pm.test('geoname_id maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `geoname_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(5287486);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for geoname_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `city` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`city`)) {\n                    const value = ld.get(jsonResponse, `city`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field city:\", error.message);\n            }\n        })\n  \n        pm.test(`city length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `city`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for city:\", error.message);\n            }\n        })\n  \n        pm.test(`city length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `city`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for city:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`region`)) {\n                    const value = ld.get(jsonResponse, `region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field region:\", error.message);\n            }\n        })\n  \n        pm.test(`region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for region:\", error.message);\n            }\n        })\n  \n        pm.test(`region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lat`)) {\n                    const value = ld.get(responseData, `lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lat:\", error.message);\n            }\n        })\n  \n        pm.test('lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1051.5264);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for lat:\", error.message);\n            }\n        })\n  \n        pm.test('lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-948.4736);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lon`)) {\n                    const value = ld.get(responseData, `lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lon:\", error.message);\n            }\n        })\n  \n        pm.test('lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(999.9159);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for lon:\", error.message);\n            }\n        })\n  \n        pm.test('lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000.0841);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`tz_id`)) {\n                    const value = ld.get(jsonResponse, `tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`localtime_epoch`)) {\n                    const value = ld.get(responseData, `localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317041290);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`localtime`)) {\n                    const value = ld.get(jsonResponse, `localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for localtime:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"ip.json?q={{q}}_GET_d0aefd50f4","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"London\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Berlin\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"timezone.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/Time_Zone_API.json","feedback":[],"name":"Time Zone API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for timezone.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n  \n        pm.test(`name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for name:\", error.message);\n            }\n        })\n  \n        pm.test(`name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`region`)) {\n                    const value = ld.get(jsonResponse, `region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field region:\", error.message);\n            }\n        })\n  \n        pm.test(`region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for region:\", error.message);\n            }\n        })\n  \n        pm.test(`region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country`)) {\n                    const value = ld.get(jsonResponse, `country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country:\", error.message);\n            }\n        })\n  \n        pm.test(`country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for country:\", error.message);\n            }\n        })\n  \n        pm.test(`country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lat`)) {\n                    const value = ld.get(responseData, `lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lat:\", error.message);\n            }\n        })\n  \n        pm.test('lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for lat:\", error.message);\n            }\n        })\n  \n        pm.test('lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lon`)) {\n                    const value = ld.get(responseData, `lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lon:\", error.message);\n            }\n        })\n  \n        pm.test('lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for lon:\", error.message);\n            }\n        })\n  \n        pm.test('lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`tz_id`)) {\n                    const value = ld.get(jsonResponse, `tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`localtime_epoch`)) {\n                    const value = ld.get(responseData, `localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`localtime`)) {\n                    const value = ld.get(jsonResponse, `localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for localtime:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"timezone.json?q={{q}}_GET_d8e8991409","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"UnauthorizedAccess\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"QuotaExceeded\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"astronomy.json?q={{q}}&dt={{dt}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/Astronomy_API.json","feedback":[],"name":"Astronomy API","testscript":" \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for astronomy.json?q={{q}}&dt={{dt}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy`)) {\n                    const value = ld.get(jsonResponse, `astronomy`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field astronomy:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field astronomy.astro:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.sunrise` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.sunrise`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.sunrise`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.sunset` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.sunset`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.sunset`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.moonrise` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.moonrise`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.moonrise`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.moonset` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.moonset`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.moonset`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.moon_phase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.moon_phase`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.moon_phase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.moon_illumination` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.moon_illumination`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.moon_illumination`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.moon_illumination:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n","bodyHash":"astronomy.json?q={{q}}&dt={{dt}}_GET_1b9f6b9595","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2023-10-15\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"dt\": \"invalid-date\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2023-11-01\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidLocation\",\n    \"dt\": \"2023-12-31\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"dt\": \"2023-09-20\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"testFilePath":"/var/tmp/Roost/RoostGPT/weather_api_test/6dfcd091-ce7e-4ae7-bc37-40c6d74dd5fa/source/api-spec/postman_collections/modified_postman_weather.json"}}}