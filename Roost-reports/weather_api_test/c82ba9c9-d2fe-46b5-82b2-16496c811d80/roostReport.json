{"postmanCollection":{"filePaths":["/var/tmp/Roost/RoostGPT/weather_api_test/c82ba9c9-d2fe-46b5-82b2-16496c811d80/source/api-spec/postman_collections/weather_api_test/weather/roost_postman_weather_1763709096.json"]},"headBranch":"roost-c82ba9c9-d2fe-46b5-82b2-16496c811d80","reportHeadBranch":"roost-report","aiUsage":{"promptTokens":12461,"completionTokens":4990,"apiCallsToAI":9},"repoPath":"/var/tmp/Roost/RoostGPT/weather_api_test/c82ba9c9-d2fe-46b5-82b2-16496c811d80/source/api-spec","errorMsg":"","gitPrUrl":"","status":"","statusDetails":"","coverageReportURL":{},"testReportURL":{},"testMetrics":{"filesScanned":1,"totalFiles":1,"totalTestFiles":9,"successfulTests":9,"testWithCompilationErrors":0,"skippedMethods":0,"toBeProcessed":0,"testswithRunTimeErrors":0,"existingTestPresent":0,"notSupported":0,"methodsScanned":9,"methodsSuccess":9},"advancedDetails":{"/var/tmp/Roost/RoostGPT/weather_api_test/c82ba9c9-d2fe-46b5-82b2-16496c811d80/weather.yaml":{"current.json?q={{q}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Realtime_API.json","feedback":[],"name":"Realtime API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for current.json?q={{q}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let locationRequired = false\n          if (locationRequired || `responseData`.get(`location`)) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let nameRequired = false\n          if (nameRequired || `responseData.location`.get(`name`)) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let regionRequired = false\n          if (regionRequired || `responseData.location`.get(`region`)) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let countryRequired = false\n          if (countryRequired || `responseData.location`.get(`country`)) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let latRequired = false\n          if (latRequired || `responseData.location`.get(`lat`)) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let lonRequired = false\n          if (lonRequired || `responseData.location`.get(`lon`)) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let tz_idRequired = false\n          if (tz_idRequired || `responseData.location`.get(`tz_id`)) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let localtime_epochRequired = false\n          if (localtime_epochRequired || `responseData.location`.get(`localtime_epoch`)) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let localtimeRequired = false\n          if (localtimeRequired || `responseData.location`.get(`localtime`)) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: current\n          let currentRequired = false\n          if (currentRequired || `responseData`.get(`current`)) {\n            pm.test(`'responseData field has current that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`current`)) {\n                const value = responseData?.current;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated_epoch\n          let last_updated_epochRequired = false\n          if (last_updated_epochRequired || `responseData.current`.get(`last_updated_epoch`)) {\n            pm.test(`'responseData.current field has last_updated_epoch that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated_epoch`)) {\n                const value = responseData.current?.last_updated_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated\n          let last_updatedRequired = false\n          if (last_updatedRequired || `responseData.current`.get(`last_updated`)) {\n            pm.test(`'responseData.current field has last_updated that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated`)) {\n                const value = responseData.current?.last_updated;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_c\n          let temp_cRequired = false\n          if (temp_cRequired || `responseData.current`.get(`temp_c`)) {\n            pm.test(`'responseData.current field has temp_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_c`)) {\n                const value = responseData.current?.temp_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_f\n          let temp_fRequired = false\n          if (temp_fRequired || `responseData.current`.get(`temp_f`)) {\n            pm.test(`'responseData.current field has temp_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_f`)) {\n                const value = responseData.current?.temp_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: is_day\n          let is_dayRequired = false\n          if (is_dayRequired || `responseData.current`.get(`is_day`)) {\n            pm.test(`'responseData.current field has is_day that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`is_day`)) {\n                const value = responseData.current?.is_day;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: condition\n          let conditionRequired = false\n          if (conditionRequired || `responseData.current`.get(`condition`)) {\n            pm.test(`'responseData.current field has condition that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                const value = responseData.current?.condition;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: text\n          let textRequired = false\n          if (textRequired || `responseData.current.condition`.get(`text`)) {\n            pm.test(`'responseData.current.condition field has text that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                const value = responseData.current.condition?.text;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: icon\n          let iconRequired = false\n          if (iconRequired || `responseData.current.condition`.get(`icon`)) {\n            pm.test(`'responseData.current.condition field has icon that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                const value = responseData.current.condition?.icon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData.current.condition`.get(`code`)) {\n            pm.test(`'responseData.current.condition field has code that is of type number'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData.current.condition?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_mph\n          let wind_mphRequired = false\n          if (wind_mphRequired || `responseData.current`.get(`wind_mph`)) {\n            pm.test(`'responseData.current field has wind_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_mph`)) {\n                const value = responseData.current?.wind_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_kph\n          let wind_kphRequired = false\n          if (wind_kphRequired || `responseData.current`.get(`wind_kph`)) {\n            pm.test(`'responseData.current field has wind_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_kph`)) {\n                const value = responseData.current?.wind_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_degree\n          let wind_degreeRequired = false\n          if (wind_degreeRequired || `responseData.current`.get(`wind_degree`)) {\n            pm.test(`'responseData.current field has wind_degree that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_degree`)) {\n                const value = responseData.current?.wind_degree;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_dir\n          let wind_dirRequired = false\n          if (wind_dirRequired || `responseData.current`.get(`wind_dir`)) {\n            pm.test(`'responseData.current field has wind_dir that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_dir`)) {\n                const value = responseData.current?.wind_dir;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_mb\n          let pressure_mbRequired = false\n          if (pressure_mbRequired || `responseData.current`.get(`pressure_mb`)) {\n            pm.test(`'responseData.current field has pressure_mb that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_mb`)) {\n                const value = responseData.current?.pressure_mb;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_in\n          let pressure_inRequired = false\n          if (pressure_inRequired || `responseData.current`.get(`pressure_in`)) {\n            pm.test(`'responseData.current field has pressure_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_in`)) {\n                const value = responseData.current?.pressure_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_mm\n          let precip_mmRequired = false\n          if (precip_mmRequired || `responseData.current`.get(`precip_mm`)) {\n            pm.test(`'responseData.current field has precip_mm that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_mm`)) {\n                const value = responseData.current?.precip_mm;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_in\n          let precip_inRequired = false\n          if (precip_inRequired || `responseData.current`.get(`precip_in`)) {\n            pm.test(`'responseData.current field has precip_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_in`)) {\n                const value = responseData.current?.precip_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: humidity\n          let humidityRequired = false\n          if (humidityRequired || `responseData.current`.get(`humidity`)) {\n            pm.test(`'responseData.current field has humidity that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`humidity`)) {\n                const value = responseData.current?.humidity;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: cloud\n          let cloudRequired = false\n          if (cloudRequired || `responseData.current`.get(`cloud`)) {\n            pm.test(`'responseData.current field has cloud that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`cloud`)) {\n                const value = responseData.current?.cloud;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_c\n          let feelslike_cRequired = false\n          if (feelslike_cRequired || `responseData.current`.get(`feelslike_c`)) {\n            pm.test(`'responseData.current field has feelslike_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_c`)) {\n                const value = responseData.current?.feelslike_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_f\n          let feelslike_fRequired = false\n          if (feelslike_fRequired || `responseData.current`.get(`feelslike_f`)) {\n            pm.test(`'responseData.current field has feelslike_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_f`)) {\n                const value = responseData.current?.feelslike_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_km\n          let vis_kmRequired = false\n          if (vis_kmRequired || `responseData.current`.get(`vis_km`)) {\n            pm.test(`'responseData.current field has vis_km that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_km`)) {\n                const value = responseData.current?.vis_km;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_miles\n          let vis_milesRequired = false\n          if (vis_milesRequired || `responseData.current`.get(`vis_miles`)) {\n            pm.test(`'responseData.current field has vis_miles that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_miles`)) {\n                const value = responseData.current?.vis_miles;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: uv\n          let uvRequired = false\n          if (uvRequired || `responseData.current`.get(`uv`)) {\n            pm.test(`'responseData.current field has uv that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                const value = responseData.current?.uv;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_mph\n          let gust_mphRequired = false\n          if (gust_mphRequired || `responseData.current`.get(`gust_mph`)) {\n            pm.test(`'responseData.current field has gust_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_mph`)) {\n                const value = responseData.current?.gust_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_kph\n          let gust_kphRequired = false\n          if (gust_kphRequired || `responseData.current`.get(`gust_kph`)) {\n            pm.test(`'responseData.current field has gust_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_kph`)) {\n                const value = responseData.current?.gust_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: air_quality\n          let air_qualityRequired = false\n          if (air_qualityRequired || `responseData.current`.get(`air_quality`)) {\n            pm.test(`'responseData.current field has air_quality that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`air_quality`)) {\n                const value = responseData.current?.air_quality;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: co\n          let coRequired = false\n          if (coRequired || `responseData.current.air_quality`.get(`co`)) {\n            pm.test(`'responseData.current.air_quality field has co that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`co`)) {\n                const value = responseData.current.air_quality?.co;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: no2\n          let no2Required = false\n          if (no2Required || `responseData.current.air_quality`.get(`no2`)) {\n            pm.test(`'responseData.current.air_quality field has no2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`no2`)) {\n                const value = responseData.current.air_quality?.no2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: o3\n          let o3Required = false\n          if (o3Required || `responseData.current.air_quality`.get(`o3`)) {\n            pm.test(`'responseData.current.air_quality field has o3 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`o3`)) {\n                const value = responseData.current.air_quality?.o3;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: so2\n          let so2Required = false\n          if (so2Required || `responseData.current.air_quality`.get(`so2`)) {\n            pm.test(`'responseData.current.air_quality field has so2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`so2`)) {\n                const value = responseData.current.air_quality?.so2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm2_5\n          let pm2_5Required = false\n          if (pm2_5Required || `responseData.current.air_quality`.get(`pm2_5`)) {\n            pm.test(`'responseData.current.air_quality field has pm2_5 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm2_5`)) {\n                const value = responseData.current.air_quality?.pm2_5;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm10\n          let pm10Required = false\n          if (pm10Required || `responseData.current.air_quality`.get(`pm10`)) {\n            pm.test(`'responseData.current.air_quality field has pm10 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm10`)) {\n                const value = responseData.current.air_quality?.pm10;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: us-epa-index\n          let us - epa - indexRequired = false\n          if (us - epa - indexRequired || `responseData.current.air_quality`.get(`us-epa-index`)) {\n            pm.test(`'responseData.current.air_quality field has us-epa-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`us-epa-index`)) {\n                const value = responseData.current.air_quality?.us - epa - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: gb-defra-index\n          let gb - defra - indexRequired = false\n          if (gb - defra - indexRequired || `responseData.current.air_quality`.get(`gb-defra-index`)) {\n            pm.test(`'responseData.current.air_quality field has gb-defra-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`gb-defra-index`)) {\n                const value = responseData.current.air_quality?.gb - defra - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"current.json?q={{q}}&lang={{lang}}_GET_11ef9fbb39","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"lang\": \"es\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"lang\": \"en\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation123\",\n    \"lang\": \"en\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'\"\n  },\n  {\n    \"q\": \"New York\",\n    \"lang\": \"invalid_lang_code\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"New York\",\n    \"lang\": \"en\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Forecast_API.json","feedback":[],"name":"Forecast API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let locationRequired = false\n          if (locationRequired || `responseData`.get(`location`)) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let nameRequired = false\n          if (nameRequired || `responseData.location`.get(`name`)) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let regionRequired = false\n          if (regionRequired || `responseData.location`.get(`region`)) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let countryRequired = false\n          if (countryRequired || `responseData.location`.get(`country`)) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let latRequired = false\n          if (latRequired || `responseData.location`.get(`lat`)) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let lonRequired = false\n          if (lonRequired || `responseData.location`.get(`lon`)) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let tz_idRequired = false\n          if (tz_idRequired || `responseData.location`.get(`tz_id`)) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let localtime_epochRequired = false\n          if (localtime_epochRequired || `responseData.location`.get(`localtime_epoch`)) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let localtimeRequired = false\n          if (localtimeRequired || `responseData.location`.get(`localtime`)) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: current\n          let currentRequired = false\n          if (currentRequired || `responseData`.get(`current`)) {\n            pm.test(`'responseData field has current that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`current`)) {\n                const value = responseData?.current;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated_epoch\n          let last_updated_epochRequired = false\n          if (last_updated_epochRequired || `responseData.current`.get(`last_updated_epoch`)) {\n            pm.test(`'responseData.current field has last_updated_epoch that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated_epoch`)) {\n                const value = responseData.current?.last_updated_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated\n          let last_updatedRequired = false\n          if (last_updatedRequired || `responseData.current`.get(`last_updated`)) {\n            pm.test(`'responseData.current field has last_updated that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated`)) {\n                const value = responseData.current?.last_updated;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_c\n          let temp_cRequired = false\n          if (temp_cRequired || `responseData.current`.get(`temp_c`)) {\n            pm.test(`'responseData.current field has temp_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_c`)) {\n                const value = responseData.current?.temp_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_f\n          let temp_fRequired = false\n          if (temp_fRequired || `responseData.current`.get(`temp_f`)) {\n            pm.test(`'responseData.current field has temp_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_f`)) {\n                const value = responseData.current?.temp_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: is_day\n          let is_dayRequired = false\n          if (is_dayRequired || `responseData.current`.get(`is_day`)) {\n            pm.test(`'responseData.current field has is_day that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`is_day`)) {\n                const value = responseData.current?.is_day;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: condition\n          let conditionRequired = false\n          if (conditionRequired || `responseData.current`.get(`condition`)) {\n            pm.test(`'responseData.current field has condition that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                const value = responseData.current?.condition;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: text\n          let textRequired = false\n          if (textRequired || `responseData.current.condition`.get(`text`)) {\n            pm.test(`'responseData.current.condition field has text that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                const value = responseData.current.condition?.text;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: icon\n          let iconRequired = false\n          if (iconRequired || `responseData.current.condition`.get(`icon`)) {\n            pm.test(`'responseData.current.condition field has icon that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                const value = responseData.current.condition?.icon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData.current.condition`.get(`code`)) {\n            pm.test(`'responseData.current.condition field has code that is of type number'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData.current.condition?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_mph\n          let wind_mphRequired = false\n          if (wind_mphRequired || `responseData.current`.get(`wind_mph`)) {\n            pm.test(`'responseData.current field has wind_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_mph`)) {\n                const value = responseData.current?.wind_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_kph\n          let wind_kphRequired = false\n          if (wind_kphRequired || `responseData.current`.get(`wind_kph`)) {\n            pm.test(`'responseData.current field has wind_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_kph`)) {\n                const value = responseData.current?.wind_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_degree\n          let wind_degreeRequired = false\n          if (wind_degreeRequired || `responseData.current`.get(`wind_degree`)) {\n            pm.test(`'responseData.current field has wind_degree that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_degree`)) {\n                const value = responseData.current?.wind_degree;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_dir\n          let wind_dirRequired = false\n          if (wind_dirRequired || `responseData.current`.get(`wind_dir`)) {\n            pm.test(`'responseData.current field has wind_dir that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_dir`)) {\n                const value = responseData.current?.wind_dir;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_mb\n          let pressure_mbRequired = false\n          if (pressure_mbRequired || `responseData.current`.get(`pressure_mb`)) {\n            pm.test(`'responseData.current field has pressure_mb that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_mb`)) {\n                const value = responseData.current?.pressure_mb;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_in\n          let pressure_inRequired = false\n          if (pressure_inRequired || `responseData.current`.get(`pressure_in`)) {\n            pm.test(`'responseData.current field has pressure_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_in`)) {\n                const value = responseData.current?.pressure_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_mm\n          let precip_mmRequired = false\n          if (precip_mmRequired || `responseData.current`.get(`precip_mm`)) {\n            pm.test(`'responseData.current field has precip_mm that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_mm`)) {\n                const value = responseData.current?.precip_mm;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_in\n          let precip_inRequired = false\n          if (precip_inRequired || `responseData.current`.get(`precip_in`)) {\n            pm.test(`'responseData.current field has precip_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_in`)) {\n                const value = responseData.current?.precip_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: humidity\n          let humidityRequired = false\n          if (humidityRequired || `responseData.current`.get(`humidity`)) {\n            pm.test(`'responseData.current field has humidity that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`humidity`)) {\n                const value = responseData.current?.humidity;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: cloud\n          let cloudRequired = false\n          if (cloudRequired || `responseData.current`.get(`cloud`)) {\n            pm.test(`'responseData.current field has cloud that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`cloud`)) {\n                const value = responseData.current?.cloud;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_c\n          let feelslike_cRequired = false\n          if (feelslike_cRequired || `responseData.current`.get(`feelslike_c`)) {\n            pm.test(`'responseData.current field has feelslike_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_c`)) {\n                const value = responseData.current?.feelslike_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_f\n          let feelslike_fRequired = false\n          if (feelslike_fRequired || `responseData.current`.get(`feelslike_f`)) {\n            pm.test(`'responseData.current field has feelslike_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_f`)) {\n                const value = responseData.current?.feelslike_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_km\n          let vis_kmRequired = false\n          if (vis_kmRequired || `responseData.current`.get(`vis_km`)) {\n            pm.test(`'responseData.current field has vis_km that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_km`)) {\n                const value = responseData.current?.vis_km;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_miles\n          let vis_milesRequired = false\n          if (vis_milesRequired || `responseData.current`.get(`vis_miles`)) {\n            pm.test(`'responseData.current field has vis_miles that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_miles`)) {\n                const value = responseData.current?.vis_miles;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: uv\n          let uvRequired = false\n          if (uvRequired || `responseData.current`.get(`uv`)) {\n            pm.test(`'responseData.current field has uv that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                const value = responseData.current?.uv;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_mph\n          let gust_mphRequired = false\n          if (gust_mphRequired || `responseData.current`.get(`gust_mph`)) {\n            pm.test(`'responseData.current field has gust_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_mph`)) {\n                const value = responseData.current?.gust_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_kph\n          let gust_kphRequired = false\n          if (gust_kphRequired || `responseData.current`.get(`gust_kph`)) {\n            pm.test(`'responseData.current field has gust_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_kph`)) {\n                const value = responseData.current?.gust_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: air_quality\n          let air_qualityRequired = false\n          if (air_qualityRequired || `responseData.current`.get(`air_quality`)) {\n            pm.test(`'responseData.current field has air_quality that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`air_quality`)) {\n                const value = responseData.current?.air_quality;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: co\n          let coRequired = false\n          if (coRequired || `responseData.current.air_quality`.get(`co`)) {\n            pm.test(`'responseData.current.air_quality field has co that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`co`)) {\n                const value = responseData.current.air_quality?.co;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: no2\n          let no2Required = false\n          if (no2Required || `responseData.current.air_quality`.get(`no2`)) {\n            pm.test(`'responseData.current.air_quality field has no2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`no2`)) {\n                const value = responseData.current.air_quality?.no2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: o3\n          let o3Required = false\n          if (o3Required || `responseData.current.air_quality`.get(`o3`)) {\n            pm.test(`'responseData.current.air_quality field has o3 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`o3`)) {\n                const value = responseData.current.air_quality?.o3;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: so2\n          let so2Required = false\n          if (so2Required || `responseData.current.air_quality`.get(`so2`)) {\n            pm.test(`'responseData.current.air_quality field has so2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`so2`)) {\n                const value = responseData.current.air_quality?.so2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm2_5\n          let pm2_5Required = false\n          if (pm2_5Required || `responseData.current.air_quality`.get(`pm2_5`)) {\n            pm.test(`'responseData.current.air_quality field has pm2_5 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm2_5`)) {\n                const value = responseData.current.air_quality?.pm2_5;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm10\n          let pm10Required = false\n          if (pm10Required || `responseData.current.air_quality`.get(`pm10`)) {\n            pm.test(`'responseData.current.air_quality field has pm10 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm10`)) {\n                const value = responseData.current.air_quality?.pm10;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: us-epa-index\n          let us - epa - indexRequired = false\n          if (us - epa - indexRequired || `responseData.current.air_quality`.get(`us-epa-index`)) {\n            pm.test(`'responseData.current.air_quality field has us-epa-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`us-epa-index`)) {\n                const value = responseData.current.air_quality?.us - epa - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: gb-defra-index\n          let gb - defra - indexRequired = false\n          if (gb - defra - indexRequired || `responseData.current.air_quality`.get(`gb-defra-index`)) {\n            pm.test(`'responseData.current.air_quality field has gb-defra-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`gb-defra-index`)) {\n                const value = responseData.current.air_quality?.gb - defra - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let forecastRequired = false\n          if (forecastRequired || `responseData`.get(`forecast`)) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: alerts\n          let alertsRequired = false\n          if (alertsRequired || `responseData`.get(`alerts`)) {\n            pm.test(`'responseData field has alerts that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`alerts`)) {\n                const value = responseData?.alerts;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.alerts` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.alerts`)) {\n              const value = responseData?.responseData.alerts;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.alerts.alert field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.alerts).to.have.nested.property(`alert`)) {\n            let alertArray = ld.get(responseData.alerts, `alert`, []);\n            if (Array.isArray(alertArray)) {\n              for (let alert_it = 0; alert_it < alertArray.length; alert_it++) {\n                let iterator = alert_it;\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'headline' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.headline;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'msgtype' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.msgtype;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'severity' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.severity;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'urgency' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.urgency;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'areas' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.areas;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'category' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.category;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'certainty' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.certainty;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'event' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.event;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'note' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.note;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'effective' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.effective;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('alertArray[${iterator}] format to be date-time', function() {\n                    const value = ld.get(responseData, `alertArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                    }\n                  })\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'expires' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.expires;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('alertArray[${iterator}] format to be date-time', function() {\n                    const value = ld.get(responseData, `alertArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                    }\n                  })\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'desc' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.desc;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'instruction' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.instruction;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}}_GET_b96c60d479","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"days\": 5,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"days\": 3,\n    \"dt\": \"2023-10-01\",\n    \"unixdt\": 1696156800,\n    \"hour\": 14,\n    \"lang\": \"en\",\n    \"alerts\": \"true\",\n    \"aqi\": \"yes\",\n    \"tp\": 1,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"days\": 7,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCity123\",\n    \"days\": 2,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'<br />Error code 1005: API request url is invalid.\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"days\": 15,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1005: API request url is invalid.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"London\",\n    \"days\": 4,\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"future.json?q={{q}}&dt={{dt}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Future_API.json","feedback":[],"name":"Future API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for future.json?q={{q}}&dt={{dt}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let locationRequired = false\n          if (locationRequired || `responseData`.get(`location`)) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let nameRequired = false\n          if (nameRequired || `responseData.location`.get(`name`)) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let regionRequired = false\n          if (regionRequired || `responseData.location`.get(`region`)) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let countryRequired = false\n          if (countryRequired || `responseData.location`.get(`country`)) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let latRequired = false\n          if (latRequired || `responseData.location`.get(`lat`)) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let lonRequired = false\n          if (lonRequired || `responseData.location`.get(`lon`)) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let tz_idRequired = false\n          if (tz_idRequired || `responseData.location`.get(`tz_id`)) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let localtime_epochRequired = false\n          if (localtime_epochRequired || `responseData.location`.get(`localtime_epoch`)) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let localtimeRequired = false\n          if (localtimeRequired || `responseData.location`.get(`localtime`)) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let forecastRequired = false\n          if (forecastRequired || `responseData`.get(`forecast`)) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"future.json?q={{q}}&dt={{dt}}&lang={{lang}}_GET_4ece0fa346","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2022-08-15\",\n    \"lang\": \"es\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCity\",\n    \"dt\": \"2022-07-22\",\n    \"lang\": \"fr\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"dt\": \"invalid-date\",\n    \"lang\": \"jp\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.\"\n  },\n  {\n    \"q\": \"Berlin\",\n    \"lang\": \"de\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Sydney\",\n    \"dt\": \"2022-09-01\",\n    \"lang\": \"en\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/History_API.json","feedback":[],"name":"History API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let locationRequired = false\n          if (locationRequired || `responseData`.get(`location`)) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let nameRequired = false\n          if (nameRequired || `responseData.location`.get(`name`)) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let regionRequired = false\n          if (regionRequired || `responseData.location`.get(`region`)) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let countryRequired = false\n          if (countryRequired || `responseData.location`.get(`country`)) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let latRequired = false\n          if (latRequired || `responseData.location`.get(`lat`)) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let lonRequired = false\n          if (lonRequired || `responseData.location`.get(`lon`)) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let tz_idRequired = false\n          if (tz_idRequired || `responseData.location`.get(`tz_id`)) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let localtime_epochRequired = false\n          if (localtime_epochRequired || `responseData.location`.get(`localtime_epoch`)) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let localtimeRequired = false\n          if (localtimeRequired || `responseData.location`.get(`localtime`)) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let forecastRequired = false\n          if (forecastRequired || `responseData`.get(`forecast`)) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}}_GET_e2512939af","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": 1658448000,\n    \"end_dt\": \"2022-07-23\",\n    \"unixend_dt\": 1658534400,\n    \"hour\": 16,\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2022-08-01\",\n    \"unixdt\": 1659312000,\n    \"hour\": 10,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"dt\": \"2022-09-15\",\n    \"unixdt\": 1663200000,\n    \"end_dt\": \"2022-09-16\",\n    \"unixend_dt\": 1663286400,\n    \"hour\": 14,\n    \"lang\": \"es\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": 1658448000,\n    \"hour\": 16,\n    \"lang\": \"en\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCity\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": 1658448000,\n    \"hour\": 16,\n    \"lang\": \"en\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": 1658448000,\n    \"hour\": 16,\n    \"lang\": \"xx\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": 1658448000,\n    \"hour\": 16,\n    \"lang\": \"en\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"unixdt\": 1658448000,\n    \"hour\": 16,\n    \"lang\": \"en\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Marine_Weather_API.json","feedback":[],"name":"Marine Weather API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let locationRequired = false\n          if (locationRequired || `responseData`.get(`location`)) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let nameRequired = false\n          if (nameRequired || `responseData.location`.get(`name`)) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let regionRequired = false\n          if (regionRequired || `responseData.location`.get(`region`)) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let countryRequired = false\n          if (countryRequired || `responseData.location`.get(`country`)) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let latRequired = false\n          if (latRequired || `responseData.location`.get(`lat`)) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let lonRequired = false\n          if (lonRequired || `responseData.location`.get(`lon`)) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let tz_idRequired = false\n          if (tz_idRequired || `responseData.location`.get(`tz_id`)) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let localtime_epochRequired = false\n          if (localtime_epochRequired || `responseData.location`.get(`localtime_epoch`)) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let localtimeRequired = false\n          if (localtimeRequired || `responseData.location`.get(`localtime`)) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let forecastRequired = false\n          if (forecastRequired || `responseData`.get(`forecast`)) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'sig_ht_mt' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.sig_ht_mt;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_ht_mt' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_ht_mt;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_ht_ft' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_ht_ft;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_dir' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_dir_16_point' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_dir_16_point;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_period_secs' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_period_secs;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}_GET_3b9375ed0c","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"days\": 5,\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"days\": 7,\n    \"dt\": \"2023-10-01\",\n    \"unixdt\": 1696156800,\n    \"hour\": 14,\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"days\": 3,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCityName\",\n    \"days\": 2,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"days\": 15,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1005: API request url is invalid.<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"days\": 5,\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"New York\",\n    \"days\": 5,\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"search.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Search_Autocomplete_API.json","feedback":[],"name":"Search/Autocomplete API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for search.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: id\n                let idRequired = false\n                if (idRequired || `item`.get(`id`)) {\n                  pm.test(`'item field has id that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`id`)) {\n                      const value = item?.id;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: name\n                let nameRequired = false\n                if (nameRequired || `item`.get(`name`)) {\n                  pm.test(`'item field has name that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`name`)) {\n                      const value = item?.name;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: region\n                let regionRequired = false\n                if (regionRequired || `item`.get(`region`)) {\n                  pm.test(`'item field has region that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`region`)) {\n                      const value = item?.region;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: country\n                let countryRequired = false\n                if (countryRequired || `item`.get(`country`)) {\n                  pm.test(`'item field has country that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`country`)) {\n                      const value = item?.country;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: lat\n                let latRequired = false\n                if (latRequired || `item`.get(`lat`)) {\n                  pm.test(`'item field has lat that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                      const value = item?.lat;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: lon\n                let lonRequired = false\n                if (lonRequired || `item`.get(`lon`)) {\n                  pm.test(`'item field has lon that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                      const value = item?.lon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: url\n                let urlRequired = false\n                if (urlRequired || `item`.get(`url`)) {\n                  pm.test(`'item field has url that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`url`)) {\n                      const value = item?.url;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"search.json?q={{q}}_GET_d9f22c6255","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCityName123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"ip.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/IP_Lookup_API.json","feedback":[],"name":"IP Lookup API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for ip.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: ip\n          let ipRequired = false\n          if (ipRequired || `responseData`.get(`ip`)) {\n            pm.test(`'responseData field has ip that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`ip`)) {\n                const value = responseData?.ip;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: type\n          let typeRequired = false\n          if (typeRequired || `responseData`.get(`type`)) {\n            pm.test(`'responseData field has type that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`type`)) {\n                const value = responseData?.type;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: continent_code\n          let continent_codeRequired = false\n          if (continent_codeRequired || `responseData`.get(`continent_code`)) {\n            pm.test(`'responseData field has continent_code that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`continent_code`)) {\n                const value = responseData?.continent_code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: continent_name\n          let continent_nameRequired = false\n          if (continent_nameRequired || `responseData`.get(`continent_name`)) {\n            pm.test(`'responseData field has continent_name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`continent_name`)) {\n                const value = responseData?.continent_name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country_code\n          let country_codeRequired = false\n          if (country_codeRequired || `responseData`.get(`country_code`)) {\n            pm.test(`'responseData field has country_code that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country_code`)) {\n                const value = responseData?.country_code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country_name\n          let country_nameRequired = false\n          if (country_nameRequired || `responseData`.get(`country_name`)) {\n            pm.test(`'responseData field has country_name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country_name`)) {\n                const value = responseData?.country_name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: is_eu\n          let is_euRequired = false\n          if (is_euRequired || `responseData`.get(`is_eu`)) {\n            pm.test(`'responseData field has is_eu that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`is_eu`)) {\n                const value = responseData?.is_eu;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: geoname_id\n          let geoname_idRequired = false\n          if (geoname_idRequired || `responseData`.get(`geoname_id`)) {\n            pm.test(`'responseData field has geoname_id that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`geoname_id`)) {\n                const value = responseData?.geoname_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: city\n          let cityRequired = false\n          if (cityRequired || `responseData`.get(`city`)) {\n            pm.test(`'responseData field has city that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`city`)) {\n                const value = responseData?.city;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: region\n          let regionRequired = false\n          if (regionRequired || `responseData`.get(`region`)) {\n            pm.test(`'responseData field has region that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lat\n          let latRequired = false\n          if (latRequired || `responseData`.get(`lat`)) {\n            pm.test(`'responseData field has lat that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lon\n          let lonRequired = false\n          if (lonRequired || `responseData`.get(`lon`)) {\n            pm.test(`'responseData field has lon that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: tz_id\n          let tz_idRequired = false\n          if (tz_idRequired || `responseData`.get(`tz_id`)) {\n            pm.test(`'responseData field has tz_id that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime_epoch\n          let localtime_epochRequired = false\n          if (localtime_epochRequired || `responseData`.get(`localtime_epoch`)) {\n            pm.test(`'responseData field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime\n          let localtimeRequired = false\n          if (localtimeRequired || `responseData`.get(`localtime`)) {\n            pm.test(`'responseData field has localtime that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"ip.json?q={{q}}_GET_d0aefd50f4","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"San Francisco\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Miami\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"timezone.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Time_Zone_API.json","feedback":[],"name":"Time Zone API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for timezone.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: name\n          let nameRequired = false\n          if (nameRequired || `responseData`.get(`name`)) {\n            pm.test(`'responseData field has name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: region\n          let regionRequired = false\n          if (regionRequired || `responseData`.get(`region`)) {\n            pm.test(`'responseData field has region that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country\n          let countryRequired = false\n          if (countryRequired || `responseData`.get(`country`)) {\n            pm.test(`'responseData field has country that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lat\n          let latRequired = false\n          if (latRequired || `responseData`.get(`lat`)) {\n            pm.test(`'responseData field has lat that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lon\n          let lonRequired = false\n          if (lonRequired || `responseData`.get(`lon`)) {\n            pm.test(`'responseData field has lon that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: tz_id\n          let tz_idRequired = false\n          if (tz_idRequired || `responseData`.get(`tz_id`)) {\n            pm.test(`'responseData field has tz_id that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime_epoch\n          let localtime_epochRequired = false\n          if (localtime_epochRequired || `responseData`.get(`localtime_epoch`)) {\n            pm.test(`'responseData field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime\n          let localtimeRequired = false\n          if (localtimeRequired || `responseData`.get(`localtime`)) {\n            pm.test(`'responseData field has localtime that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"timezone.json?q={{q}}_GET_d8e8991409","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"London\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCityName123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"astronomy.json?q={{q}}&dt={{dt}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather_api_test/weather/datasets/Astronomy_API.json","feedback":[],"name":"Astronomy API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for astronomy.json?q={{q}}&dt={{dt}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let locationRequired = false\n          if (locationRequired || `responseData`.get(`location`)) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let nameRequired = false\n          if (nameRequired || `responseData.location`.get(`name`)) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let regionRequired = false\n          if (regionRequired || `responseData.location`.get(`region`)) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let countryRequired = false\n          if (countryRequired || `responseData.location`.get(`country`)) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let latRequired = false\n          if (latRequired || `responseData.location`.get(`lat`)) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let lonRequired = false\n          if (lonRequired || `responseData.location`.get(`lon`)) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let tz_idRequired = false\n          if (tz_idRequired || `responseData.location`.get(`tz_id`)) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let localtime_epochRequired = false\n          if (localtime_epochRequired || `responseData.location`.get(`localtime_epoch`)) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let localtimeRequired = false\n          if (localtimeRequired || `responseData.location`.get(`localtime`)) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: astronomy\n          let astronomyRequired = false\n          if (astronomyRequired || `responseData`.get(`astronomy`)) {\n            pm.test(`'responseData field has astronomy that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`astronomy`)) {\n                const value = responseData?.astronomy;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy\n          // subKey: astro\n          let astroRequired = false\n          if (astroRequired || `responseData.astronomy`.get(`astro`)) {\n            pm.test(`'responseData.astronomy field has astro that is of type object'`, function() {\n              let parent = responseData.astronomy;\n              if (pm.expect(parent).to.have.nested.property(`astro`)) {\n                const value = responseData.astronomy?.astro;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: sunrise\n          let sunriseRequired = false\n          if (sunriseRequired || `responseData.astronomy.astro`.get(`sunrise`)) {\n            pm.test(`'responseData.astronomy.astro field has sunrise that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                const value = responseData.astronomy.astro?.sunrise;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: sunset\n          let sunsetRequired = false\n          if (sunsetRequired || `responseData.astronomy.astro`.get(`sunset`)) {\n            pm.test(`'responseData.astronomy.astro field has sunset that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                const value = responseData.astronomy.astro?.sunset;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moonrise\n          let moonriseRequired = false\n          if (moonriseRequired || `responseData.astronomy.astro`.get(`moonrise`)) {\n            pm.test(`'responseData.astronomy.astro field has moonrise that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                const value = responseData.astronomy.astro?.moonrise;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moonset\n          let moonsetRequired = false\n          if (moonsetRequired || `responseData.astronomy.astro`.get(`moonset`)) {\n            pm.test(`'responseData.astronomy.astro field has moonset that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                const value = responseData.astronomy.astro?.moonset;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moon_phase\n          let moon_phaseRequired = false\n          if (moon_phaseRequired || `responseData.astronomy.astro`.get(`moon_phase`)) {\n            pm.test(`'responseData.astronomy.astro field has moon_phase that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                const value = responseData.astronomy.astro?.moon_phase;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moon_illumination\n          let moon_illuminationRequired = false\n          if (moon_illuminationRequired || `responseData.astronomy.astro`.get(`moon_illumination`)) {\n            pm.test(`'responseData.astronomy.astro field has moon_illumination that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                const value = responseData.astronomy.astro?.moon_illumination;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let codeRequired = false\n          if (codeRequired || `responseData`.get(`code`)) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let messageRequired = false\n          if (messageRequired || `responseData`.get(`message`)) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"astronomy.json?q={{q}}&dt={{dt}}_GET_1b9f6b9595","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2023-10-01\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2023-10-02\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidCityName\",\n    \"dt\": \"2023-10-03\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'\"\n  },\n  {\n    \"dt\": \"2023-10-04\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"San Francisco\",\n    \"dt\": \"invalid-date\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.\"\n  },\n  {\n    \"q\": \"Miami\",\n    \"dt\": \"2023-10-05\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Seattle\",\n    \"dt\": \"2023-10-06\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"testFilePath":"/var/tmp/Roost/RoostGPT/weather_api_test/c82ba9c9-d2fe-46b5-82b2-16496c811d80/source/api-spec/postman_collections/weather_api_test/weather/roost_postman_weather_1763709096.json"}}}