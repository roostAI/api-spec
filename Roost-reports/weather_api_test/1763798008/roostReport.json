{"postmanCollection":{"filePaths":["/var/tmp/Roost/RoostGPT/weather_api_test/1763798008/source/api-spec/postman_collections/weather/weather/roost_postman_weather_1763798008.json"]},"headBranch":"roost-1763798008","reportHeadBranch":"roost-report","aiUsage":{"promptTokens":0,"completionTokens":0,"apiCallsToAI":0},"repoPath":"/var/tmp/Roost/RoostGPT/weather_api_test/1763798008/source/api-spec","errorMsg":"","gitPrUrl":"","status":"","statusDetails":"","coverageReportURL":{},"testReportURL":{},"testMetrics":{"filesScanned":1,"totalFiles":1,"totalTestFiles":9,"successfulTests":9,"testWithCompilationErrors":0,"skippedMethods":0,"toBeProcessed":0,"testswithRunTimeErrors":0,"existingTestPresent":0,"notSupported":0,"methodsScanned":9,"methodsSuccess":9},"advancedDetails":{"/Users/iamdm/Downloads/weather.yaml":{"current.json?q={{q}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/Realtime_API.json","feedback":[],"name":"Realtime API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for current.json?q={{q}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: current\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'current')) {\n            pm.test(`'responseData field has current that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`current`)) {\n                const value = responseData?.current;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'last_updated_epoch')) {\n            pm.test(`'responseData.current field has last_updated_epoch that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated_epoch`)) {\n                const value = responseData.current?.last_updated_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'last_updated')) {\n            pm.test(`'responseData.current field has last_updated that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated`)) {\n                const value = responseData.current?.last_updated;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_c\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'temp_c')) {\n            pm.test(`'responseData.current field has temp_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_c`)) {\n                const value = responseData.current?.temp_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_f\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'temp_f')) {\n            pm.test(`'responseData.current field has temp_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_f`)) {\n                const value = responseData.current?.temp_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: is_day\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'is_day')) {\n            pm.test(`'responseData.current field has is_day that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`is_day`)) {\n                const value = responseData.current?.is_day;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: condition\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'condition')) {\n            pm.test(`'responseData.current field has condition that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                const value = responseData.current?.condition;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: text\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'text')) {\n            pm.test(`'responseData.current.condition field has text that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                const value = responseData.current.condition?.text;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: icon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'icon')) {\n            pm.test(`'responseData.current.condition field has icon that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                const value = responseData.current.condition?.icon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'code')) {\n            pm.test(`'responseData.current.condition field has code that is of type number'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData.current.condition?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_mph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_mph')) {\n            pm.test(`'responseData.current field has wind_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_mph`)) {\n                const value = responseData.current?.wind_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_kph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_kph')) {\n            pm.test(`'responseData.current field has wind_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_kph`)) {\n                const value = responseData.current?.wind_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_degree\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_degree')) {\n            pm.test(`'responseData.current field has wind_degree that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_degree`)) {\n                const value = responseData.current?.wind_degree;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_dir\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_dir')) {\n            pm.test(`'responseData.current field has wind_dir that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_dir`)) {\n                const value = responseData.current?.wind_dir;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_mb\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'pressure_mb')) {\n            pm.test(`'responseData.current field has pressure_mb that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_mb`)) {\n                const value = responseData.current?.pressure_mb;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_in\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'pressure_in')) {\n            pm.test(`'responseData.current field has pressure_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_in`)) {\n                const value = responseData.current?.pressure_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_mm\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'precip_mm')) {\n            pm.test(`'responseData.current field has precip_mm that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_mm`)) {\n                const value = responseData.current?.precip_mm;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_in\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'precip_in')) {\n            pm.test(`'responseData.current field has precip_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_in`)) {\n                const value = responseData.current?.precip_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: humidity\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'humidity')) {\n            pm.test(`'responseData.current field has humidity that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`humidity`)) {\n                const value = responseData.current?.humidity;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: cloud\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'cloud')) {\n            pm.test(`'responseData.current field has cloud that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`cloud`)) {\n                const value = responseData.current?.cloud;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_c\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'feelslike_c')) {\n            pm.test(`'responseData.current field has feelslike_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_c`)) {\n                const value = responseData.current?.feelslike_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_f\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'feelslike_f')) {\n            pm.test(`'responseData.current field has feelslike_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_f`)) {\n                const value = responseData.current?.feelslike_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_km\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'vis_km')) {\n            pm.test(`'responseData.current field has vis_km that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_km`)) {\n                const value = responseData.current?.vis_km;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_miles\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'vis_miles')) {\n            pm.test(`'responseData.current field has vis_miles that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_miles`)) {\n                const value = responseData.current?.vis_miles;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: uv\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'uv')) {\n            pm.test(`'responseData.current field has uv that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                const value = responseData.current?.uv;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_mph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'gust_mph')) {\n            pm.test(`'responseData.current field has gust_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_mph`)) {\n                const value = responseData.current?.gust_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_kph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'gust_kph')) {\n            pm.test(`'responseData.current field has gust_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_kph`)) {\n                const value = responseData.current?.gust_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: air_quality\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'air_quality')) {\n            pm.test(`'responseData.current field has air_quality that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`air_quality`)) {\n                const value = responseData.current?.air_quality;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: co\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'co')) {\n            pm.test(`'responseData.current.air_quality field has co that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`co`)) {\n                const value = responseData.current.air_quality?.co;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: no2\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'no2')) {\n            pm.test(`'responseData.current.air_quality field has no2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`no2`)) {\n                const value = responseData.current.air_quality?.no2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: o3\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'o3')) {\n            pm.test(`'responseData.current.air_quality field has o3 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`o3`)) {\n                const value = responseData.current.air_quality?.o3;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: so2\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'so2')) {\n            pm.test(`'responseData.current.air_quality field has so2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`so2`)) {\n                const value = responseData.current.air_quality?.so2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm2_5\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'pm2_5')) {\n            pm.test(`'responseData.current.air_quality field has pm2_5 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm2_5`)) {\n                const value = responseData.current.air_quality?.pm2_5;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm10\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'pm10')) {\n            pm.test(`'responseData.current.air_quality field has pm10 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm10`)) {\n                const value = responseData.current.air_quality?.pm10;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: us-epa-index\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'us-epa-index')) {\n            pm.test(`'responseData.current.air_quality field has us-epa-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`us-epa-index`)) {\n                const value = responseData.current.air_quality?.us - epa - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: gb-defra-index\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'gb-defra-index')) {\n            pm.test(`'responseData.current.air_quality field has gb-defra-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`gb-defra-index`)) {\n                const value = responseData.current.air_quality?.gb - defra - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"current.json?q={{q}}&lang={{lang}}_GET_11ef9fbb39","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"lang\": \"es\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Chicago\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"InvalidLocation1\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'\"\n  },\n  {\n    \"lang\": \"fr\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"lang\": \"invalid_lang\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1005: API request url is invalid.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"InvalidLocation2\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'\"\n  },\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/Forecast_API.json","feedback":[],"name":"Forecast API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: current\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'current')) {\n            pm.test(`'responseData field has current that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`current`)) {\n                const value = responseData?.current;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'last_updated_epoch')) {\n            pm.test(`'responseData.current field has last_updated_epoch that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated_epoch`)) {\n                const value = responseData.current?.last_updated_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'last_updated')) {\n            pm.test(`'responseData.current field has last_updated that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated`)) {\n                const value = responseData.current?.last_updated;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_c\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'temp_c')) {\n            pm.test(`'responseData.current field has temp_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_c`)) {\n                const value = responseData.current?.temp_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_f\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'temp_f')) {\n            pm.test(`'responseData.current field has temp_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_f`)) {\n                const value = responseData.current?.temp_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: is_day\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'is_day')) {\n            pm.test(`'responseData.current field has is_day that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`is_day`)) {\n                const value = responseData.current?.is_day;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: condition\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'condition')) {\n            pm.test(`'responseData.current field has condition that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                const value = responseData.current?.condition;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: text\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'text')) {\n            pm.test(`'responseData.current.condition field has text that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                const value = responseData.current.condition?.text;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: icon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'icon')) {\n            pm.test(`'responseData.current.condition field has icon that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                const value = responseData.current.condition?.icon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'code')) {\n            pm.test(`'responseData.current.condition field has code that is of type number'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData.current.condition?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_mph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_mph')) {\n            pm.test(`'responseData.current field has wind_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_mph`)) {\n                const value = responseData.current?.wind_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_kph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_kph')) {\n            pm.test(`'responseData.current field has wind_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_kph`)) {\n                const value = responseData.current?.wind_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_degree\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_degree')) {\n            pm.test(`'responseData.current field has wind_degree that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_degree`)) {\n                const value = responseData.current?.wind_degree;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_dir\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_dir')) {\n            pm.test(`'responseData.current field has wind_dir that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_dir`)) {\n                const value = responseData.current?.wind_dir;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_mb\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'pressure_mb')) {\n            pm.test(`'responseData.current field has pressure_mb that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_mb`)) {\n                const value = responseData.current?.pressure_mb;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_in\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'pressure_in')) {\n            pm.test(`'responseData.current field has pressure_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_in`)) {\n                const value = responseData.current?.pressure_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_mm\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'precip_mm')) {\n            pm.test(`'responseData.current field has precip_mm that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_mm`)) {\n                const value = responseData.current?.precip_mm;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_in\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'precip_in')) {\n            pm.test(`'responseData.current field has precip_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_in`)) {\n                const value = responseData.current?.precip_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: humidity\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'humidity')) {\n            pm.test(`'responseData.current field has humidity that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`humidity`)) {\n                const value = responseData.current?.humidity;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: cloud\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'cloud')) {\n            pm.test(`'responseData.current field has cloud that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`cloud`)) {\n                const value = responseData.current?.cloud;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_c\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'feelslike_c')) {\n            pm.test(`'responseData.current field has feelslike_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_c`)) {\n                const value = responseData.current?.feelslike_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_f\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'feelslike_f')) {\n            pm.test(`'responseData.current field has feelslike_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_f`)) {\n                const value = responseData.current?.feelslike_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_km\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'vis_km')) {\n            pm.test(`'responseData.current field has vis_km that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_km`)) {\n                const value = responseData.current?.vis_km;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_miles\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'vis_miles')) {\n            pm.test(`'responseData.current field has vis_miles that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_miles`)) {\n                const value = responseData.current?.vis_miles;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: uv\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'uv')) {\n            pm.test(`'responseData.current field has uv that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                const value = responseData.current?.uv;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_mph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'gust_mph')) {\n            pm.test(`'responseData.current field has gust_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_mph`)) {\n                const value = responseData.current?.gust_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_kph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'gust_kph')) {\n            pm.test(`'responseData.current field has gust_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_kph`)) {\n                const value = responseData.current?.gust_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: air_quality\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'air_quality')) {\n            pm.test(`'responseData.current field has air_quality that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`air_quality`)) {\n                const value = responseData.current?.air_quality;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: co\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'co')) {\n            pm.test(`'responseData.current.air_quality field has co that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`co`)) {\n                const value = responseData.current.air_quality?.co;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: no2\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'no2')) {\n            pm.test(`'responseData.current.air_quality field has no2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`no2`)) {\n                const value = responseData.current.air_quality?.no2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: o3\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'o3')) {\n            pm.test(`'responseData.current.air_quality field has o3 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`o3`)) {\n                const value = responseData.current.air_quality?.o3;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: so2\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'so2')) {\n            pm.test(`'responseData.current.air_quality field has so2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`so2`)) {\n                const value = responseData.current.air_quality?.so2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm2_5\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'pm2_5')) {\n            pm.test(`'responseData.current.air_quality field has pm2_5 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm2_5`)) {\n                const value = responseData.current.air_quality?.pm2_5;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm10\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'pm10')) {\n            pm.test(`'responseData.current.air_quality field has pm10 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm10`)) {\n                const value = responseData.current.air_quality?.pm10;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: us-epa-index\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'us-epa-index')) {\n            pm.test(`'responseData.current.air_quality field has us-epa-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`us-epa-index`)) {\n                const value = responseData.current.air_quality?.us - epa - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: gb-defra-index\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'gb-defra-index')) {\n            pm.test(`'responseData.current.air_quality field has gb-defra-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`gb-defra-index`)) {\n                const value = responseData.current.air_quality?.gb - defra - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'forecast')) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: alerts\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'alerts')) {\n            pm.test(`'responseData field has alerts that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`alerts`)) {\n                const value = responseData?.alerts;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.alerts` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.alerts`)) {\n              const value = responseData?.responseData.alerts;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.alerts.alert field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.alerts).to.have.nested.property(`alert`)) {\n            let alertArray = ld.get(responseData.alerts, `alert`, []);\n            if (Array.isArray(alertArray)) {\n              for (let alert_it = 0; alert_it < alertArray.length; alert_it++) {\n                let iterator = alert_it;\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'headline' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.headline;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'msgtype' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.msgtype;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'severity' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.severity;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'urgency' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.urgency;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'areas' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.areas;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'category' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.category;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'certainty' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.certainty;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'event' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.event;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'note' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.note;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'effective' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.effective;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('alertArray[${iterator}] format to be date-time', function() {\n                    const value = ld.get(responseData, `alertArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                    }\n                  })\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'expires' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.expires;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('alertArray[${iterator}] format to be date-time', function() {\n                    const value = ld.get(responseData, `alertArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                    }\n                  })\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'desc' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.desc;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'instruction' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.instruction;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}}_GET_b96c60d479","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"days\": 5,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"days\": 3,\n    \"dt\": \"2023-10-01\",\n    \"unixdt\": 1696156800,\n    \"hour\": 14,\n    \"lang\": \"en\",\n    \"alerts\": \"true\",\n    \"aqi\": \"yes\",\n    \"tp\": 25,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"days\": 7,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation123\",\n    \"days\": 2,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"days\": 20,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"days\": 3,\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"London\",\n    \"days\": 4,\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"future.json?q={{q}}&dt={{dt}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/Future_API.json","feedback":[],"name":"Future API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for future.json?q={{q}}&dt={{dt}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'forecast')) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"future.json?q={{q}}&dt={{dt}}&lang={{lang}}_GET_4ece0fa346","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2022-07-22\",\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"dt\": \"2023-05-15\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"London\",\n    \"lang\": \"fr\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"dt\": \"2022-07-22\",\n    \"lang\": \"en\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCityName\",\n    \"dt\": \"not-a-date\",\n    \"lang\": \"xx\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"UnknownPlace\",\n    \"lang\": \"en\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/History_API.json","feedback":[],"name":"History API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'forecast')) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}}_GET_e2512939af","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2023-10-15\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2023-10-16\",\n    \"unixdt\": 1697404800,\n    \"end_dt\": \"2023-10-17\",\n    \"unixend_dt\": 1697491200,\n    \"hour\": 10,\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"dt\": \"2023-10-18\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation!\",\n    \"dt\": \"2023-10-19\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'\"\n  },\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2023-10-20\",\n    \"unixdt\": \"invalid_date_format\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.\"\n  },\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2023-10-21\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2023-10-22\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/Marine_Weather_API.json","feedback":[],"name":"Marine Weather API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'forecast')) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test(`'Response has the `\n          responseData.forecast` field of type array'`,\n          function() {\n            if (pm.expect(item).to.have.nested.property(`responseData.forecast`)) {\n              const value = responseData?.responseData.forecast;\n\n              if (value !== null && value !== undefined) {\n                pm.expect(Array.isArray(value)).to.equal(true);\n              }\n\n            }\n          })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'sig_ht_mt' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.sig_ht_mt;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_ht_mt' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_ht_mt;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_ht_ft' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_ht_ft;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_dir' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_dir_16_point' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_dir_16_point;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_period_secs' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_period_secs;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}_GET_3b9375ed0c","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"days\": 5,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"days\": 7,\n    \"dt\": \"2023-10-10\",\n    \"unixdt\": 1696953600,\n    \"hour\": 14,\n    \"lang\": \"en\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"days\": 3,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Invalid_City\",\n    \"days\": 2,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'<br />Error code 1005: API request url is invalid.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"London\",\n    \"days\": 15,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1005: API request url is invalid.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"lang\": \"jp\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Berlin\",\n    \"days\": 4,\n    \"unixdt\": \"invalid_unix_time\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Sydney\",\n    \"days\": 3,\n    \"hour\": 25,\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Mumbai\",\n    \"days\": 1,\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Rio de Janeiro\",\n    \"dt\": \"invalid_date_format\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9999: Internal application error.\"\n  }\n]"}},"search.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/Search_Autocomplete_API.json","feedback":[],"name":"Search/Autocomplete API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for search.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: id\n                let requiredField = false\n                if (requiredField || ld.get(item, 'id')) {\n                  pm.test(`'item field has id that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`id`)) {\n                      const value = item?.id;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: name\n                let requiredField = false\n                if (requiredField || ld.get(item, 'name')) {\n                  pm.test(`'item field has name that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`name`)) {\n                      const value = item?.name;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: region\n                let requiredField = false\n                if (requiredField || ld.get(item, 'region')) {\n                  pm.test(`'item field has region that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`region`)) {\n                      const value = item?.region;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: country\n                let requiredField = false\n                if (requiredField || ld.get(item, 'country')) {\n                  pm.test(`'item field has country that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`country`)) {\n                      const value = item?.country;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: lat\n                let requiredField = false\n                if (requiredField || ld.get(item, 'lat')) {\n                  pm.test(`'item field has lat that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                      const value = item?.lat;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: lon\n                let requiredField = false\n                if (requiredField || ld.get(item, 'lon')) {\n                  pm.test(`'item field has lon that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                      const value = item?.lon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: url\n                let requiredField = false\n                if (requiredField || ld.get(item, 'url')) {\n                  pm.test(`'item field has url that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`url`)) {\n                      const value = item?.url;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"search.json?q={{q}}_GET_d9f22c6255","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"London\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCityName123\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Berlin\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"ip.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/IP_Lookup_API.json","feedback":[],"name":"IP Lookup API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for ip.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: ip\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'ip')) {\n            pm.test(`'responseData field has ip that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`ip`)) {\n                const value = responseData?.ip;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: type\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'type')) {\n            pm.test(`'responseData field has type that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`type`)) {\n                const value = responseData?.type;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: continent_code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'continent_code')) {\n            pm.test(`'responseData field has continent_code that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`continent_code`)) {\n                const value = responseData?.continent_code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: continent_name\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'continent_name')) {\n            pm.test(`'responseData field has continent_name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`continent_name`)) {\n                const value = responseData?.continent_name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country_code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'country_code')) {\n            pm.test(`'responseData field has country_code that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country_code`)) {\n                const value = responseData?.country_code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country_name\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'country_name')) {\n            pm.test(`'responseData field has country_name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country_name`)) {\n                const value = responseData?.country_name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: is_eu\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'is_eu')) {\n            pm.test(`'responseData field has is_eu that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`is_eu`)) {\n                const value = responseData?.is_eu;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: geoname_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'geoname_id')) {\n            pm.test(`'responseData field has geoname_id that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`geoname_id`)) {\n                const value = responseData?.geoname_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: city\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'city')) {\n            pm.test(`'responseData field has city that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`city`)) {\n                const value = responseData?.city;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'region')) {\n            pm.test(`'responseData field has region that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'lat')) {\n            pm.test(`'responseData field has lat that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'lon')) {\n            pm.test(`'responseData field has lon that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'tz_id')) {\n            pm.test(`'responseData field has tz_id that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'localtime_epoch')) {\n            pm.test(`'responseData field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'localtime')) {\n            pm.test(`'responseData field has localtime that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"ip.json?q={{q}}_GET_d0aefd50f4","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 200,\n    \"scenario\": \"Success\"\n  },\n  {\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidLocation\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'\"\n  },\n  {\n    \"q\": \"123456\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'\"\n  },\n  {\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"timezone.json?q={{q}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/Time_Zone_API.json","feedback":[],"name":"Time Zone API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for timezone.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'name')) {\n            pm.test(`'responseData field has name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'region')) {\n            pm.test(`'responseData field has region that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'country')) {\n            pm.test(`'responseData field has country that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'lat')) {\n            pm.test(`'responseData field has lat that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'lon')) {\n            pm.test(`'responseData field has lon that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'tz_id')) {\n            pm.test(`'responseData field has tz_id that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'localtime_epoch')) {\n            pm.test(`'responseData field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'localtime')) {\n            pm.test(`'responseData field has localtime that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"timezone.json?q={{q}}_GET_d8e8991409","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Atlantis\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1006: No location found matching parameter 'q'<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidURL\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1005: API request url is invalid.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"ValidCityButKeyMissing\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"ValidCityButKeyInvalid\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"ValidCityButKeyDisabled\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  },\n  {\n    \"q\": \"ValidCityButQuotaExceeded\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.\"\n  }\n]"}},"astronomy.json?q={{q}}&dt={{dt}}":{"GET":{"status":"successfully_generated","description":"Tests generated successfully","jsonFilePath":"postman_collections/weather/weather/datasets/Astronomy_API.json","feedback":[],"name":"Astronomy API","testscript":"// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for astronomy.json?q={{q}}&dt={{dt}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: astronomy\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'astronomy')) {\n            pm.test(`'responseData field has astronomy that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`astronomy`)) {\n                const value = responseData?.astronomy;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy\n          // subKey: astro\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy, 'astro')) {\n            pm.test(`'responseData.astronomy field has astro that is of type object'`, function() {\n              let parent = responseData.astronomy;\n              if (pm.expect(parent).to.have.nested.property(`astro`)) {\n                const value = responseData.astronomy?.astro;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: sunrise\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'sunrise')) {\n            pm.test(`'responseData.astronomy.astro field has sunrise that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                const value = responseData.astronomy.astro?.sunrise;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: sunset\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'sunset')) {\n            pm.test(`'responseData.astronomy.astro field has sunset that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                const value = responseData.astronomy.astro?.sunset;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moonrise\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'moonrise')) {\n            pm.test(`'responseData.astronomy.astro field has moonrise that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                const value = responseData.astronomy.astro?.moonrise;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moonset\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'moonset')) {\n            pm.test(`'responseData.astronomy.astro field has moonset that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                const value = responseData.astronomy.astro?.moonset;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moon_phase\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'moon_phase')) {\n            pm.test(`'responseData.astronomy.astro field has moon_phase that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                const value = responseData.astronomy.astro?.moon_phase;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moon_illumination\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'moon_illumination')) {\n            pm.test(`'responseData.astronomy.astro field has moon_illumination that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                const value = responseData.astronomy.astro?.moon_illumination;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}","bodyHash":"astronomy.json?q={{q}}&dt={{dt}}_GET_1b9f6b9595","jsonData":"[\n  {\n    \"q\": \"New York\",\n    \"dt\": \"2023-10-01\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"Los Angeles\",\n    \"dt\": \"2023-09-15\",\n    \"statusCode\": 200,\n    \"scenario\": \"Ok\"\n  },\n  {\n    \"q\": \"\",\n    \"dt\": \"2023-08-20\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"InvalidCity123\",\n    \"dt\": \"2023-07-10\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"Tokyo\",\n    \"statusCode\": 400,\n    \"scenario\": \"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\"\n  },\n  {\n    \"q\": \"London\",\n    \"dt\": \"2023-10-10\",\n    \"statusCode\": 401,\n    \"scenario\": \"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\"\n  },\n  {\n    \"q\": \"Paris\",\n    \"dt\": \"2023-05-05\",\n    \"statusCode\": 403,\n    \"scenario\": \"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\"\n  }\n]"}},"testFilePath":"/var/tmp/Roost/RoostGPT/weather_api_test/1763798008/source/api-spec/postman_collections/weather/weather/roost_postman_weather_1763798008.json"}}}