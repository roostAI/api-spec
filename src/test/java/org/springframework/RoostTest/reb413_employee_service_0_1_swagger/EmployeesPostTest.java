// ********RoostGPT********
/*
Test generated by RoostGPT for test rest-assured-20-nov_clone using AI Type Claude AI and AI Model claude-sonnet-4-5-20250929

Test generated for /employees_post for http method type POST in rest-assured framework

RoostTestHash=98aac2289d

[
  {
    "ScenarioID": "1",
    "TestName": "testValidEmployeeCreationReturns201",
    "Description": "Test creating a new employee with all valid required fields",
    "Execution": {
      "Arrange": "Prepare a valid employee object with all required fields (id, name, email, department, position)",
      "Act": "Send POST request to /employees with valid employee data in request body",
      "Assert": "Check for 201 status code and verify employee created response"
    },
    "Validation": "Ensures API successfully creates an employee with valid input data"
  },
  {
    "ScenarioID": "2",
    "TestName": "testValidEmployeeWithAllOptionalFields",
    "Description": "Test creating employee with all required and optional fields populated",
    "Execution": {
      "Arrange": "Prepare employee object with required fields plus optional fields (phone, address, hire_date, salary)",
      "Act": "Send POST request to /employees with complete employee data",
      "Assert": "Check for 201 status code confirming successful creation"
    },
    "Validation": "Ensures API accepts and processes all optional fields correctly"
  },
  {
    "ScenarioID": "3",
    "TestName": "testDuplicateEmployeeReturns409",
    "Description": "Test creating an employee that already exists in the system",
    "Execution": {
      "Arrange": "Prepare employee data with an ID or email that already exists in the system",
      "Act": "Send POST request to /employees with duplicate employee information",
      "Assert": "Check for 409 status code and appropriate error message about existing employee"
    },
    "Validation": "Ensures API prevents duplicate employee creation and returns conflict error"
  },
  {
    "ScenarioID": "4",
    "TestName": "testEmptyRequestBodyReturns400",
    "Description": "Test sending request with empty body",
    "Execution": {
      "Arrange": "Prepare an empty request body",
      "Act": "Send POST request to /employees with empty body",
      "Assert": "Check for 400 status code and error message indicating invalid input"
    },
    "Validation": "Ensures API validates presence of request body and rejects empty requests"
  },
  {
    "ScenarioID": "5",
    "TestName": "testNullRequestBodyReturns400",
    "Description": "Test sending request with null body",
    "Execution": {
      "Arrange": "Prepare a null request body",
      "Act": "Send POST request to /employees with null body",
      "Assert": "Check for 400 status code indicating invalid input"
    },
    "Validation": "Ensures API handles null body gracefully and returns appropriate error"
  },
  {
    "ScenarioID": "6",
    "TestName": "testMissingRequiredFieldNameReturns400",
    "Description": "Test creating employee without required name field",
    "Execution": {
      "Arrange": "Prepare employee object missing the name field",
      "Act": "Send POST request to /employees with incomplete data",
      "Assert": "Check for 400 status code and error message about missing required field"
    },
    "Validation": "Ensures API validates required name field is present"
  },
  {
    "ScenarioID": "7",
    "TestName": "testMissingRequiredFieldEmailReturns400",
    "Description": "Test creating employee without required email field",
    "Execution": {
      "Arrange": "Prepare employee object missing the email field",
      "Act": "Send POST request to /employees with incomplete data",
      "Assert": "Check for 400 status code and error message about missing email"
    },
    "Validation": "Ensures API validates required email field is present"
  },
  {
    "ScenarioID": "8",
    "TestName": "testInvalidEmailFormatReturns400",
    "Description": "Test creating employee with malformed email address",
    "Execution": {
      "Arrange": "Prepare employee object with invalid email format (e.g., 'notanemail', 'test@', '@domain.com')",
      "Act": "Send POST request to /employees with invalid email",
      "Assert": "Check for 400 status code and error message about invalid email format"
    },
    "Validation": "Ensures API validates email format and rejects invalid emails"
  },
  {
    "ScenarioID": "9",
    "TestName": "testInvalidDataTypeForIdReturns400",
    "Description": "Test creating employee with wrong data type for ID field",
    "Execution": {
      "Arrange": "Prepare employee object with string value for numeric ID field or vice versa",
      "Act": "Send POST request to /employees with incorrect data type",
      "Assert": "Check for 400 status code and error message about invalid data type"
    },
    "Validation": "Ensures API validates data types for all fields"
  },
  {
    "ScenarioID": "10",
    "TestName": "testNullValueForRequiredFieldReturns400",
    "Description": "Test creating employee with null value in required field",
    "Execution": {
      "Arrange": "Prepare employee object with null value for required field like name or email",
      "Act": "Send POST request to /employees with null required field",
      "Assert": "Check for 400 status code and error message about null value in required field"
    },
    "Validation": "Ensures API rejects null values in required fields"
  },
  {
    "ScenarioID": "11",
    "TestName": "testEmptyStringForRequiredFieldReturns400",
    "Description": "Test creating employee with empty string in required field",
    "Execution": {
      "Arrange": "Prepare employee object with empty string for name or email field",
      "Act": "Send POST request to /employees with empty string in required field",
      "Assert": "Check for 400 status code and error message about invalid input"
    },
    "Validation": "Ensures API validates that required fields contain actual data, not just empty strings"
  },
  {
    "ScenarioID": "12",
    "TestName": "testWhitespaceOnlyStringForRequiredFieldReturns400",
    "Description": "Test creating employee with whitespace-only string in required field",
    "Execution": {
      "Arrange": "Prepare employee object with whitespace-only string for name field (e.g., '   ')",
      "Act": "Send POST request to /employees with whitespace-only required field",
      "Assert": "Check for 400 status code and error message about invalid input"
    },
    "Validation": "Ensures API trims and validates string fields properly"
  },
  {
    "ScenarioID": "13",
    "TestName": "testExcessivelyLongNameReturns400",
    "Description": "Test creating employee with name exceeding maximum length",
    "Execution": {
      "Arrange": "Prepare employee object with name field containing 1000+ characters",
      "Act": "Send POST request to /employees with excessively long name",
      "Assert": "Check for 400 status code and error message about field length violation"
    },
    "Validation": "Ensures API enforces maximum length constraints on string fields"
  },
  {
    "ScenarioID": "14",
    "TestName": "testSpecialCharactersInNameField",
    "Description": "Test creating employee with special characters in name",
    "Execution": {
      "Arrange": "Prepare employee object with special characters in name field (e.g., '@#$%^&*()')",
      "Act": "Send POST request to /employees with special characters",
      "Assert": "Check for 400 status code if special characters are not allowed, or 201 if they are valid"
    },
    "Validation": "Ensures API handles special characters according to business rules"
  },
  {
    "ScenarioID": "15",
    "TestName": "testSQLInjectionInNameFieldReturns400",
    "Description": "Test creating employee with SQL injection attempt in name field",
    "Execution": {
      "Arrange": "Prepare employee object with SQL injection string in name (e.g., 'Robert'; DROP TABLE employees;--')",
      "Act": "Send POST request to /employees with malicious SQL string",
      "Assert": "Check for 400 status code and verify no SQL execution occurred"
    },
    "Validation": "Ensures API sanitizes input and prevents SQL injection attacks"
  },
  {
    "ScenarioID": "16",
    "TestName": "testXSSAttemptInNameFieldReturns400",
    "Description": "Test creating employee with XSS script in name field",
    "Execution": {
      "Arrange": "Prepare employee object with XSS payload in name (e.g., '<script>alert(1)</script>')",
      "Act": "Send POST request to /employees with XSS payload",
      "Assert": "Check for 400 status code or verify script is properly escaped/sanitized"
    },
    "Validation": "Ensures API prevents XSS attacks by sanitizing input"
  },
  {
    "ScenarioID": "17",
    "TestName": "testInvalidJSONFormatReturns400",
    "Description": "Test sending malformed JSON in request body",
    "Execution": {
      "Arrange": "Prepare malformed JSON string with syntax errors (missing quotes, brackets, commas)",
      "Act": "Send POST request to /employees with malformed JSON",
      "Assert": "Check for 400 status code and error message about JSON parsing error"
    },
    "Validation": "Ensures API validates JSON format and returns appropriate error for malformed requests"
  },
  {
    "ScenarioID": "18",
    "TestName": "testUnexpectedAdditionalFieldsInBody",
    "Description": "Test creating employee with extra fields not defined in schema",
    "Execution": {
      "Arrange": "Prepare employee object with valid fields plus unexpected additional fields",
      "Act": "Send POST request to /employees with extra fields",
      "Assert": "Check for 201 status (if extra fields ignored) or 400 status (if strict validation)"
    },
    "Validation": "Ensures API handles unexpected fields according to schema validation rules"
  },
  {
    "ScenarioID": "19",
    "TestName": "testNegativeValueForIdReturns400",
    "Description": "Test creating employee with negative ID value",
    "Execution": {
      "Arrange": "Prepare employee object with negative number for ID field",
      "Act": "Send POST request to /employees with negative ID",
      "Assert": "Check for 400 status code and error message about invalid ID value"
    },
    "Validation": "Ensures API validates numeric field constraints and rejects negative values where inappropriate"
  },
  {
    "ScenarioID": "20",
    "TestName": "testZeroValueForIdReturns400",
    "Description": "Test creating employee with zero as ID value",
    "Execution": {
      "Arrange": "Prepare employee object with ID value of 0",
      "Act": "Send POST request to /employees with zero ID",
      "Assert": "Check for 400 status code if zero is invalid, or 201 if allowed"
    },
    "Validation": "Ensures API validates ID field according to business rules for zero values"
  },
  {
    "ScenarioID": "21",
    "TestName": "testInvalidDateFormatReturns400",
    "Description": "Test creating employee with invalid date format for hire_date",
    "Execution": {
      "Arrange": "Prepare employee object with invalid date format (e.g., '32/13/2023', 'not-a-date')",
      "Act": "Send POST request to /employees with invalid date",
      "Assert": "Check for 400 status code and error message about invalid date format"
    },
    "Validation": "Ensures API validates date fields and rejects invalid formats"
  },
  {
    "ScenarioID": "22",
    "TestName": "testFutureDateForHireDateReturns400",
    "Description": "Test creating employee with future date for hire_date",
    "Execution": {
      "Arrange": "Prepare employee object with hire_date set to a future date",
      "Act": "Send POST request to /employees with future hire date",
      "Assert": "Check for 400 status code if future dates are not allowed"
    },
    "Validation": "Ensures API validates business logic for date fields"
  },
  {
    "ScenarioID": "23",
    "TestName": "testNegativeSalaryValueReturns400",
    "Description": "Test creating employee with negative salary value",
    "Execution": {
      "Arrange": "Prepare employee object with negative number for salary field",
      "Act": "Send POST request to /employees with negative salary",
      "Assert": "Check for 400 status code and error message about invalid salary"
    },
    "Validation": "Ensures API validates numeric constraints for salary field"
  },
  {
    "ScenarioID": "24",
    "TestName": "testInvalidPhoneNumberFormatReturns400",
    "Description": "Test creating employee with invalid phone number format",
    "Execution": {
      "Arrange": "Prepare employee object with invalid phone format (e.g., 'abc-def-ghij', '123')",
      "Act": "Send POST request to /employees with invalid phone number",
      "Assert": "Check for 400 status code and error message about invalid phone format"
    },
    "Validation": "Ensures API validates phone number format according to defined pattern"
  },
  {
    "ScenarioID": "25",
    "TestName": "testInvalidDepartmentEnumValueReturns400",
    "Description": "Test creating employee with department value not in allowed enum",
    "Execution": {
      "Arrange": "Prepare employee object with department value not in predefined list (e.g., 'InvalidDept')",
      "Act": "Send POST request to /employees with invalid department enum",
      "Assert": "Check for 400 status code and error message about invalid department value"
    },
    "Validation": "Ensures API validates enum fields and rejects values outside allowed set"
  },
  {
    "ScenarioID": "26",
    "TestName": "testCaseSensitivityForEnumValues",
    "Description": "Test creating employee with different case for enum values",
    "Execution": {
      "Arrange": "Prepare employee object with enum value in different case (e.g., 'ENGINEERING' vs 'engineering')",
      "Act": "Send POST request to /employees with different case enum value",
      "Assert": "Check for 400 status if case-sensitive, or 201 if case-insensitive"
    },
    "Validation": "Ensures API handles enum case sensitivity correctly"
  },
  {
    "ScenarioID": "27",
    "TestName": "testUnicodeCharactersInNameField",
    "Description": "Test creating employee with Unicode characters in name",
    "Execution": {
      "Arrange": "Prepare employee object with Unicode characters in name (e.g., Chinese, Arabic, emoji)",
      "Act": "Send POST request to /employees with Unicode name",
      "Assert": "Check for 201 status if Unicode is supported, or 400 if not allowed"
    },
    "Validation": "Ensures API handles international characters appropriately"
  },
  {
    "ScenarioID": "28",
    "TestName": "testVeryLargeNumericValueForSalary",
    "Description": "Test creating employee with extremely large salary value",
    "Execution": {
      "Arrange": "Prepare employee object with very large number for salary (e.g., 999999999999)",
      "Act": "Send POST request to /employees with large salary value",
      "Assert": "Check for 400 status if value exceeds maximum, or 201 if within range"
    },
    "Validation": "Ensures API validates maximum numeric value constraints"
  },
  {
    "ScenarioID": "29",
    "TestName": "testDecimalValueForIntegerFieldReturns400",
    "Description": "Test creating employee with decimal value for integer field",
    "Execution": {
      "Arrange": "Prepare employee object with decimal value for ID field (e.g., 123.45)",
      "Act": "Send POST request to /employees with decimal in integer field",
      "Assert": "Check for 400 status code and error message about invalid data type"
    },
    "Validation": "Ensures API enforces integer type constraints"
  },
  {
    "ScenarioID": "30",
    "TestName": "testBooleanValueForStringFieldReturns400",
    "Description": "Test creating employee with boolean value for string field",
    "Execution": {
      "Arrange": "Prepare employee object with boolean value for name field (e.g., true/false)",
      "Act": "Send POST request to /employees with wrong data type",
      "Assert": "Check for 400 status code and error message about type mismatch"
    },
    "Validation": "Ensures API validates data types strictly"
  },
  {
    "ScenarioID": "31",
    "TestName": "testArrayValueForStringFieldReturns400",
    "Description": "Test creating employee with array value for string field",
    "Execution": {
      "Arrange": "Prepare employee object with array value for name field (e.g., ['John', 'Doe'])",
      "Act": "Send POST request to /employees with array in string field",
      "Assert": "Check for 400 status code and error message about invalid data type"
    },
    "Validation": "Ensures API rejects incorrect data structures"
  },
  {
    "ScenarioID": "32",
    "TestName": "testObjectValueForStringFieldReturns400",
    "Description": "Test creating employee with object value for string field",
    "Execution": {
      "Arrange": "Prepare employee object with nested object for name field",
      "Act": "Send POST request to /employees with object in string field",
      "Assert": "Check for 400 status code and error message about invalid data type"
    },
    "Validation": "Ensures API validates field types and rejects nested objects where not expected"
  },
  {
    "ScenarioID": "33",
    "TestName": "testContentTypeApplicationXMLReturns400",
    "Description": "Test sending request with unsupported Content-Type header",
    "Execution": {
      "Arrange": "Prepare valid employee data but set Content-Type header to application/xml",
      "Act": "Send POST request to /employees with XML Content-Type",
      "Assert": "Check for 400 or 415 status code indicating unsupported media type"
    },
    "Validation": "Ensures API validates Content-Type header and rejects unsupported formats"
  },
  {
    "ScenarioID": "34",
    "TestName": "testMissingContentTypeHeader",
    "Description": "Test sending request without Content-Type header",
    "Execution": {
      "Arrange": "Prepare valid employee data but omit Content-Type header",
      "Act": "Send POST request to /employees without Content-Type header",
      "Assert": "Check for 400 status code or verify default handling"
    },
    "Validation": "Ensures API handles missing Content-Type header appropriately"
  },
  {
    "ScenarioID": "35",
    "TestName": "testMinimumValidEmployeeData",
    "Description": "Test creating employee with only minimum required fields",
    "Execution": {
      "Arrange": "Prepare employee object with only mandatory fields, no optional fields",
      "Act": "Send POST request to /employees with minimal valid data",
      "Assert": "Check for 201 status code confirming successful creation"
    },
    "Validation": "Ensures API accepts requests with only required fields"
  },
  {
    "ScenarioID": "36",
    "TestName": "testLeadingTrailingWhitespaceInFields",
    "Description": "Test creating employee with leading and trailing whitespace in string fields",
    "Execution": {
      "Arrange": "Prepare employee object with whitespace around string values (e.g., '  John Doe  ')",
      "Act": "Send POST request to /employees with whitespace-padded fields",
      "Assert": "Check for 201 status and verify whitespace is trimmed or preserved per business rules"
    },
    "Validation": "Ensures API handles whitespace in string fields consistently"
  },
  {
    "ScenarioID": "37",
    "TestName": "testDuplicateKeysInJSONBody",
    "Description": "Test sending JSON with duplicate keys",
    "Execution": {
      "Arrange": "Prepare JSON body with duplicate keys (e.g., two 'name' fields with different values)",
      "Act": "Send POST request to /employees with duplicate keys",
      "Assert": "Check for 400 status code or verify which value is used"
    },
    "Validation": "Ensures API handles duplicate JSON keys appropriately"
  },
  {
    "ScenarioID": "38",
    "TestName": "testMaxBoundaryValueForNumericFields",
    "Description": "Test creating employee with maximum allowed values for numeric fields",
    "Execution": {
      "Arrange": "Prepare employee object with maximum boundary values for numeric fields",
      "Act": "Send POST request to /employees with max boundary values",
      "Assert": "Check for 201 status code confirming values at boundary are accepted"
    },
    "Validation": "Ensures API accepts maximum boundary values correctly"
  },
  {
    "ScenarioID": "39",
    "TestName": "testMinBoundaryValueForNumericFields",
    "Description": "Test creating employee with minimum allowed values for numeric fields",
    "Execution": {
      "Arrange": "Prepare employee object with minimum boundary values for numeric fields",
      "Act": "Send POST request to /employees with min boundary values",
      "Assert": "Check for 201 status code confirming values at boundary are accepted"
    },
    "Validation": "Ensures API accepts minimum boundary values correctly"
  },
  {
    "ScenarioID": "40",
    "TestName": "testNullValuesInOptionalFields",
    "Description": "Test creating employee with null values in optional fields",
    "Execution": {
      "Arrange": "Prepare employee object with required fields populated and optional fields set to null",
      "Act": "Send POST request to /employees with null optional fields",
      "Assert": "Check for 201 status code confirming null optional fields are accepted"
    },
    "Validation": "Ensures API handles null values in optional fields correctly"
  }
]

*/

// ********RoostGPT********
package org.springframework.RoostTest.reb413_employee_service_0_1_swagger;

import org.springframework.RoostTest.reb413_employee_service_0_1_swagger.auth.UnifiedAuthHandler;
import org.springframework.RoostTest.reb413_employee_service_0_1_swagger.utils.ResponseValidator;
import org.springframework.RoostTest.reb413_employee_service_0_1_swagger.utils.SchemaModels.ResponseSchema;
import org.springframework.RoostTest.reb413_employee_service_0_1_swagger.utils.SchemaModels.FieldConstraint;
import org.springframework.RoostTest.reb413_employee_service_0_1_swagger.utils.SchemaModels.NumericConstraint;
import org.springframework.RoostTest.reb413_employee_service_0_1_swagger.utils.SchemaModels.StringConstraint;
import org.springframework.RoostTest.reb413_employee_service_0_1_swagger.utils.SchemaModels.ArrayConstraint;
import io.restassured.RestAssured;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import io.restassured.http.ContentType;
import static io.restassured.RestAssured.given;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.AfterAll;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.File;
import java.io.IOException;
import java.util.*;

public class EmployeesPostTest {

	private static final Logger logger = LoggerFactory.getLogger(EmployeesPostTest.class);

	private static UnifiedAuthHandler authHandler;

	private static ResponseValidator responseValidator;

	private static ObjectMapper objectMapper;

	private static final String BASE_URI = "https://virtserver.swaggerhub.com/061REB413/employee-service/0.1";

	private static final String ENDPOINT = "/employees";

	private static final String HTTP_METHOD = "post";

	private static final String TEST_DATA_FILE = "src/test/java/org/springframework/RoostTest/reb413_employee_service_0_1_swagger/datasets/employeesPostTest.json";

	private static List<String> failedTests = new ArrayList<>();

	private static int totalTests = 0;

	private static int passedTests = 0;

	private static int failedTestsCount = 0;

	@BeforeAll
	public static void setup() {
		authHandler = new UnifiedAuthHandler();
		responseValidator = new ResponseValidator();
		objectMapper = new ObjectMapper();

		String baseUrl = authHandler.getBaseUrl();
		if (baseUrl != null && !baseUrl.isEmpty()) {
			RestAssured.baseURI = baseUrl;
		}
		else {
			RestAssured.baseURI = BASE_URI;
		}

		logger.info("Test setup completed. Base URI: {}", RestAssured.baseURI);
	}

	@Test
	public void testEndpoint() {
		List<Map<String, Object>> testCases = loadTestData();
		Map<String, ParameterInfo> parameters = getParameters();
		SecurityInfo security = getSecurityInfo();
		Map<Integer, ResponseSchema> schemas = getResponseSchemas();

		logger.info("Starting test execution for {} test cases", testCases.size());

		for (Map<String, Object> testCase : testCases) {
			totalTests++;
			String scenario = testCase.containsKey("scenario") ? testCase.get("scenario").toString()
					: "Test case " + totalTests;

			try {
				logger.info("Executing test {}/{}: {}", totalTests, testCases.size(), scenario);

				Object statusCodeObj = testCase.get("expected_statusCode");
				if (statusCodeObj == null) {
					logger.error("Test case missing 'expected_statusCode' field: {}", scenario);
					failedTests.add(scenario + " - Missing expected_statusCode");
					failedTestsCount++;
					continue;
				}
				int expectedStatusCode = ((Number) statusCodeObj).intValue();

				String authValidityType = (expectedStatusCode == 401) ? "invalid" : "valid";

				Response response = executeTest(testCase, parameters, security, authValidityType);

				ResponseSchema schema = schemas.get(expectedStatusCode);
				if (schema == null) {
					schema = schemas.get(0);
				}

				String contentType = response.getHeader("Content-Type");
				if (contentType != null && contentType.toLowerCase().contains("application/json")) {
					responseValidator.validateResponse(response, expectedStatusCode, schema);
					logger.info("Response validation completed for JSON content type");
				}
				else {
					if (response.getStatusCode() == expectedStatusCode) {
						logger.info(
								"Status code validation passed: expected {}, actual {}. Response body validation skipped for content-type: {}",
								expectedStatusCode, response.getStatusCode(),
								contentType != null ? contentType : "not specified");
					}
					else {
						throw new AssertionError(String.format(
								"Status code mismatch: expected %d, but got %d. Response body validation skipped for content-type: %s",
								expectedStatusCode, response.getStatusCode(),
								contentType != null ? contentType : "not specified"));
					}
				}

				passedTests++;
				logger.info("✓ Test passed: {}", scenario);

			}
			catch (Throwable e) {
				failedTestsCount++;
				failedTests.add(scenario + " - " + e.getMessage());
				logger.error("✗ Test failed: {} - Error: {}", scenario, e.getMessage());
			}
		}
	}

	@AfterAll
	public static void tearDown() {
		logger.info("\n=== Test Execution Summary ===");
		logger.info("Total tests: {}", totalTests);
		logger.info("Passed: {}", passedTests);
		logger.info("Failed: {}", failedTestsCount);

		if (failedTestsCount > 0) {
			logger.info("\nFailed test scenarios:");
			for (String failedTest : failedTests) {
				logger.info("  - {}", failedTest);
			}
		}
	}

	private Response executeTest(Map<String, Object> testCase, Map<String, ParameterInfo> parameters,
			SecurityInfo security, String authValidityType) {
		Map<String, Object> queryParams = new HashMap<>();
		Map<String, Object> pathParams = new HashMap<>();
		Map<String, Object> headerParams = new HashMap<>();
		Object requestBody = null;

		for (Map.Entry<String, Object> entry : testCase.entrySet()) {
			String key = entry.getKey();
			if (key.equals("scenario") || key.equals("expected_statusCode")) {
				continue;
			}

			ParameterInfo paramInfo = parameters.get(key);
			if (paramInfo != null) {
				String location = paramInfo.getLocation();
				if ("query".equals(location)) {
					queryParams.put(key, entry.getValue());
				}
				else if ("path".equals(location)) {
					pathParams.put(key, entry.getValue());
				}
				else if ("header".equals(location)) {
					headerParams.put(key, entry.getValue());
				}
			}
			else {
				if (requestBody == null) {
					requestBody = new HashMap<String, Object>();
				}
				if (requestBody instanceof Map) {
					((Map<String, Object>) requestBody).put(key, entry.getValue());
				}
			}
		}

		RequestSpecification request = given().contentType(ContentType.JSON);

		if (security != null && security.getSchemeName() != null) {
			request = authHandler.applyAuth(request, security.getSchemeName(), authValidityType);
		}

		if (!queryParams.isEmpty()) {
			request.queryParams(queryParams);
		}
		if (!pathParams.isEmpty()) {
			request.pathParams(pathParams);
		}
		if (!headerParams.isEmpty()) {
			request.headers(headerParams);
		}
		if (requestBody != null) {
			request.body(requestBody);
		}

		Response response = null;
		if ("post".equalsIgnoreCase(HTTP_METHOD)) {
			response = request.when().post(ENDPOINT);
		}
		else if ("get".equalsIgnoreCase(HTTP_METHOD)) {
			response = request.when().get(ENDPOINT);
		}
		else if ("put".equalsIgnoreCase(HTTP_METHOD)) {
			response = request.when().put(ENDPOINT);
		}
		else if ("delete".equalsIgnoreCase(HTTP_METHOD)) {
			response = request.when().delete(ENDPOINT);
		}
		else if ("patch".equalsIgnoreCase(HTTP_METHOD)) {
			response = request.when().patch(ENDPOINT);
		}

		return response;
	}

	private Map<String, ParameterInfo> getParameters() {
		Map<String, ParameterInfo> parameters = new HashMap<>();
		parameters.put("id", new ParameterInfo("id", "body", "string", false));
		parameters.put("jobTitle", new ParameterInfo("jobTitle", "body", "string", true));
		parameters.put("name", new ParameterInfo("name", "body", "string", true));
		parameters.put("email", new ParameterInfo("email", "body", "string", true));
		return parameters;
	}

	private SecurityInfo getSecurityInfo() {
		return new SecurityInfo(null, null, null, null);
	}

	private Map<Integer, ResponseSchema> getResponseSchemas() {
		Map<Integer, ResponseSchema> schemas = new HashMap<>();

		ResponseSchema schema201 = new ResponseSchema();
		schemas.put(201, schema201);

		ResponseSchema schema400 = new ResponseSchema();
		schemas.put(400, schema400);

		ResponseSchema schema409 = new ResponseSchema();
		schemas.put(409, schema409);

		ResponseSchema defaultSchema = new ResponseSchema();
		schemas.put(0, defaultSchema);

		return schemas;
	}

	private List<Map<String, Object>> loadTestData() {
		try {
			File file = new File(TEST_DATA_FILE);
			return objectMapper.readValue(file, new TypeReference<List<Map<String, Object>>>() {
			});
		}
		catch (IOException e) {
			logger.error("Failed to load test data from file: {}", TEST_DATA_FILE, e);
			return new ArrayList<>();
		}
	}

	private static class ParameterInfo {

		private final String name;

		private final String location;

		private final String type;

		private final boolean required;

		public ParameterInfo(String name, String location, String type, boolean required) {
			this.name = name;
			this.location = location;
			this.type = type;
			this.required = required;
		}

		public String getName() {
			return name;
		}

		public String getLocation() {
			return location;
		}

		public String getType() {
			return type;
		}

		public boolean isRequired() {
			return required;
		}

	}

	private static class SecurityInfo {

		private final String schemeName;

		private final String type;

		private final String credentialName;

		private final String location;

		public SecurityInfo(String schemeName, String type, String credentialName, String location) {
			this.schemeName = schemeName;
			this.type = type;
			this.credentialName = credentialName;
			this.location = location;
		}

		public String getSchemeName() {
			return schemeName;
		}

		public String getType() {
			return type;
		}

		public String getCredentialName() {
			return credentialName;
		}

		public String getLocation() {
			return location;
		}

	}

}
