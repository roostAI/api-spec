// ********RoostGPT********
/*
Test generated by RoostGPT for test rest-assured-20-nov_clone using AI Type Claude AI and AI Model claude-sonnet-4-5-20250929

RoostTestHash=27c74670ad


*/

// ********RoostGPT********
package org.springframework.RoostTest.reb413_employee_service_0_1_swagger.auth;

import io.restassured.specification.RequestSpecification;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;

/**
 * Unified Authentication Handler for REST Assured API Testing
 *
 * This class manages authentication for API requests based on OpenAPI security schemes.
 * It supports both valid and invalid authentication scenarios for comprehensive testing.
 *
 * Features: - Loads credentials from properties file:
 * reb413_employee_service_0_1_swagger_auth.properties - Supports environment variable
 * overrides (prefix: AUTH_) - Handles multiple authentication schemes - Supports negative
 * testing with invalid credentials
 *
 * @author Roost Test Framework
 * @version 1.0
 */
public class UnifiedAuthHandler {

	private Properties properties;

	private Map<String, SecurityScheme> securitySchemes;

	/**
	 * Constructor - Initializes the authentication handler Loads properties and registers
	 * security schemes from the OpenAPI specification
	 */
	public UnifiedAuthHandler() {
		this.properties = new Properties();
		this.securitySchemes = new HashMap<>();
		loadProperties();
	}

	/**
	 * Loads authentication properties from the properties file and environment variables
	 *
	 * Priority: 1. Environment variables (prefixed with AUTH_) 2. Properties file values
	 *
	 * Properties file location:
	 * classpath:reb413_employee_service_0_1_swagger_auth.properties
	 */
	private void loadProperties() {
		// Load from properties file
		try (InputStream input = getClass().getClassLoader()
			.getResourceAsStream("reb413_employee_service_0_1_swagger_auth.properties")) {
			if (input != null) {
				properties.load(input);
			}
			else {
				System.out.println(
						"Warning: reb413_employee_service_0_1_swagger_auth.properties file not found in classpath. Using defaults and environment variables only.");
			}
		}
		catch (IOException e) {
			System.err.println("Error loading properties file: " + e.getMessage());
		}

		// Override with environment variables (prefix: AUTH_)
		Map<String, String> envVars = System.getenv();
		for (Map.Entry<String, String> entry : envVars.entrySet()) {
			if (entry.getKey().startsWith("AUTH_")) {
				String propertyKey = entry.getKey().substring(5); // Remove "AUTH_" prefix
				properties.setProperty(propertyKey, entry.getValue());
			}
		}
	}

	/**
	 * Applies authentication to a REST Assured request specification
	 * @param requestSpec The REST Assured request specification
	 * @param schemeName The name of the security scheme to apply
	 * @param authValidityType Type of authentication: "valid" for real credentials,
	 * "invalid" for fake credentials
	 * @return Modified request specification with authentication applied
	 */
	public RequestSpecification applyAuth(RequestSpecification requestSpec, String schemeName,
			String authValidityType) {
		// CRITICAL FALLBACK: Normalize authValidityType to "valid" if null or empty
		if (authValidityType == null || authValidityType.trim().isEmpty()) {
			authValidityType = "valid";
		}

		if (schemeName == null || schemeName.trim().isEmpty()) {
			System.out.println("Warning: No scheme name provided. Returning request specification unchanged.");
			return requestSpec;
		}

		SecurityScheme scheme = securitySchemes.get(schemeName);
		if (scheme == null) {
			System.out.println("Warning: Security scheme '" + schemeName
					+ "' not found. Returning request specification unchanged.");
			return requestSpec;
		}

		// No security schemes defined in the specification
		// Return the request specification unchanged
		return requestSpec;
	}

	/**
	 * Applies authentication to a REST Assured request specification (backward
	 * compatibility overload) Defaults to "valid" authentication type
	 * @param requestSpec The REST Assured request specification
	 * @param schemeName The name of the security scheme to apply
	 * @return Modified request specification with authentication applied
	 */
	public RequestSpecification applyAuth(RequestSpecification requestSpec, String schemeName) {
		return applyAuth(requestSpec, schemeName, "valid");
	}

	/**
	 * Applies multiple authentication schemes to a REST Assured request specification
	 * @param requestSpec The REST Assured request specification
	 * @param schemeNames List of security scheme names to apply
	 * @param authValidityType Type of authentication: "valid" for real credentials,
	 * "invalid" for fake credentials
	 * @return Modified request specification with all authentications applied
	 */
	public RequestSpecification applyMultipleAuth(RequestSpecification requestSpec, List<String> schemeNames,
			String authValidityType) {
		// CRITICAL FALLBACK: Normalize authValidityType to "valid" if null or empty
		if (authValidityType == null || authValidityType.trim().isEmpty()) {
			authValidityType = "valid";
		}

		if (schemeNames == null || schemeNames.isEmpty()) {
			System.out.println("Warning: No scheme names provided. Returning request specification unchanged.");
			return requestSpec;
		}

		for (String schemeName : schemeNames) {
			requestSpec = applyAuth(requestSpec, schemeName, authValidityType);
		}

		return requestSpec;
	}

	/**
	 * Applies multiple authentication schemes to a REST Assured request specification
	 * (backward compatibility overload) Defaults to "valid" authentication type
	 * @param requestSpec The REST Assured request specification
	 * @param schemeNames List of security scheme names to apply
	 * @return Modified request specification with all authentications applied
	 */
	public RequestSpecification applyMultipleAuth(RequestSpecification requestSpec, List<String> schemeNames) {
		return applyMultipleAuth(requestSpec, schemeNames, "valid");
	}

	/**
	 * Checks if a security scheme exists
	 * @param schemeName The name of the security scheme
	 * @return true if the scheme exists, false otherwise
	 */
	public boolean hasScheme(String schemeName) {
		return securitySchemes.containsKey(schemeName);
	}

	/**
	 * Gets the base URL for the API
	 * @return The base URL from properties or default value
	 */
	public String getBaseUrl() {
		return properties.getProperty("api_baseUrl",
				"https://virtserver.swaggerhub.com/061REB413/employee-service/0.1");
	}

	/**
	 * Gets the environment name
	 * @return The environment name from properties or default value
	 */
	public String getEnvironment() {
		return properties.getProperty("api_environment", "dev");
	}

	/**
	 * Generates an invalid/fake value for negative testing
	 * @param prefix The prefix for the generated value
	 * @return A random string value
	 */
	private String generateInvalidValue(String prefix) {
		return prefix + "_" + UUID.randomUUID().toString();
	}

	/**
	 * Inner class representing a security scheme Stores the parsed details of each
	 * authentication scheme from the OpenAPI specification
	 */
	private static class SecurityScheme {

		String type; // e.g., "apiKey", "http", "oauth2", "openIdConnect"

		String scheme; // e.g., "basic", "bearer", "digest" (for http type)

		String in; // e.g., "header", "query", "cookie" (for apiKey type)

		String name; // The name of the header, query param, or cookie (for apiKey type)

		String bearerFormat; // e.g., "JWT" (for bearer tokens)

		Map<String, Object> flows; // OAuth2 flows

		String openIdConnectUrl; // OpenID Connect URL

		public SecurityScheme(String type) {
			this.type = type;
		}

		@Override
		public String toString() {
			return "SecurityScheme{" + "type='" + type + '\'' + ", scheme='" + scheme + '\'' + ", in='" + in + '\''
					+ ", name='" + name + '\'' + ", bearerFormat='" + bearerFormat + '\'' + ", flows=" + flows
					+ ", openIdConnectUrl='" + openIdConnectUrl + '\'' + '}';
		}

	}

}
