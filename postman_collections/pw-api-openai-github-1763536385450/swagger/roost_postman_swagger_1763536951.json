{
  "item": [
    {
      "name": "Submit Request",
      "request": {
        "name": "Submit Request",
        "description": {
          "content": "Meta API request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "submitRequest"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "\"{{value_*object}}\"",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for submitRequest for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AuthToken",
      "request": {
        "name": "AuthToken",
        "description": {
          "content": "Get authentication token",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "authToken"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null
      },
      "response": [
        {
          "name": "successful login",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"token\": \"token\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for authToken for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful login\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: token\n\n        pm.test(`'responseData field has token that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`token`)) {\n            const value = responseData?.token;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Deposit",
      "request": {
        "name": "Deposit",
        "description": {
          "content": "Deposit amount to customer's account",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deposit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*string}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Deposit success",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deposit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Deposit success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetAccountInfo",
      "request": {
        "name": "GetAccountInfo",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"customerId\": 996.493965599452,\n  \"accounts\": [\n    {\n      \"customerId\": 6697.6971759990665,\n      \"accountName\": \"string\",\n      \"accountNickname\": \"string\",\n      \"accountNumber\": \"string\",\n      \"accountType\": \"string\",\n      \"activatedDate\": \"string\",\n      \"availableBalance\": 4998.965305661643,\n      \"availableCash\": 680.6426316693681,\n      \"availableCashLimit\": 3348.6594307655214,\n      \"availableCredit\": 2056.876432958452,\n      \"bankName\": \"string\",\n      \"branchName\": \"string\",\n      \"cardName\": \"string\",\n      \"cardNumber\": \"string\",\n      \"cardStatus\": \"string\",\n      \"cardType\": \"string\",\n      \"creditLimit\": 6243.289078850685,\n      \"currency\": \"string\",\n      \"currentBalance\": 6727.382095147023,\n      \"deactivatedDate\": \"string\",\n      \"dueAmount\": 8985.08151263881,\n      \"dueDate\": \"string\",\n      \"earlyWithdrawalPenalty\": 5602.73853378672,\n      \"email\": \"string\",\n      \"expDate\": \"string\",\n      \"fdType\": \"string\",\n      \"image\": \"string\",\n      \"interestRate\": 2745.3739046486157,\n      \"internalTransferFromEnabled\": false,\n      \"internalTransferToEnabled\": true,\n      \"isPrimaryMobile\": false,\n      \"isAlternateMobileNumber\": true,\n      \"isStatement\": false,\n      \"lastDrawDate\": \"string\",\n      \"loanMaturityDate\": \"string\",\n      \"loanOriginationDate\": \"string\",\n      \"location\": \"string\",\n      \"lastUpdated\": \"string\",\n      \"maxTransactionLimit\": \"string\",\n      \"maturityDate\": \"string\",\n      \"minimumPaymentDue\": \"string\",\n      \"minimumBalance\": \"string\",\n      \"monthlyPayment\": 773.4649149504924,\n      \"openingBalance\": 3492.2438370443797,\n      \"originalLoanAmount\": 9417.67825573244,\n      \"P2PLimit\": 1799.517237850099,\n      \"p2pEnabled\": 1756.219461983719,\n      \"paybillEnabled\": false,\n      \"payoffAmount\": 843.5731893167953,\n      \"personalBankerName\": \"string\",\n      \"personalBankerContact\": {\n        \"email\": \"string\",\n        \"mobileNumber\": \"string\"\n      },\n      \"phone\": 2229.9732733402066,\n      \"postedBalance\": 8128.073813105223,\n      \"principalBalance\": \"string\",\n      \"productCode\": \"string\",\n      \"productName\": \"string\",\n      \"propertyAddress\": \"string\",\n      \"rewardPoints\": \"string\",\n      \"routingNumber\": \"string\",\n      \"statementDate\": \"string\",\n      \"status\": \"string\",\n      \"swiftCode\": \"string\",\n      \"totalBalance\": 2929.6533363230415,\n      \"unbilledAmount\": 9294.606781081024,\n      \"valueAtMaturity\": 8172.15680572184,\n      \"holdAmount\": 6376.214679612289,\n      \"unclearFundsAmount\": 3344.3924263809045,\n      \"averageMonthlyBalance\": 1365.3843218897,\n      \"netWithdrawableBalance\": 2891.7352614475144,\n      \"totalTenure\": \"string\",\n      \"remainingTenure\": \"string\",\n      \"debitAccountNumber\": \"string\",\n      \"lateFee\": 8728.91317634373,\n      \"bounceCharge\": 7965.806976521663,\n      \"totalCharges\": 7230.690597846974,\n      \"overDueAmount\": 2183.4853011138234,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 6441.515081194085,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 8153.25096689935,\n          \"partialPaymentPaid\": 3892.644736210802\n        },\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 3596.766106798841,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 692.7680039298623,\n          \"partialPaymentPaid\": 850.1411874978681\n        }\n      ],\n      \"IsCrossAccount\": false\n    },\n    {\n      \"customerId\": 3536.0157994203114,\n      \"accountName\": \"string\",\n      \"accountNickname\": \"string\",\n      \"accountNumber\": \"string\",\n      \"accountType\": \"string\",\n      \"activatedDate\": \"string\",\n      \"availableBalance\": 118.92434447319911,\n      \"availableCash\": 3766.7326017335045,\n      \"availableCashLimit\": 1729.2570816327136,\n      \"availableCredit\": 2059.6694367928526,\n      \"bankName\": \"string\",\n      \"branchName\": \"string\",\n      \"cardName\": \"string\",\n      \"cardNumber\": \"string\",\n      \"cardStatus\": \"string\",\n      \"cardType\": \"string\",\n      \"creditLimit\": 4420.347226817845,\n      \"currency\": \"string\",\n      \"currentBalance\": 7694.840118384185,\n      \"deactivatedDate\": \"string\",\n      \"dueAmount\": 2114.6894614164326,\n      \"dueDate\": \"string\",\n      \"earlyWithdrawalPenalty\": 3851.909726772886,\n      \"email\": \"string\",\n      \"expDate\": \"string\",\n      \"fdType\": \"string\",\n      \"image\": \"string\",\n      \"interestRate\": 3446.1015137913596,\n      \"internalTransferFromEnabled\": true,\n      \"internalTransferToEnabled\": true,\n      \"isPrimaryMobile\": false,\n      \"isAlternateMobileNumber\": true,\n      \"isStatement\": false,\n      \"lastDrawDate\": \"string\",\n      \"loanMaturityDate\": \"string\",\n      \"loanOriginationDate\": \"string\",\n      \"location\": \"string\",\n      \"lastUpdated\": \"string\",\n      \"maxTransactionLimit\": \"string\",\n      \"maturityDate\": \"string\",\n      \"minimumPaymentDue\": \"string\",\n      \"minimumBalance\": \"string\",\n      \"monthlyPayment\": 3390.4200511995364,\n      \"openingBalance\": 2198.0624845189054,\n      \"originalLoanAmount\": 7008.063503339697,\n      \"P2PLimit\": 907.657647338691,\n      \"p2pEnabled\": 4045.3792223615983,\n      \"paybillEnabled\": true,\n      \"payoffAmount\": 6491.691470485091,\n      \"personalBankerName\": \"string\",\n      \"personalBankerContact\": {\n        \"email\": \"string\",\n        \"mobileNumber\": \"string\"\n      },\n      \"phone\": 1883.2320145104297,\n      \"postedBalance\": 6875.150963539813,\n      \"principalBalance\": \"string\",\n      \"productCode\": \"string\",\n      \"productName\": \"string\",\n      \"propertyAddress\": \"string\",\n      \"rewardPoints\": \"string\",\n      \"routingNumber\": \"string\",\n      \"statementDate\": \"string\",\n      \"status\": \"string\",\n      \"swiftCode\": \"string\",\n      \"totalBalance\": 4002.050089234912,\n      \"unbilledAmount\": 5133.644547417711,\n      \"valueAtMaturity\": 5391.85742667521,\n      \"holdAmount\": 4233.0331442072165,\n      \"unclearFundsAmount\": 1802.4890455908603,\n      \"averageMonthlyBalance\": 4437.121774158765,\n      \"netWithdrawableBalance\": 2380.9213912914506,\n      \"totalTenure\": \"string\",\n      \"remainingTenure\": \"string\",\n      \"debitAccountNumber\": \"string\",\n      \"lateFee\": 9004.31461645855,\n      \"bounceCharge\": 6033.216050411359,\n      \"totalCharges\": 899.2199746386808,\n      \"overDueAmount\": 894.5203733867379,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 2899.9009099348873,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 2851.1126228933126,\n          \"partialPaymentPaid\": 826.9808803966682\n        },\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": false,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 2662.04721336774,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 57.308609580619674,\n          \"partialPaymentPaid\": 91.31652448488347\n        }\n      ],\n      \"IsCrossAccount\": true\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'accounts' as type array'`, function() {\n          const value = responseData?.accounts;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.accounts field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`accounts`)) {\n            let accountsArray = ld.get(responseData, `accounts`, []);\n            if (Array.isArray(accountsArray)) {\n              for (let accounts_it = 0; accounts_it < accountsArray.length; accounts_it++) {\n                let iterator = accounts_it;\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'customerId' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.customerId;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountNickname' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountNickname;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'activatedDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.activatedDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCash' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCash;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCashLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCashLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCredit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCredit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'bankName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.bankName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'branchName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.branchName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardStatus;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'creditLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.creditLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'currency' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.currency;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'currentBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.currentBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'deactivatedDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.deactivatedDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.dueAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.dueDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'earlyWithdrawalPenalty' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.earlyWithdrawalPenalty;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'email' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.email;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.expDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'fdType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.fdType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'image' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.image;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'interestRate' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.interestRate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'internalTransferFromEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.internalTransferFromEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'internalTransferToEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.internalTransferToEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isPrimaryMobile' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isPrimaryMobile;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isAlternateMobileNumber' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isAlternateMobileNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isStatement' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isStatement;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lastDrawDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.lastDrawDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'loanMaturityDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.loanMaturityDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'loanOriginationDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.loanOriginationDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'location' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.location;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lastUpdated' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.lastUpdated;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'maxTransactionLimit' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.maxTransactionLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'maturityDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.maturityDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'minimumPaymentDue' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.minimumPaymentDue;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'minimumBalance' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.minimumBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'monthlyPayment' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.monthlyPayment;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'openingBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.openingBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'originalLoanAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.originalLoanAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'P2PLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.P2PLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'p2pEnabled' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.p2pEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'paybillEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.paybillEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'payoffAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.payoffAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'personalBankerName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.personalBankerName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'personalBankerContact' as type 'object'`, function() {\n                    const value = accountsArray[iterator]?.personalBankerContact;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: accountsArray[${iterator}].personalBankerContact\n                  // subKey: email\n                  // array: accountsArray\n\n\n                  pm.test(`'accountsArray[${iterator}].personalBankerContact field has email that is of type string'`, function() {\n                    let parent = accountsArray[iterator].personalBankerContact;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`email`)) {\n                      const value = accountsArray[iterator].personalBankerContact?.email;\n                      console.log(`accountsArray[iterator].personalBankerContact?.email`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: accountsArray[${iterator}].personalBankerContact\n                  // subKey: mobileNumber\n                  // array: accountsArray\n\n\n                  pm.test(`'accountsArray[${iterator}].personalBankerContact field has mobileNumber that is of type string'`, function() {\n                    let parent = accountsArray[iterator].personalBankerContact;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n                      const value = accountsArray[iterator].personalBankerContact?.mobileNumber;\n                      console.log(`accountsArray[iterator].personalBankerContact?.mobileNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'phone' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.phone;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'postedBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.postedBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'principalBalance' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.principalBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'productCode' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.productCode;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'productName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.productName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'propertyAddress' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.propertyAddress;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'rewardPoints' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.rewardPoints;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'routingNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.routingNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'statementDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.statementDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'status' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.status;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'swiftCode' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.swiftCode;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.totalBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'unbilledAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.unbilledAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'valueAtMaturity' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.valueAtMaturity;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'holdAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.holdAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'unclearFundsAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.unclearFundsAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'averageMonthlyBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.averageMonthlyBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'netWithdrawableBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.netWithdrawableBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalTenure' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.totalTenure;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'remainingTenure' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.remainingTenure;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'debitAccountNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.debitAccountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lateFee' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.lateFee;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'bounceCharge' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.bounceCharge;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalCharges' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.totalCharges;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'overDueAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.overDueAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardDetails' as type array'`, function() {\n                    const value = accountsArray[iterator]?.cardDetails;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the accountsArray[${iterator}].cardDetails field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(accountsArray[iterator]).to.have.nested.property(`cardDetails`)) {\n                      let cardDetailsArray = ld.get(accountsArray[iterator], `cardDetails`, []);\n                      if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                          let iterator = cardDetails_it;\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardName;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardNumber;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardStatus;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardImage' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardImage;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardType;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.expDate;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'displayCardStatus' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.displayCardStatus;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'primaryCard' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.primaryCard;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardChannelInfo' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardChannelInfo;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: ATM\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has ATM that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`ATM`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.ATM;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.ATM`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: offline\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has offline that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`offline`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.offline;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.offline`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.offline?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.offline?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: international\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has international that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`international`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.international;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.international`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.international?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.international?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: online\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has online that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`online`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.online;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.online`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.online?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.online?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: contactless\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has contactless that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`contactless`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.contactless;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.contactless`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardRestrictions' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardRestrictions;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // array condition and parent property is not an array\n                            pm.test(`'Response has the `\n                              cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                              function() {\n                                if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                                  const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                                  if (value !== null && value !== undefined) {\n                                    pm.expect(Array.isArray(value)).to.equal(true);\n                                  }\n\n                                }\n                              })\n\n                            pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.countries field has all the required fields and correct data-types`, function() {\n                              if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`countries`)) {\n                                let countriesArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `countries`, []);\n                                if (Array.isArray(countriesArray)) {\n                                  for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                                    let iterator = countries_it;\n                                    if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at countriesArray[${iterator}]' has 'countrycode' as type 'string'`, function() {\n                                        const value = countriesArray[iterator]?.countrycode;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                  }\n                                }\n                              }\n                            })\n\n                            // array condition and parent property is not an array\n                            pm.test(`'Response has the `\n                              cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                              function() {\n                                if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                                  const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                                  if (value !== null && value !== undefined) {\n                                    pm.expect(Array.isArray(value)).to.equal(true);\n                                  }\n\n                                }\n                              })\n\n                            pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.MCC field has all the required fields and correct data-types`, function() {\n                              if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`MCC`)) {\n                                let MCCArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `MCC`, []);\n                                if (Array.isArray(MCCArray)) {\n                                  for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                                    let iterator = MCC_it;\n                                    if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at MCCArray[${iterator}]' has 'name' as type 'string'`, function() {\n                                        const value = MCCArray[iterator]?.name;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                    if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at MCCArray[${iterator}]' has 'description' as type 'string'`, function() {\n                                        const value = MCCArray[iterator]?.description;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                  }\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'blockReason' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.blockReason;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'nameOnCard' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.nameOnCard;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNetwork' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardNetwork;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'autopay' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.autopay;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: enabled\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has enabled that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enabled`)) {\n                                const value = cardDetailsArray[iterator].autopay?.enabled;\n                                console.log(`cardDetailsArray[iterator].autopay?.enabled`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: sourceAccountId\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has sourceAccountId that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`sourceAccountId`)) {\n                                const value = cardDetailsArray[iterator].autopay?.sourceAccountId;\n                                console.log(`cardDetailsArray[iterator].autopay?.sourceAccountId`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: paymentType\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has paymentType that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`paymentType`)) {\n                                const value = cardDetailsArray[iterator].autopay?.paymentType;\n                                console.log(`cardDetailsArray[iterator].autopay?.paymentType`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: onStatementDate\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has onStatementDate that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`onStatementDate`)) {\n                                const value = cardDetailsArray[iterator].autopay?.onStatementDate;\n                                console.log(`cardDetailsArray[iterator].autopay?.onStatementDate`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: dayOfMonth\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has dayOfMonth that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`dayOfMonth`)) {\n                                const value = cardDetailsArray[iterator].autopay?.dayOfMonth;\n                                console.log(`cardDetailsArray[iterator].autopay?.dayOfMonth`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.dueAmount;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.dueDate;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'minimumPaymentDue' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.minimumPaymentDue;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'partialPaymentPaid' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.partialPaymentPaid;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'IsCrossAccount' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.IsCrossAccount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the details of the mentioned customer account",
      "request": {
        "name": "to get the details of the mentioned customer account",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountDetails"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*string}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*string}}\"\n        }\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 9045.409689627999,\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"activatedDate\": \"string\",\n    \"availableBalance\": 7342.95284736757,\n    \"availableCash\": 4284.354991043264,\n    \"availableCashLimit\": 181.60577236034925,\n    \"availableCredit\": 1092.5099121065518,\n    \"bankName\": \"string\",\n    \"branchName\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"cardStatus\": \"string\",\n    \"cardType\": \"string\",\n    \"creditLimit\": 5999.570594876289,\n    \"currency\": \"string\",\n    \"currentBalance\": 1192.3828625183507,\n    \"deactivatedDate\": \"string\",\n    \"dueAmount\": 5640.86159063665,\n    \"dueDate\": \"string\",\n    \"earlyWithdrawalPenalty\": 7135.653463141425,\n    \"email\": \"string\",\n    \"expDate\": \"string\",\n    \"fdType\": \"string\",\n    \"image\": \"string\",\n    \"interestRate\": 3228.762310493607,\n    \"internalTransferFromEnabled\": true,\n    \"internalTransferToEnabled\": true,\n    \"isPrimaryMobile\": false,\n    \"isAlternateMobileNumber\": true,\n    \"isStatement\": false,\n    \"lastDrawDate\": \"string\",\n    \"loanMaturityDate\": \"string\",\n    \"loanOriginationDate\": \"string\",\n    \"location\": \"string\",\n    \"lastUpdated\": \"string\",\n    \"maxTransactionLimit\": \"string\",\n    \"maturityDate\": \"string\",\n    \"minimumPaymentDue\": \"string\",\n    \"minimumBalance\": \"string\",\n    \"monthlyPayment\": 1786.517647564816,\n    \"openingBalance\": 6788.605255223026,\n    \"originalLoanAmount\": 6219.21674612117,\n    \"P2PLimit\": 9857.990140536596,\n    \"p2pEnabled\": 6879.332225736796,\n    \"paybillEnabled\": false,\n    \"payoffAmount\": 3006.712149794579,\n    \"personalBankerName\": \"string\",\n    \"personalBankerContact\": {\n      \"email\": \"string\",\n      \"mobileNumber\": \"string\"\n    },\n    \"phone\": 8666.434066073376,\n    \"postedBalance\": 7182.475627052094,\n    \"principalBalance\": \"string\",\n    \"productCode\": \"string\",\n    \"productName\": \"string\",\n    \"propertyAddress\": \"string\",\n    \"rewardPoints\": \"string\",\n    \"routingNumber\": \"string\",\n    \"statementDate\": \"string\",\n    \"status\": \"string\",\n    \"swiftCode\": \"string\",\n    \"totalBalance\": 8565.268917905056,\n    \"unbilledAmount\": 533.5038074519272,\n    \"valueAtMaturity\": 7339.07038631187,\n    \"holdAmount\": 3745.6152934067877,\n    \"unclearFundsAmount\": 1160.8729581560185,\n    \"averageMonthlyBalance\": 2804.9873848411844,\n    \"netWithdrawableBalance\": 603.1271950608818,\n    \"totalTenure\": \"string\",\n    \"remainingTenure\": \"string\",\n    \"debitAccountNumber\": \"string\",\n    \"lateFee\": 73.99800762206476,\n    \"bounceCharge\": 2113.494106446603,\n    \"totalCharges\": 3121.7799731544037,\n    \"overDueAmount\": 5812.312919056672,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 7091.75663176052,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 5001.690388088862,\n        \"partialPaymentPaid\": 6892.299658275813\n      },\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 5979.156880247702,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 7880.097193670365,\n        \"partialPaymentPaid\": 7527.360772946452\n      }\n    ],\n    \"IsCrossAccount\": false\n  },\n  {\n    \"customerId\": 9232.499329426351,\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"activatedDate\": \"string\",\n    \"availableBalance\": 5655.179658474525,\n    \"availableCash\": 5753.467954453983,\n    \"availableCashLimit\": 2240.2932334316515,\n    \"availableCredit\": 8523.132263316571,\n    \"bankName\": \"string\",\n    \"branchName\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"cardStatus\": \"string\",\n    \"cardType\": \"string\",\n    \"creditLimit\": 7199.830799505083,\n    \"currency\": \"string\",\n    \"currentBalance\": 7458.163477937325,\n    \"deactivatedDate\": \"string\",\n    \"dueAmount\": 4134.688316393458,\n    \"dueDate\": \"string\",\n    \"earlyWithdrawalPenalty\": 1777.4087365668856,\n    \"email\": \"string\",\n    \"expDate\": \"string\",\n    \"fdType\": \"string\",\n    \"image\": \"string\",\n    \"interestRate\": 2318.811618716703,\n    \"internalTransferFromEnabled\": false,\n    \"internalTransferToEnabled\": false,\n    \"isPrimaryMobile\": false,\n    \"isAlternateMobileNumber\": false,\n    \"isStatement\": false,\n    \"lastDrawDate\": \"string\",\n    \"loanMaturityDate\": \"string\",\n    \"loanOriginationDate\": \"string\",\n    \"location\": \"string\",\n    \"lastUpdated\": \"string\",\n    \"maxTransactionLimit\": \"string\",\n    \"maturityDate\": \"string\",\n    \"minimumPaymentDue\": \"string\",\n    \"minimumBalance\": \"string\",\n    \"monthlyPayment\": 9884.279953414034,\n    \"openingBalance\": 1354.2455308598323,\n    \"originalLoanAmount\": 220.45793432818206,\n    \"P2PLimit\": 9289.384201890622,\n    \"p2pEnabled\": 3509.161268897978,\n    \"paybillEnabled\": false,\n    \"payoffAmount\": 978.277022567502,\n    \"personalBankerName\": \"string\",\n    \"personalBankerContact\": {\n      \"email\": \"string\",\n      \"mobileNumber\": \"string\"\n    },\n    \"phone\": 7679.913382494752,\n    \"postedBalance\": 1571.2026976441296,\n    \"principalBalance\": \"string\",\n    \"productCode\": \"string\",\n    \"productName\": \"string\",\n    \"propertyAddress\": \"string\",\n    \"rewardPoints\": \"string\",\n    \"routingNumber\": \"string\",\n    \"statementDate\": \"string\",\n    \"status\": \"string\",\n    \"swiftCode\": \"string\",\n    \"totalBalance\": 389.35489265827573,\n    \"unbilledAmount\": 6729.313177412688,\n    \"valueAtMaturity\": 8837.968358788057,\n    \"holdAmount\": 7709.66714402119,\n    \"unclearFundsAmount\": 858.1027372978633,\n    \"averageMonthlyBalance\": 7365.517080535462,\n    \"netWithdrawableBalance\": 9660.164482082791,\n    \"totalTenure\": \"string\",\n    \"remainingTenure\": \"string\",\n    \"debitAccountNumber\": \"string\",\n    \"lateFee\": 6463.109191151144,\n    \"bounceCharge\": 3141.2951854800285,\n    \"totalCharges\": 4999.467662011792,\n    \"overDueAmount\": 6779.279931179057,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 3695.5033313251915,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 2305.7288411023655,\n        \"partialPaymentPaid\": 8938.258930647567\n      },\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 5784.935624244685,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 424.79794457997986,\n        \"partialPaymentPaid\": 4443.736172952069\n      }\n    ],\n    \"IsCrossAccount\": true\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountDetails for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountName\n\n              pm.test(`'item field has accountName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountName`)) {\n                  const value = item?.accountName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNickname\n\n              pm.test(`'item field has accountNickname that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNickname`)) {\n                  const value = item?.accountNickname;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountType\n\n              pm.test(`'item field has accountType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountType`)) {\n                  const value = item?.accountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: activatedDate\n\n              pm.test(`'item field has activatedDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`activatedDate`)) {\n                  const value = item?.activatedDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableBalance\n\n              pm.test(`'item field has availableBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableBalance`)) {\n                  const value = item?.availableBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCash\n\n              pm.test(`'item field has availableCash that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCash`)) {\n                  const value = item?.availableCash;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCashLimit\n\n              pm.test(`'item field has availableCashLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCashLimit`)) {\n                  const value = item?.availableCashLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCredit\n\n              pm.test(`'item field has availableCredit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCredit`)) {\n                  const value = item?.availableCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: bankName\n\n              pm.test(`'item field has bankName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`bankName`)) {\n                  const value = item?.bankName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: branchName\n\n              pm.test(`'item field has branchName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`branchName`)) {\n                  const value = item?.branchName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardName\n\n              pm.test(`'item field has cardName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardName`)) {\n                  const value = item?.cardName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardNumber\n\n              pm.test(`'item field has cardNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                  const value = item?.cardNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardStatus\n\n              pm.test(`'item field has cardStatus that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardStatus`)) {\n                  const value = item?.cardStatus;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardType\n\n              pm.test(`'item field has cardType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardType`)) {\n                  const value = item?.cardType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: creditLimit\n\n              pm.test(`'item field has creditLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`creditLimit`)) {\n                  const value = item?.creditLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currentBalance\n\n              pm.test(`'item field has currentBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currentBalance`)) {\n                  const value = item?.currentBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: deactivatedDate\n\n              pm.test(`'item field has deactivatedDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`deactivatedDate`)) {\n                  const value = item?.deactivatedDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: dueAmount\n\n              pm.test(`'item field has dueAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`dueAmount`)) {\n                  const value = item?.dueAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: dueDate\n\n              pm.test(`'item field has dueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`dueDate`)) {\n                  const value = item?.dueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: earlyWithdrawalPenalty\n\n              pm.test(`'item field has earlyWithdrawalPenalty that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`earlyWithdrawalPenalty`)) {\n                  const value = item?.earlyWithdrawalPenalty;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: email\n\n              pm.test(`'item field has email that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`email`)) {\n                  const value = item?.email;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: expDate\n\n              pm.test(`'item field has expDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`expDate`)) {\n                  const value = item?.expDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: fdType\n\n              pm.test(`'item field has fdType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`fdType`)) {\n                  const value = item?.fdType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: image\n\n              pm.test(`'item field has image that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`image`)) {\n                  const value = item?.image;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: interestRate\n\n              pm.test(`'item field has interestRate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`interestRate`)) {\n                  const value = item?.interestRate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: internalTransferFromEnabled\n\n              pm.test(`'item field has internalTransferFromEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`internalTransferFromEnabled`)) {\n                  const value = item?.internalTransferFromEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: internalTransferToEnabled\n\n              pm.test(`'item field has internalTransferToEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`internalTransferToEnabled`)) {\n                  const value = item?.internalTransferToEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isPrimaryMobile\n\n              pm.test(`'item field has isPrimaryMobile that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isPrimaryMobile`)) {\n                  const value = item?.isPrimaryMobile;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isAlternateMobileNumber\n\n              pm.test(`'item field has isAlternateMobileNumber that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n                  const value = item?.isAlternateMobileNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isStatement\n\n              pm.test(`'item field has isStatement that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isStatement`)) {\n                  const value = item?.isStatement;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lastDrawDate\n\n              pm.test(`'item field has lastDrawDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lastDrawDate`)) {\n                  const value = item?.lastDrawDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: loanMaturityDate\n\n              pm.test(`'item field has loanMaturityDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`loanMaturityDate`)) {\n                  const value = item?.loanMaturityDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: loanOriginationDate\n\n              pm.test(`'item field has loanOriginationDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`loanOriginationDate`)) {\n                  const value = item?.loanOriginationDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: location\n\n              pm.test(`'item field has location that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`location`)) {\n                  const value = item?.location;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lastUpdated\n\n              pm.test(`'item field has lastUpdated that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lastUpdated`)) {\n                  const value = item?.lastUpdated;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: maxTransactionLimit\n\n              pm.test(`'item field has maxTransactionLimit that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maxTransactionLimit`)) {\n                  const value = item?.maxTransactionLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: maturityDate\n\n              pm.test(`'item field has maturityDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maturityDate`)) {\n                  const value = item?.maturityDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: minimumPaymentDue\n\n              pm.test(`'item field has minimumPaymentDue that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`minimumPaymentDue`)) {\n                  const value = item?.minimumPaymentDue;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: minimumBalance\n\n              pm.test(`'item field has minimumBalance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`minimumBalance`)) {\n                  const value = item?.minimumBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: monthlyPayment\n\n              pm.test(`'item field has monthlyPayment that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthlyPayment`)) {\n                  const value = item?.monthlyPayment;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: openingBalance\n\n              pm.test(`'item field has openingBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`openingBalance`)) {\n                  const value = item?.openingBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: originalLoanAmount\n\n              pm.test(`'item field has originalLoanAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`originalLoanAmount`)) {\n                  const value = item?.originalLoanAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: P2PLimit\n\n              pm.test(`'item field has P2PLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`P2PLimit`)) {\n                  const value = item?.P2PLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: p2pEnabled\n\n              pm.test(`'item field has p2pEnabled that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`p2pEnabled`)) {\n                  const value = item?.p2pEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: paybillEnabled\n\n              pm.test(`'item field has paybillEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`paybillEnabled`)) {\n                  const value = item?.paybillEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: payoffAmount\n\n              pm.test(`'item field has payoffAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`payoffAmount`)) {\n                  const value = item?.payoffAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: personalBankerName\n\n              pm.test(`'item field has personalBankerName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`personalBankerName`)) {\n                  const value = item?.personalBankerName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: personalBankerContact\n\n              pm.test(`'item field has personalBankerContact that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`personalBankerContact`)) {\n                  const value = item?.personalBankerContact;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.personalBankerContact\n              // subKey: email\n\n              pm.test(`'item.personalBankerContact field has email that is of type string'`, function() {\n                let parent = item.personalBankerContact;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`email`)) {\n                  const value = item.personalBankerContact?.email;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.personalBankerContact\n              // subKey: mobileNumber\n\n              pm.test(`'item.personalBankerContact field has mobileNumber that is of type string'`, function() {\n                let parent = item.personalBankerContact;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n                  const value = item.personalBankerContact?.mobileNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: phone\n\n              pm.test(`'item field has phone that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`phone`)) {\n                  const value = item?.phone;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: postedBalance\n\n              pm.test(`'item field has postedBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`postedBalance`)) {\n                  const value = item?.postedBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: principalBalance\n\n              pm.test(`'item field has principalBalance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`principalBalance`)) {\n                  const value = item?.principalBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: productCode\n\n              pm.test(`'item field has productCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`productCode`)) {\n                  const value = item?.productCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: productName\n\n              pm.test(`'item field has productName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`productName`)) {\n                  const value = item?.productName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: propertyAddress\n\n              pm.test(`'item field has propertyAddress that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`propertyAddress`)) {\n                  const value = item?.propertyAddress;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: rewardPoints\n\n              pm.test(`'item field has rewardPoints that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`rewardPoints`)) {\n                  const value = item?.rewardPoints;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: routingNumber\n\n              pm.test(`'item field has routingNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`routingNumber`)) {\n                  const value = item?.routingNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: statementDate\n\n              pm.test(`'item field has statementDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`statementDate`)) {\n                  const value = item?.statementDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: swiftCode\n\n              pm.test(`'item field has swiftCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`swiftCode`)) {\n                  const value = item?.swiftCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalBalance\n\n              pm.test(`'item field has totalBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalBalance`)) {\n                  const value = item?.totalBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: unbilledAmount\n\n              pm.test(`'item field has unbilledAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`unbilledAmount`)) {\n                  const value = item?.unbilledAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: valueAtMaturity\n\n              pm.test(`'item field has valueAtMaturity that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`valueAtMaturity`)) {\n                  const value = item?.valueAtMaturity;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: holdAmount\n\n              pm.test(`'item field has holdAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`holdAmount`)) {\n                  const value = item?.holdAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: unclearFundsAmount\n\n              pm.test(`'item field has unclearFundsAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`unclearFundsAmount`)) {\n                  const value = item?.unclearFundsAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: averageMonthlyBalance\n\n              pm.test(`'item field has averageMonthlyBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`averageMonthlyBalance`)) {\n                  const value = item?.averageMonthlyBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: netWithdrawableBalance\n\n              pm.test(`'item field has netWithdrawableBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`netWithdrawableBalance`)) {\n                  const value = item?.netWithdrawableBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalTenure\n\n              pm.test(`'item field has totalTenure that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalTenure`)) {\n                  const value = item?.totalTenure;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: remainingTenure\n\n              pm.test(`'item field has remainingTenure that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`remainingTenure`)) {\n                  const value = item?.remainingTenure;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: debitAccountNumber\n\n              pm.test(`'item field has debitAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`debitAccountNumber`)) {\n                  const value = item?.debitAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lateFee\n\n              pm.test(`'item field has lateFee that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lateFee`)) {\n                  const value = item?.lateFee;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: bounceCharge\n\n              pm.test(`'item field has bounceCharge that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`bounceCharge`)) {\n                  const value = item?.bounceCharge;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalCharges\n\n              pm.test(`'item field has totalCharges that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalCharges`)) {\n                  const value = item?.totalCharges;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: overDueAmount\n\n              pm.test(`'item field has overDueAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`overDueAmount`)) {\n                  const value = item?.overDueAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // array condition without arrayName and parent property is an array\n              pm.test(`'item has 'cardDetails' as type array'`, function() {\n                const value = item?.cardDetails;\n\n                if (value !== null && value !== undefined) {\n                  pm.expect(Array.isArray(value)).to.equal(true);\n                }\n\n              })\n\n\n              pm.test(`Each object in the item.cardDetails field has all the required fields and correct data-types`, function() {\n                if (pm.expect(item).to.have.nested.property(`cardDetails`)) {\n                  let cardDetailsArray = ld.get(item, `cardDetails`, []);\n                  if (Array.isArray(cardDetailsArray)) {\n                    for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                      let iterator = cardDetails_it;\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardName;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardNumber;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardStatus;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardImage' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardImage;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardType;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.expDate;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'displayCardStatus' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.displayCardStatus;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'primaryCard' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.primaryCard;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardChannelInfo' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardChannelInfo;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: ATM\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has ATM that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`ATM`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.ATM;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.ATM`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: offline\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has offline that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`offline`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.offline;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.offline`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.offline?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.offline?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: international\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has international that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`international`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.international;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.international`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.international?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.international?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: online\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has online that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`online`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.online;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.online`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.online?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.online?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: contactless\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has contactless that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`contactless`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.contactless;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.contactless`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardRestrictions' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardRestrictions;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // array condition and parent property is not an array\n                        pm.test(`'Response has the `\n                          cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                          function() {\n                            if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                              const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                              if (value !== null && value !== undefined) {\n                                pm.expect(Array.isArray(value)).to.equal(true);\n                              }\n\n                            }\n                          })\n\n                        pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.countries field has all the required fields and correct data-types`, function() {\n                          if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`countries`)) {\n                            let countriesArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `countries`, []);\n                            if (Array.isArray(countriesArray)) {\n                              for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                                let iterator = countries_it;\n                                if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at countriesArray[${iterator}]' has 'countrycode' as type 'string'`, function() {\n                                    const value = countriesArray[iterator]?.countrycode;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                              }\n                            }\n                          }\n                        })\n\n                        // array condition and parent property is not an array\n                        pm.test(`'Response has the `\n                          cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                          function() {\n                            if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                              const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                              if (value !== null && value !== undefined) {\n                                pm.expect(Array.isArray(value)).to.equal(true);\n                              }\n\n                            }\n                          })\n\n                        pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.MCC field has all the required fields and correct data-types`, function() {\n                          if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`MCC`)) {\n                            let MCCArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `MCC`, []);\n                            if (Array.isArray(MCCArray)) {\n                              for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                                let iterator = MCC_it;\n                                if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at MCCArray[${iterator}]' has 'name' as type 'string'`, function() {\n                                    const value = MCCArray[iterator]?.name;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                                if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at MCCArray[${iterator}]' has 'description' as type 'string'`, function() {\n                                    const value = MCCArray[iterator]?.description;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                              }\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'blockReason' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.blockReason;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'nameOnCard' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.nameOnCard;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNetwork' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardNetwork;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'autopay' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.autopay;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: enabled\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has enabled that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enabled`)) {\n                            const value = cardDetailsArray[iterator].autopay?.enabled;\n                            console.log(`cardDetailsArray[iterator].autopay?.enabled`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: sourceAccountId\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has sourceAccountId that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`sourceAccountId`)) {\n                            const value = cardDetailsArray[iterator].autopay?.sourceAccountId;\n                            console.log(`cardDetailsArray[iterator].autopay?.sourceAccountId`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: paymentType\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has paymentType that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`paymentType`)) {\n                            const value = cardDetailsArray[iterator].autopay?.paymentType;\n                            console.log(`cardDetailsArray[iterator].autopay?.paymentType`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: onStatementDate\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has onStatementDate that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`onStatementDate`)) {\n                            const value = cardDetailsArray[iterator].autopay?.onStatementDate;\n                            console.log(`cardDetailsArray[iterator].autopay?.onStatementDate`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: dayOfMonth\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has dayOfMonth that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`dayOfMonth`)) {\n                            const value = cardDetailsArray[iterator].autopay?.dayOfMonth;\n                            console.log(`cardDetailsArray[iterator].autopay?.dayOfMonth`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.dueAmount;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.dueDate;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'minimumPaymentDue' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.minimumPaymentDue;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'partialPaymentPaid' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.partialPaymentPaid;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                    }\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: IsCrossAccount\n\n              pm.test(`'item field has IsCrossAccount that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`IsCrossAccount`)) {\n                  const value = item?.IsCrossAccount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountsLimit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"balance\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"currency\": \"string\",\n    \"customerId\": 6073.58458563509,\n    \"perTxn\": 1607.1620865319903,\n    \"status\": \"string\",\n    \"availableCashLimit\": 7678.048605310665,\n    \"creditLimit\": 1305.294345647583,\n    \"availableCredit\": 4692.000606063818,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 7458.811044900699,\n          \"maximum\": 901.887645813062,\n          \"spent\": 3420.7589199846366\n        },\n        \"daily\": {\n          \"available\": 6838.331427326762,\n          \"maximum\": 7101.577914535304,\n          \"spent\": 4473.882223447159\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 3190.5974356871325,\n          \"maximum\": 7516.904018830956,\n          \"usedup\": 4015.9585471898486\n        },\n        \"daily\": {\n          \"available\": 166.96888339063466,\n          \"maximum\": 2684.5501067617492,\n          \"usedup\": 4703.0944781443095\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 6383.024937522153,\n      \"maximum\": 8308.36369361372,\n      \"usedup\": 313.32435538662384,\n      \"amountperday\": 6714.089156404306\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 9069.496293235163,\n          \"maximum\": 3895.418946089431,\n          \"spent\": 1546.385866042681\n        },\n        \"daily\": {\n          \"available\": 3819.7318878721885,\n          \"maximum\": 2066.717634132047,\n          \"spent\": 1738.5266989748804\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 5685.374757530141,\n          \"maximum\": 3175.4541537647365,\n          \"usedup\": 508.45067341102276\n        },\n        \"daily\": {\n          \"available\": 6807.456074420617,\n          \"maximum\": 3385.3528127674704,\n          \"usedup\": 3680.5763959029746\n        }\n      }\n    }\n  },\n  {\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"balance\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"currency\": \"string\",\n    \"customerId\": 9662.519860078062,\n    \"perTxn\": 4995.122802952425,\n    \"status\": \"string\",\n    \"availableCashLimit\": 6369.10205918259,\n    \"creditLimit\": 3217.9094329787204,\n    \"availableCredit\": 2849.477598122285,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 7184.2216428583415,\n          \"maximum\": 9254.844215639727,\n          \"spent\": 6158.1665789937915\n        },\n        \"daily\": {\n          \"available\": 1664.7886664290202,\n          \"maximum\": 8897.575013323623,\n          \"spent\": 8256.178221367312\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 4971.4721141477285,\n          \"maximum\": 3285.3289757828175,\n          \"usedup\": 5998.280832501417\n        },\n        \"daily\": {\n          \"available\": 4210.099782493546,\n          \"maximum\": 8408.73752039215,\n          \"usedup\": 9987.76643461764\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 9846.252310846257,\n      \"maximum\": 6934.061288550651,\n      \"usedup\": 4962.567303259182,\n      \"amountperday\": 6188.461495269077\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 9984.735263084274,\n          \"maximum\": 8475.338150638148,\n          \"spent\": 5671.272668266174\n        },\n        \"daily\": {\n          \"available\": 7770.773411109326,\n          \"maximum\": 2050.2329849214184,\n          \"spent\": 3944.1547019030354\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 1770.858585334829,\n          \"maximum\": 5512.60264134452,\n          \"usedup\": 9493.11922041159\n        },\n        \"daily\": {\n          \"available\": 1524.4918439626254,\n          \"maximum\": 8495.17030232461,\n          \"usedup\": 7757.541174189284\n        }\n      }\n    }\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountsLimit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountName\n\n              pm.test(`'item field has accountName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountName`)) {\n                  const value = item?.accountName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNickname\n\n              pm.test(`'item field has accountNickname that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNickname`)) {\n                  const value = item?.accountNickname;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountType\n\n              pm.test(`'item field has accountType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountType`)) {\n                  const value = item?.accountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: balance\n\n              pm.test(`'item field has balance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`balance`)) {\n                  const value = item?.balance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardName\n\n              pm.test(`'item field has cardName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardName`)) {\n                  const value = item?.cardName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardNumber\n\n              pm.test(`'item field has cardNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                  const value = item?.cardNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: perTxn\n\n              pm.test(`'item field has perTxn that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`perTxn`)) {\n                  const value = item?.perTxn;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCashLimit\n\n              pm.test(`'item field has availableCashLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCashLimit`)) {\n                  const value = item?.availableCashLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: creditLimit\n\n              pm.test(`'item field has creditLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`creditLimit`)) {\n                  const value = item?.creditLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCredit\n\n              pm.test(`'item field has availableCredit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCredit`)) {\n                  const value = item?.availableCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: purchase\n\n              pm.test(`'item field has purchase that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`purchase`)) {\n                  const value = item?.purchase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: limits\n\n              pm.test(`'item.purchase field has limits that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.purchase?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: monthly\n\n              pm.test(`'item.purchase.limits field has monthly that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: daily\n\n              pm.test(`'item.purchase.limits field has daily that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: transactions\n\n              pm.test(`'item.purchase field has transactions that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.purchase?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: monthly\n\n              pm.test(`'item.purchase.transactions field has monthly that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: daily\n\n              pm.test(`'item.purchase.transactions field has daily that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: txnsPerDay\n\n              pm.test(`'item field has txnsPerDay that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`txnsPerDay`)) {\n                  const value = item?.txnsPerDay;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: available\n\n              pm.test(`'item.txnsPerDay field has available that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.txnsPerDay?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: maximum\n\n              pm.test(`'item.txnsPerDay field has maximum that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.txnsPerDay?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: usedup\n\n              pm.test(`'item.txnsPerDay field has usedup that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.txnsPerDay?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: amountperday\n\n              pm.test(`'item.txnsPerDay field has amountperday that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amountperday`)) {\n                  const value = item.txnsPerDay?.amountperday;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: withdrawal\n\n              pm.test(`'item field has withdrawal that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`withdrawal`)) {\n                  const value = item?.withdrawal;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: limits\n\n              pm.test(`'item.withdrawal field has limits that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.withdrawal?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.limits field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.limits field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: transactions\n\n              pm.test(`'item.withdrawal field has transactions that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.withdrawal?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.transactions field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.transactions field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountSpecificLimitsInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 1045300,\n    \"currency\": \"USD\",\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 5,\n      \"maximum\": 8,\n      \"usedup\": 3,\n      \"amount\": 500\n    },\n    \"perTxn\": 500\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountSpecificLimitsInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: perTxn\n\n              pm.test(`'item field has perTxn that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`perTxn`)) {\n                  const value = item?.perTxn;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: purchase\n\n              pm.test(`'item field has purchase that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`purchase`)) {\n                  const value = item?.purchase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: limits\n\n              pm.test(`'item.purchase field has limits that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.purchase?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: monthly\n\n              pm.test(`'item.purchase.limits field has monthly that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: daily\n\n              pm.test(`'item.purchase.limits field has daily that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: transactions\n\n              pm.test(`'item.purchase field has transactions that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.purchase?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: monthly\n\n              pm.test(`'item.purchase.transactions field has monthly that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: daily\n\n              pm.test(`'item.purchase.transactions field has daily that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: txnsPerDay\n\n              pm.test(`'item field has txnsPerDay that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`txnsPerDay`)) {\n                  const value = item?.txnsPerDay;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: available\n\n              pm.test(`'item.txnsPerDay field has available that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.txnsPerDay?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: maximum\n\n              pm.test(`'item.txnsPerDay field has maximum that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.txnsPerDay?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: usedup\n\n              pm.test(`'item.txnsPerDay field has usedup that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.txnsPerDay?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: amount\n\n              pm.test(`'item.txnsPerDay field has amount that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amount`)) {\n                  const value = item.txnsPerDay?.amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: withdrawal\n\n              pm.test(`'item field has withdrawal that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`withdrawal`)) {\n                  const value = item?.withdrawal;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: limits\n\n              pm.test(`'item.withdrawal field has limits that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.withdrawal?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.limits field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.limits field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: transactions\n\n              pm.test(`'item.withdrawal field has transactions that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.withdrawal?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.transactions field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.transactions field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateAccountInfo",
      "request": {
        "name": "UpdateAccountInfo",
        "description": {
          "content": "Update customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateAccountInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCustomerInfo",
      "request": {
        "name": "GetCustomerInfo",
        "description": {
          "content": "fetch customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"alternatePhoneNumber\": 9621.433274185836,\n  \"customerId\": \"string\",\n  \"email\": \"string\",\n  \"identificationNumber\": 5415.748741495337,\n  \"identificationType\": \"string\",\n  \"image\": \"string\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": true,\n  \"location\": \"string\",\n  \"name\": \"string\",\n  \"firstName\": \"string\",\n  \"lastName\": \"string\",\n  \"personalBanker\": {\n    \"name\": \"string\",\n    \"email\": \"string\",\n    \"mobileNumber\": \"string\"\n  },\n  \"phone\": 5023.846645658829,\n  \"securityQuestions\": [\n    \"string\",\n    \"string\"\n  ],\n  \"segmentId\": 5468.071690211107\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCustomerInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alternatePhoneNumber\n\n        pm.test(`'responseData field has alternatePhoneNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alternatePhoneNumber`)) {\n            const value = responseData?.alternatePhoneNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: email\n\n        pm.test(`'responseData field has email that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationNumber\n\n        pm.test(`'responseData field has identificationNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationNumber`)) {\n            const value = responseData?.identificationNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationType\n\n        pm.test(`'responseData field has identificationType that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationType`)) {\n            const value = responseData?.identificationType;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: image\n\n        pm.test(`'responseData field has image that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`image`)) {\n            const value = responseData?.image;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isAlternateMobileNumber\n\n        pm.test(`'responseData field has isAlternateMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n            const value = responseData?.isAlternateMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isPrimaryMobileNumber\n\n        pm.test(`'responseData field has isPrimaryMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isPrimaryMobileNumber`)) {\n            const value = responseData?.isPrimaryMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: firstName\n\n        pm.test(`'responseData field has firstName that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`firstName`)) {\n            const value = responseData?.firstName;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: lastName\n\n        pm.test(`'responseData field has lastName that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lastName`)) {\n            const value = responseData?.lastName;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalBanker\n\n        pm.test(`'responseData field has personalBanker that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalBanker`)) {\n            const value = responseData?.personalBanker;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: name\n\n        pm.test(`'responseData.personalBanker field has name that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.personalBanker?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: email\n\n        pm.test(`'responseData.personalBanker field has email that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData.personalBanker?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: mobileNumber\n\n        pm.test(`'responseData.personalBanker field has mobileNumber that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n            const value = responseData.personalBanker?.mobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: phone\n\n        pm.test(`'responseData field has phone that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`phone`)) {\n            const value = responseData?.phone;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'securityQuestions' as type array'`, function() {\n          const value = responseData?.securityQuestions;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: segmentId\n\n        pm.test(`'responseData field has segmentId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`segmentId`)) {\n            const value = responseData?.segmentId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateCustomerInfo",
      "request": {
        "name": "UpdateCustomerInfo",
        "description": {
          "content": "Update customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateCustomerInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetTransactions",
      "request": {
        "name": "GetTransactions",
        "description": {
          "content": "Fetch transactions information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetTransactions"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetTransactions"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 5997.617673872548,\n    \"transactionId\": 9909.611802955986,\n    \"accountNumber\": \"string\",\n    \"timestamp\": 7956.7437276889905,\n    \"amount\": 5523.349305524405,\n    \"currency\": \"string\",\n    \"debitOrCredit\": \"string\",\n    \"description\": \"string\",\n    \"paymentMode\": \"string\",\n    \"DBANames\": \"string\",\n    \"status\": \"string\",\n    \"closingBalance\": 2733.345295265388,\n    \"transacitonType\": \"string\",\n    \"ACHCode\": \"string\",\n    \"MCCCode\": \"string\",\n    \"SICCode\": \"string\",\n    \"name\": \"string\",\n    \"address\": \"string\",\n    \"street\": \"string\",\n    \"city\": \"string\",\n    \"state\": \"string\",\n    \"zip\": \"string\",\n    \"country\": \"string\",\n    \"phoneNumber\": 3227.306802479193,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  },\n  {\n    \"customerId\": 4273.05975977657,\n    \"transactionId\": 7460.96540754793,\n    \"accountNumber\": \"string\",\n    \"timestamp\": 9117.058162190226,\n    \"amount\": 8154.058536366307,\n    \"currency\": \"string\",\n    \"debitOrCredit\": \"string\",\n    \"description\": \"string\",\n    \"paymentMode\": \"string\",\n    \"DBANames\": \"string\",\n    \"status\": \"string\",\n    \"closingBalance\": 771.8810492588868,\n    \"transacitonType\": \"string\",\n    \"ACHCode\": \"string\",\n    \"MCCCode\": \"string\",\n    \"SICCode\": \"string\",\n    \"name\": \"string\",\n    \"address\": \"string\",\n    \"street\": \"string\",\n    \"city\": \"string\",\n    \"state\": \"string\",\n    \"zip\": \"string\",\n    \"country\": \"string\",\n    \"phoneNumber\": 3006.813990345383,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetTransactions for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: transactionId\n\n              pm.test(`'item field has transactionId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactionId`)) {\n                  const value = item?.transactionId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: timestamp\n\n              pm.test(`'item field has timestamp that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`timestamp`)) {\n                  const value = item?.timestamp;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: amount\n\n              pm.test(`'item field has amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amount`)) {\n                  const value = item?.amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: debitOrCredit\n\n              pm.test(`'item field has debitOrCredit that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`debitOrCredit`)) {\n                  const value = item?.debitOrCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: description\n\n              pm.test(`'item field has description that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`description`)) {\n                  const value = item?.description;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: paymentMode\n\n              pm.test(`'item field has paymentMode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`paymentMode`)) {\n                  const value = item?.paymentMode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DBANames\n\n              pm.test(`'item field has DBANames that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DBANames`)) {\n                  const value = item?.DBANames;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: closingBalance\n\n              pm.test(`'item field has closingBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`closingBalance`)) {\n                  const value = item?.closingBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: transacitonType\n\n              pm.test(`'item field has transacitonType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transacitonType`)) {\n                  const value = item?.transacitonType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ACHCode\n\n              pm.test(`'item field has ACHCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ACHCode`)) {\n                  const value = item?.ACHCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: MCCCode\n\n              pm.test(`'item field has MCCCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`MCCCode`)) {\n                  const value = item?.MCCCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SICCode\n\n              pm.test(`'item field has SICCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SICCode`)) {\n                  const value = item?.SICCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: name\n\n              pm.test(`'item field has name that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`name`)) {\n                  const value = item?.name;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: address\n\n              pm.test(`'item field has address that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`address`)) {\n                  const value = item?.address;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: street\n\n              pm.test(`'item field has street that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`street`)) {\n                  const value = item?.street;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: city\n\n              pm.test(`'item field has city that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`city`)) {\n                  const value = item?.city;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: state\n\n              pm.test(`'item field has state that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`state`)) {\n                  const value = item?.state;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: zip\n\n              pm.test(`'item field has zip that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`zip`)) {\n                  const value = item?.zip;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: country\n\n              pm.test(`'item field has country that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`country`)) {\n                  const value = item?.country;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: phoneNumber\n\n              pm.test(`'item field has phoneNumber that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`phoneNumber`)) {\n                  const value = item?.phoneNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // array condition without arrayName and parent property is an array\n              pm.test(`'item has 'metaInfo' as type array'`, function() {\n                const value = item?.metaInfo;\n\n                if (value !== null && value !== undefined) {\n                  pm.expect(Array.isArray(value)).to.equal(true);\n                }\n\n              })\n\n\n              pm.test(`Each object in the item.metaInfo field has all the required fields and correct data-types`, function() {\n                if (pm.expect(item).to.have.nested.property(`metaInfo`)) {\n                  let metaInfoArray = ld.get(item, `metaInfo`, []);\n                  if (Array.isArray(metaInfoArray)) {\n                    for (let metaInfo_it = 0; metaInfo_it < metaInfoArray.length; metaInfo_it++) {\n                      let iterator = metaInfo_it;\n                      // Condition: Raw data type with defined arrayName and parent property is an array\n                      pm.test(`'Item at metaInfoArray[${iterator}]' has 'name' as type 'string'`, function() {\n                        const value = metaInfoArray[iterator]?.name;\n\n                        pm.expect(typeof value).to.equal(\"string\");\n\n                      })\n\n\n                      // Condition: Raw data type with defined arrayName and parent property is an array\n                      pm.test(`'Item at metaInfoArray[${iterator}]' has 'value' as type 'string'`, function() {\n                        const value = metaInfoArray[iterator]?.value;\n\n                        pm.expect(typeof value).to.equal(\"string\");\n\n                      })\n\n\n                    }\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "TransferFunds",
      "request": {
        "name": "TransferFunds",
        "description": {
          "content": "Transfers funds between accounts",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "TransferFunds"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*string}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Transaction success",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for TransferFunds for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Transaction success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetScheduleTransfers",
      "request": {
        "name": "GetScheduleTransfers",
        "description": {
          "content": "Fetches the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 8427.931151700166,\n    \"Amount\": 5377.444440187791,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"InvoiceNumber\": 1558.215451438718,\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 528.4008884638181,\n    \"NextScheduleDate\": 4414.092641107066,\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 9878.858254900171,\n    \"Amount\": 9423.556240005857,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"InvoiceNumber\": 4614.388011297819,\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 4805.86495821453,\n    \"NextScheduleDate\": 7999.855262349467,\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: InvoiceNumber\n\n              pm.test(`'item field has InvoiceNumber that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`InvoiceNumber`)) {\n                  const value = item?.InvoiceNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ScheduledDate\n\n              pm.test(`'item field has ScheduledDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ScheduledDate`)) {\n                  const value = item?.ScheduledDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: NextScheduleDate\n\n              pm.test(`'item field has NextScheduleDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`NextScheduleDate`)) {\n                  const value = item?.NextScheduleDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateScheduleTransfers",
      "request": {
        "name": "UpdateScheduleTransfers",
        "description": {
          "content": "Update the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateScheduleTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Scheduled transfer updated successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteScheduleTransfers",
      "request": {
        "name": "DeleteScheduleTransfers",
        "description": {
          "content": "Delete the scheduled transfer",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Scheduled transfer deleted successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AddRecurringTransfers",
      "request": {
        "name": "AddRecurringTransfers",
        "description": {
          "content": "Adds the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "AddRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer added successfully",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for AddRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer added successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetRecurringTransfers",
      "request": {
        "name": "GetRecurringTransfers",
        "description": {
          "content": "Fetches all the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 7504.75935383041,\n    \"Amount\": 4768.128835391734,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 1815.5483556399088,\n    \"recurringOptions\": {\n      \"amountType\": \"string\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"string\",\n          \"untilDate\": \"string\",\n          \"numberOfPayments\": \"string\"\n        },\n        \"iterate\": \"string\"\n      }\n    },\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 5159.941310993146,\n    \"Amount\": 4783.828799191214,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 6715.003717608936,\n    \"recurringOptions\": {\n      \"amountType\": \"string\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"string\",\n          \"untilDate\": \"string\",\n          \"numberOfPayments\": \"string\"\n        },\n        \"iterate\": \"string\"\n      }\n    },\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ScheduledDate\n\n              pm.test(`'item field has ScheduledDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ScheduledDate`)) {\n                  const value = item?.ScheduledDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: recurringOptions\n\n              pm.test(`'item field has recurringOptions that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`recurringOptions`)) {\n                  const value = item?.recurringOptions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions\n              // subKey: amountType\n\n              pm.test(`'item.recurringOptions field has amountType that is of type string'`, function() {\n                let parent = item.recurringOptions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amountType`)) {\n                  const value = item.recurringOptions?.amountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions\n              // subKey: frequency\n\n              pm.test(`'item.recurringOptions field has frequency that is of type object'`, function() {\n                let parent = item.recurringOptions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`frequency`)) {\n                  const value = item.recurringOptions?.frequency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency\n              // subKey: duration\n\n              pm.test(`'item.recurringOptions.frequency field has duration that is of type object'`, function() {\n                let parent = item.recurringOptions.frequency;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`duration`)) {\n                  const value = item.recurringOptions.frequency?.duration;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: untilStop\n\n              pm.test(`'item.recurringOptions.frequency.duration field has untilStop that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`untilStop`)) {\n                  const value = item.recurringOptions.frequency.duration?.untilStop;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: untilDate\n\n              pm.test(`'item.recurringOptions.frequency.duration field has untilDate that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`untilDate`)) {\n                  const value = item.recurringOptions.frequency.duration?.untilDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: numberOfPayments\n\n              pm.test(`'item.recurringOptions.frequency.duration field has numberOfPayments that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`numberOfPayments`)) {\n                  const value = item.recurringOptions.frequency.duration?.numberOfPayments;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency\n              // subKey: iterate\n\n              pm.test(`'item.recurringOptions.frequency field has iterate that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`iterate`)) {\n                  const value = item.recurringOptions.frequency?.iterate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateRecurringTransfers",
      "request": {
        "name": "UpdateRecurringTransfers",
        "description": {
          "content": "Update the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            },\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\"\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateRecurringTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Recurring transfer updated successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteRecurringTransfers",
      "request": {
        "name": "DeleteRecurringTransfers",
        "description": {
          "content": "Delete the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Recurring transfer deleted successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "resetPassword",
      "request": {
        "name": "resetPassword",
        "description": {
          "content": "It allows to reset the password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "resetPassword"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"password\": \"{{password_*string}}\",\n    \"username\": \"{{username_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "password has been updated successfully.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for resetPassword for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"password has been updated successfully.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "debitcardInfoValidation",
      "request": {
        "name": "debitcardInfoValidation",
        "description": {
          "content": "for validating card info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "debitcardInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*string}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*string}}\",\n    \"expiryDate\": \"{{expiryDate_*string}}\",\n    \"pin\": \"{{pin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for debitcardInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Validated Successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "personalInfoValidation",
      "request": {
        "name": "personalInfoValidation",
        "description": {
          "content": "for validating personal info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "personalInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*string}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*string}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for personalInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Validated Successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "disputeTransaction",
      "request": {
        "name": "disputeTransaction",
        "description": {
          "content": "dispute a transaction",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "disputeTransaction"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Dispute Transactions reported successfully",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for disputeTransaction for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Dispute Transactions reported successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "ccPay",
      "request": {
        "name": "ccPay",
        "description": {
          "content": "to pay cc bill",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "ccPay"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Credit Card payment scheduled successfully",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for ccPay for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Credit Card payment scheduled successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCCSchedule",
      "request": {
        "name": "GetCCSchedule",
        "description": {
          "content": "Fetch cc payment list",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCCSchedule"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 8865.31381881413,\n    \"Amount\": 5910.693809149013,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 9169.973524357549,\n    \"Amount\": 4840.6310803559745,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCCSchedule for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendsecuremessage",
      "request": {
        "name": "sendsecuremessage",
        "description": {
          "content": "send secure message",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendsecuremessage"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendsecuremessage for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "locateProfile",
      "request": {
        "name": "locateProfile",
        "description": {
          "content": "get profile details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "locateProfile"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"accountNumber\": \"string\",\n  \"cardDetails\": {\n    \"cardNumber\": \"string\",\n    \"expiryDate\": \"string\",\n    \"cvv\": \"string\",\n    \"pin\": \"string\"\n  },\n  \"personalQuestions\": {\n    \"DOB\": \"string\",\n    \"SSN\": 7318.750338657527,\n    \"SecretPassword\": \"string\",\n    \"LDAmount\": 7269.324402886293,\n    \"AccNumber\": \"string\"\n  },\n  \"ssNumber\": 4961.3671242882365,\n  \"ssnShort\": 9294.390412569606,\n  \"alternatePhoneNumber\": 2204.611755552115,\n  \"customerId\": \"string\",\n  \"email\": \"string\",\n  \"identificationNumber\": \"string\",\n  \"identificationType\": \"string\",\n  \"image\": \"string\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": false,\n  \"location\": \"string\",\n  \"name\": \"string\",\n  \"personalBanker\": {\n    \"name\": \"string\",\n    \"email\": \"string\",\n    \"mobileNumber\": \"string\"\n  },\n  \"phone\": 9504.177307138216,\n  \"securityQuestions\": [\n    \"string\",\n    \"string\"\n  ],\n  \"segmentId\": 5986.366670152063,\n  \"multiAccounts\": [\n    {\n      \"accountNumber\": \"string\",\n      \"cardDetails\": {\n        \"cardNumber\": \"string\",\n        \"expiryDate\": \"string\",\n        \"cvv\": \"string\",\n        \"pin\": \"string\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"string\",\n        \"SSN\": 9761.924384296479,\n        \"SecretPassword\": \"string\",\n        \"LDAmount\": 1092.8545205504813,\n        \"AccNumber\": \"string\"\n      },\n      \"ssNumber\": 7510.976934747507,\n      \"ssnShort\": 5607.369757971676,\n      \"alternatePhoneNumber\": 5666.052016771042,\n      \"customerId\": \"string\",\n      \"email\": \"string\",\n      \"identificationNumber\": \"string\",\n      \"identificationType\": \"string\",\n      \"location\": \"string\",\n      \"name\": \"string\",\n      \"phone\": 9271.788344264274\n    },\n    {\n      \"accountNumber\": \"string\",\n      \"cardDetails\": {\n        \"cardNumber\": \"string\",\n        \"expiryDate\": \"string\",\n        \"cvv\": \"string\",\n        \"pin\": \"string\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"string\",\n        \"SSN\": 3411.4176495489824,\n        \"SecretPassword\": \"string\",\n        \"LDAmount\": 8784.942256123113,\n        \"AccNumber\": \"string\"\n      },\n      \"ssNumber\": 5885.726816528933,\n      \"ssnShort\": 3969.8262088420533,\n      \"alternatePhoneNumber\": 5077.857287345087,\n      \"customerId\": \"string\",\n      \"email\": \"string\",\n      \"identificationNumber\": \"string\",\n      \"identificationType\": \"string\",\n      \"location\": \"string\",\n      \"name\": \"string\",\n      \"phone\": 62.60885366255353\n    }\n  ],\n  \"warningCodes\": [\n    {\n      \"code\": 9486.592010866058,\n      \"level\": \"string\",\n      \"description\": \"string\"\n    },\n    {\n      \"code\": 5989.521057054987,\n      \"level\": \"string\",\n      \"description\": \"string\"\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for locateProfile for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: accountNumber\n\n        pm.test(`'responseData field has accountNumber that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n            const value = responseData?.accountNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: cardDetails\n\n        pm.test(`'responseData field has cardDetails that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cardDetails`)) {\n            const value = responseData?.cardDetails;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: cardNumber\n\n        pm.test(`'responseData.cardDetails field has cardNumber that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n            const value = responseData.cardDetails?.cardNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: expiryDate\n\n        pm.test(`'responseData.cardDetails field has expiryDate that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`expiryDate`)) {\n            const value = responseData.cardDetails?.expiryDate;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: cvv\n\n        pm.test(`'responseData.cardDetails field has cvv that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cvv`)) {\n            const value = responseData.cardDetails?.cvv;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: pin\n\n        pm.test(`'responseData.cardDetails field has pin that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pin`)) {\n            const value = responseData.cardDetails?.pin;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalQuestions\n\n        pm.test(`'responseData field has personalQuestions that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalQuestions`)) {\n            const value = responseData?.personalQuestions;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: DOB\n\n        pm.test(`'responseData.personalQuestions field has DOB that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`DOB`)) {\n            const value = responseData.personalQuestions?.DOB;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: SSN\n\n        pm.test(`'responseData.personalQuestions field has SSN that is of type number'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`SSN`)) {\n            const value = responseData.personalQuestions?.SSN;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: SecretPassword\n\n        pm.test(`'responseData.personalQuestions field has SecretPassword that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`SecretPassword`)) {\n            const value = responseData.personalQuestions?.SecretPassword;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: LDAmount\n\n        pm.test(`'responseData.personalQuestions field has LDAmount that is of type number'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`LDAmount`)) {\n            const value = responseData.personalQuestions?.LDAmount;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: AccNumber\n\n        pm.test(`'responseData.personalQuestions field has AccNumber that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`AccNumber`)) {\n            const value = responseData.personalQuestions?.AccNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ssNumber\n\n        pm.test(`'responseData field has ssNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ssNumber`)) {\n            const value = responseData?.ssNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ssnShort\n\n        pm.test(`'responseData field has ssnShort that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ssnShort`)) {\n            const value = responseData?.ssnShort;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alternatePhoneNumber\n\n        pm.test(`'responseData field has alternatePhoneNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alternatePhoneNumber`)) {\n            const value = responseData?.alternatePhoneNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: email\n\n        pm.test(`'responseData field has email that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationNumber\n\n        pm.test(`'responseData field has identificationNumber that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationNumber`)) {\n            const value = responseData?.identificationNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationType\n\n        pm.test(`'responseData field has identificationType that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationType`)) {\n            const value = responseData?.identificationType;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: image\n\n        pm.test(`'responseData field has image that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`image`)) {\n            const value = responseData?.image;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isAlternateMobileNumber\n\n        pm.test(`'responseData field has isAlternateMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n            const value = responseData?.isAlternateMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isPrimaryMobileNumber\n\n        pm.test(`'responseData field has isPrimaryMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isPrimaryMobileNumber`)) {\n            const value = responseData?.isPrimaryMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalBanker\n\n        pm.test(`'responseData field has personalBanker that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalBanker`)) {\n            const value = responseData?.personalBanker;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: name\n\n        pm.test(`'responseData.personalBanker field has name that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.personalBanker?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: email\n\n        pm.test(`'responseData.personalBanker field has email that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData.personalBanker?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: mobileNumber\n\n        pm.test(`'responseData.personalBanker field has mobileNumber that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n            const value = responseData.personalBanker?.mobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: phone\n\n        pm.test(`'responseData field has phone that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`phone`)) {\n            const value = responseData?.phone;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'securityQuestions' as type array'`, function() {\n          const value = responseData?.securityQuestions;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: segmentId\n\n        pm.test(`'responseData field has segmentId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`segmentId`)) {\n            const value = responseData?.segmentId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'multiAccounts' as type array'`, function() {\n          const value = responseData?.multiAccounts;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.multiAccounts field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`multiAccounts`)) {\n            let multiAccountsArray = ld.get(responseData, `multiAccounts`, []);\n            if (Array.isArray(multiAccountsArray)) {\n              for (let multiAccounts_it = 0; multiAccounts_it < multiAccountsArray.length; multiAccounts_it++) {\n                let iterator = multiAccounts_it;\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'accountNumber' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.accountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'cardDetails' as type 'object'`, function() {\n                    const value = multiAccountsArray[iterator]?.cardDetails;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: cardNumber\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has cardNumber that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.cardNumber;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.cardNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: expiryDate\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has expiryDate that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`expiryDate`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.expiryDate;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.expiryDate`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: cvv\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has cvv that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`cvv`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.cvv;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.cvv`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: pin\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has pin that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`pin`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.pin;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.pin`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'personalQuestions' as type 'object'`, function() {\n                    const value = multiAccountsArray[iterator]?.personalQuestions;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: DOB\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has DOB that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`DOB`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.DOB;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.DOB`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: SSN\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has SSN that is of type number'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`SSN`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.SSN;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.SSN`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: SecretPassword\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has SecretPassword that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`SecretPassword`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.SecretPassword;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.SecretPassword`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: LDAmount\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has LDAmount that is of type number'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`LDAmount`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.LDAmount;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.LDAmount`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: AccNumber\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has AccNumber that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`AccNumber`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.AccNumber;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.AccNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'ssNumber' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.ssNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'ssnShort' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.ssnShort;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'alternatePhoneNumber' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.alternatePhoneNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'customerId' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.customerId;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'email' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.email;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'identificationNumber' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.identificationNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'identificationType' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.identificationType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'location' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.location;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'name' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.name;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'phone' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.phone;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'warningCodes' as type array'`, function() {\n          const value = responseData?.warningCodes;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.warningCodes field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`warningCodes`)) {\n            let warningCodesArray = ld.get(responseData, `warningCodes`, []);\n            if (Array.isArray(warningCodesArray)) {\n              for (let warningCodes_it = 0; warningCodes_it < warningCodesArray.length; warningCodes_it++) {\n                let iterator = warningCodes_it;\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'code' as type 'number'`, function() {\n                    const value = warningCodesArray[iterator]?.code;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'level' as type 'string'`, function() {\n                    const value = warningCodesArray[iterator]?.level;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'description' as type 'string'`, function() {\n                    const value = warningCodesArray[iterator]?.description;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the exiting user",
      "request": {
        "name": "to validate the exiting user",
        "description": {
          "content": "to validate the in of existing user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validateUser"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validateUser for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PINs matched\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the pins entered by the new user",
      "request": {
        "name": "to validate the pins entered by the new user",
        "description": {
          "content": "to validate the pins entered by the new user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePIN"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePIN for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PINs matched\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate if pin entered by new user follows pin rules",
      "request": {
        "name": "to validate if pin entered by new user follows pin rules",
        "description": {
          "content": "to validate if pin entered by new user follows pin rules",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePINRules"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PIN rules satisfied",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePINRules for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PIN rules satisfied\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the account closure status",
      "request": {
        "name": "to fetch the account closure status",
        "description": {
          "content": "to fetch the account closure status",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "getRequestStatus"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for getRequestStatus for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to place the request",
      "request": {
        "name": "to place the request",
        "description": {
          "content": "to place the request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "request"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for request for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to enable or disable e or paper statements at profile level",
      "request": {
        "name": "to enable or disable e or paper statements at profile level",
        "description": {
          "content": "to enable or disable e or paper statements at profile level",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "enableEStatement"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for enableEStatement for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to update the cheque book details of customer accounts",
      "request": {
        "name": "to update the cheque book details of customer accounts",
        "description": {
          "content": "Update customer cheque book details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "RequestChequeBook"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for RequestChequeBook for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendOTP",
      "request": {
        "name": "sendOTP",
        "description": {
          "content": "sends OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "verification code has been sent to your mobile number",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"verification code has been sent to your mobile number\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "verifyOTP",
      "request": {
        "name": "verifyOTP",
        "description": {
          "content": "to verify OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "verifyOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "OTP verifid successfully",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for verifyOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"OTP verifid successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the deeplink",
      "request": {
        "name": "to fetch the deeplink",
        "description": {
          "content": "to fetch the deeplink",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deeplink"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "tenantId",
            "value": "{{tenantId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "environment",
            "value": "{{environment}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "channel",
            "value": "{{channel}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"usecase\": \"addbeneficiary\",\n    \"link\": \"www.google.com\",\n    \"linkType\": \"deeplink\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763536385450 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deeplink for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: usecase\n\n              pm.test(`'item field has usecase that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usecase`)) {\n                  const value = item?.usecase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: link\n\n              pm.test(`'item field has link that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`link`)) {\n                  const value = item?.link;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: linkType\n\n              pm.test(`'item field has linkType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`linkType`)) {\n                  const value = item?.linkType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://localhost:8080/smt",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{bearerToken}}"
      }
    ]
  },
  "info": {
    "_postman_id": "4b55586f-ead9-4b56-831d-af35b7c9eb86",
    "name": "BankAssist SMT Core Banking API Specification",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "kore.ai banking bot apis.",
      "type": "text/plain"
    }
  }
}