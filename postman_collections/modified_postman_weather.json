{
  "item": [
    {
      "name": "Realtime API",
      "request": {
        "name": "Realtime API",
        "description": {
          "content": "Current weather or realtime weather API method allows a user to get up to date current weather information in json and xml. The data is returned as a Current Object.<br /><br />Current object contains current or realtime weather information for a given city.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "current.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "current.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"current\": {\n    \"last_updated_epoch\": 1658522700,\n    \"last_updated\": \"2022-07-22 16:45\",\n    \"temp_c\": 34.4,\n    \"temp_f\": 93.9,\n    \"is_day\": 1,\n    \"condition\": {\n      \"text\": \"Partly cloudy\",\n      \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/116.png\",\n      \"code\": 1003\n    },\n    \"wind_mph\": 16.1,\n    \"wind_kph\": 25.9,\n    \"wind_degree\": 180,\n    \"wind_dir\": \"S\",\n    \"pressure_mb\": 1011,\n    \"pressure_in\": 29.85,\n    \"precip_mm\": 0,\n    \"precip_in\": 0,\n    \"humidity\": 31,\n    \"cloud\": 75,\n    \"feelslike_c\": 37,\n    \"feelslike_f\": 98.6,\n    \"vis_km\": 16,\n    \"vis_miles\": 9,\n    \"uv\": 8,\n    \"gust_mph\": 11.6,\n    \"gust_kph\": 18.7,\n    \"air_quality\": {\n      \"co\": 293.70001220703125,\n      \"no2\": 18.5,\n      \"o3\": 234.60000610351562,\n      \"so2\": 12,\n      \"pm2_5\": 13.600000381469727,\n      \"pm10\": 15,\n      \"us-epa-index\": 1,\n      \"gb-defra-index\": 2\n    }\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "current.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "current.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "current.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for current.json?q={{q}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current`)) {\n                    const value = ld.get(jsonResponse, `current`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.last_updated_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.last_updated_epoch`)) {\n                    const value = ld.get(responseData, `current.last_updated_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.last_updated_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('current.last_updated_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.last_updated_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045400);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.last_updated_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.last_updated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.last_updated`)) {\n                    const value = ld.get(jsonResponse, `current.last_updated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`current.last_updated length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`current.last_updated length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.last_updated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.temp_c` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.temp_c`)) {\n                    const value = ld.get(responseData, `current.temp_c`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1034.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-965.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.temp_c:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.temp_f` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.temp_f`)) {\n                    const value = ld.get(responseData, `current.temp_f`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1093.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-906.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.temp_f:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.is_day` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.is_day`)) {\n                    const value = ld.get(responseData, `current.is_day`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.is_day:\", error.message);\n            }\n        })\n  \n        pm.test('current.is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.is_day:\", error.message);\n            }\n        })\n  \n        pm.test('current.is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.is_day:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition`)) {\n                    const value = ld.get(jsonResponse, `current.condition`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current.condition:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.text` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition.text`)) {\n                    const value = ld.get(jsonResponse, `current.condition.text`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.condition.text:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.icon` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition.icon`)) {\n                    const value = ld.get(jsonResponse, `current.condition.icon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.condition.code`)) {\n                    const value = ld.get(responseData, `current.condition.code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.condition.code:\", error.message);\n            }\n        })\n  \n        pm.test('current.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.condition.code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_mph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_mph`)) {\n                    const value = ld.get(responseData, `current.wind_mph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1016.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-983.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_mph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_kph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_kph`)) {\n                    const value = ld.get(responseData, `current.wind_kph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1025.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-974.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_kph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_degree` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_degree`)) {\n                    const value = ld.get(responseData, `current.wind_degree`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1180);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-820);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_degree:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_dir` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.wind_dir`)) {\n                    const value = ld.get(jsonResponse, `current.wind_dir`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`current.wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`current.wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.wind_dir:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.pressure_mb` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.pressure_mb`)) {\n                    const value = ld.get(responseData, `current.pressure_mb`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.pressure_mb:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2022);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.pressure_in` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.pressure_in`)) {\n                    const value = ld.get(responseData, `current.pressure_in`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.85);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.15);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.pressure_in:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.precip_mm` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.precip_mm`)) {\n                    const value = ld.get(responseData, `current.precip_mm`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.precip_mm:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.precip_in` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.precip_in`)) {\n                    const value = ld.get(responseData, `current.precip_in`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.precip_in:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.humidity` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.humidity`)) {\n                    const value = ld.get(responseData, `current.humidity`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.humidity:\", error.message);\n            }\n        })\n  \n        pm.test('current.humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1031);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.humidity:\", error.message);\n            }\n        })\n  \n        pm.test('current.humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.humidity:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.cloud` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.cloud`)) {\n                    const value = ld.get(responseData, `current.cloud`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.cloud:\", error.message);\n            }\n        })\n  \n        pm.test('current.cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1075);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.cloud:\", error.message);\n            }\n        })\n  \n        pm.test('current.cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-925);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.cloud:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.feelslike_c` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.feelslike_c`)) {\n                    const value = ld.get(responseData, `current.feelslike_c`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1037);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-963);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.feelslike_f` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.feelslike_f`)) {\n                    const value = ld.get(responseData, `current.feelslike_f`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1098.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-901.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.vis_km` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.vis_km`)) {\n                    const value = ld.get(responseData, `current.vis_km`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1016);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.vis_km:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.vis_miles` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.vis_miles`)) {\n                    const value = ld.get(responseData, `current.vis_miles`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-991);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.vis_miles:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.uv` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.uv`)) {\n                    const value = ld.get(responseData, `current.uv`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.uv:\", error.message);\n            }\n        })\n  \n        pm.test('current.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.uv:\", error.message);\n            }\n        })\n  \n        pm.test('current.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.uv:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.gust_mph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.gust_mph`)) {\n                    const value = ld.get(responseData, `current.gust_mph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1011.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-988.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.gust_mph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.gust_kph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.gust_kph`)) {\n                    const value = ld.get(responseData, `current.gust_kph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1018.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.gust_kph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.air_quality`)) {\n                    const value = ld.get(jsonResponse, `current.air_quality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current.air_quality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.co` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.co`)) {\n                    const value = ld.get(responseData, `current.air_quality.co`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.co:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.co maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.co`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1293.7000122070312);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.co:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.co minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.co`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-706.2999877929688);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.co:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.no2` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.no2`)) {\n                    const value = ld.get(responseData, `current.air_quality.no2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.no2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.no2 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.no2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1018.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.no2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.no2 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.no2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.no2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.o3` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.o3`)) {\n                    const value = ld.get(responseData, `current.air_quality.o3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.o3:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.o3 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.o3`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1234.6000061035156);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.o3:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.o3 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.o3`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-765.3999938964844);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.o3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.so2` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.so2`)) {\n                    const value = ld.get(responseData, `current.air_quality.so2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.so2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.so2 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.so2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.so2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.so2 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.so2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-988);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.so2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.pm2_5` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.pm2_5`)) {\n                    const value = ld.get(responseData, `current.air_quality.pm2_5`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.pm2_5:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm2_5 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm2_5`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1013.6000003814697);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.pm2_5:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm2_5 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm2_5`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-986.3999996185303);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.pm2_5:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.pm10` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.pm10`)) {\n                    const value = ld.get(responseData, `current.air_quality.pm10`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.pm10:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm10 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm10`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.pm10:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm10 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm10`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.pm10:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.us-epa-index` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.us-epa-index`)) {\n                    const value = ld.get(responseData, `current.air_quality.us-epa-index`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.us-epa-index maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.us-epa-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.us-epa-index minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.us-epa-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.gb-defra-index` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.gb-defra-index`)) {\n                    const value = ld.get(responseData, `current.air_quality.gb-defra-index`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.gb-defra-index maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.gb-defra-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1002);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.gb-defra-index minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.gb-defra-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-998);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Forecast API",
      "request": {
        "name": "Forecast API",
        "description": {
          "content": "Forecast weather API method returns, depending upon your price plan level, upto next 14 day weather forecast and weather alert as json or xml. The data is returned as a Forecast Object.<br /><br />Forecast object contains astronomy data, day weather forecast and hourly interval weather information for a given city.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "forecast.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "days",
              "value": "{{days}}",
              "description": "(Required) Number of days of weather forecast. Value ranges from 1 to 14"
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "Date should be between today and next 14 day in yyyy-MM-dd format. e.g. '2015-01-01'"
            },
            {
              "disabled": false,
              "key": "unixdt",
              "value": "{{unixdt}}",
              "description": "Please either pass 'dt' or 'unixdt' and not both in same request. unixdt should be between today and next 14 day in Unix format. e.g. 1490227200"
            },
            {
              "disabled": false,
              "key": "hour",
              "value": "{{hour}}",
              "description": "Must be in 24 hour. For example 5 pm should be hour=17, 6 am as hour=6"
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            },
            {
              "disabled": false,
              "key": "alerts",
              "value": "{{alerts}}",
              "description": "Enable/Disable alerts in forecast API output. Example, alerts=yes or alerts=no."
            },
            {
              "disabled": false,
              "key": "aqi",
              "value": "{{aqi}}",
              "description": "Enable/Disable Air Quality data in forecast API output. Example, aqi=yes or aqi=no."
            },
            {
              "disabled": false,
              "key": "tp",
              "value": "{{tp}}",
              "description": "Get 15 min interval or 24 hour average data for Forecast and History API. Available for Enterprise clients only. E.g:- tp=15"
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "forecast.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "alerts",
                  "value": "{{alerts}}"
                },
                {
                  "key": "aqi",
                  "value": "{{aqi}}"
                },
                {
                  "key": "tp",
                  "value": "{{tp}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"current\": {\n    \"last_updated_epoch\": 1658522700,\n    \"last_updated\": \"2022-07-22 16:45\",\n    \"temp_c\": 34.4,\n    \"temp_f\": 93.9,\n    \"is_day\": 1,\n    \"condition\": {\n      \"text\": \"Partly cloudy\",\n      \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/116.png\",\n      \"code\": 1003\n    },\n    \"wind_mph\": 16.1,\n    \"wind_kph\": 25.9,\n    \"wind_degree\": 180,\n    \"wind_dir\": \"S\",\n    \"pressure_mb\": 1011,\n    \"pressure_in\": 29.85,\n    \"precip_mm\": 0,\n    \"precip_in\": 0,\n    \"humidity\": 31,\n    \"cloud\": 75,\n    \"feelslike_c\": 37,\n    \"feelslike_f\": 98.6,\n    \"vis_km\": 16,\n    \"vis_miles\": 9,\n    \"uv\": 8,\n    \"gust_mph\": 11.6,\n    \"gust_kph\": 18.7,\n    \"air_quality\": {\n      \"co\": 293.70001220703125,\n      \"no2\": 18.5,\n      \"o3\": 234.60000610351562,\n      \"so2\": 12,\n      \"pm2_5\": 13.600000381469727,\n      \"pm10\": 15,\n      \"us-epa-index\": 1,\n      \"gb-defra-index\": 2\n    }\n  },\n  \"forecast\": {\n    \"forecastday\": [\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"officia in ullamco\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      },\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"sint in\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      }\n    ]\n  },\n  \"alerts\": {\n    \"alert\": [\n      {\n        \"headline\": \"NWS New York City - Upton (Long Island and New York City)\",\n        \"msgtype\": \"minim nostrud dolore dolor\",\n        \"severity\": \"irure in\",\n        \"urgency\": \"velit officia id commodo\",\n        \"areas\": \"velit et culpa\",\n        \"category\": \"Extreme temperature value\",\n        \"certainty\": \"nostrud aute\",\n        \"event\": \"Heat Advisory\",\n        \"note\": \"adipisicing\",\n        \"effective\": \"2022-07-21T19:38:00+00:00\",\n        \"expires\": \"2022-07-25T00:00:00+00:00\",\n        \"desc\": \"...HEAT ADVISORY REMAINS IN EFFECT UNTIL 8 PM EDT SUNDAY... * WHAT...Heat index values up to 105. * WHERE...Eastern Passaic Hudson Western Bergen Western Essex Eastern Bergen and Eastern Essex Counties. * WHEN...Until 8 PM EDT Sunday. * IMPACTS...High temperatures and high humidity may cause heat illnesses to occur.\",\n        \"instruction\": \"\"\n      },\n      {\n        \"headline\": \"NWS New York City - Upton (Long Island and New York City)\",\n        \"msgtype\": \"mollit laboris\",\n        \"severity\": \"adipisicing voluptate dolor\",\n        \"urgency\": \"sunt officia sed\",\n        \"areas\": \"Excepteur cupidatat com\",\n        \"category\": \"Extreme temperature value\",\n        \"certainty\": \"in ex cupidatat\",\n        \"event\": \"Heat Advisory\",\n        \"note\": \"sit est aliquip ea\",\n        \"effective\": \"2022-07-21T19:38:00+00:00\",\n        \"expires\": \"2022-07-25T00:00:00+00:00\",\n        \"desc\": \"...HEAT ADVISORY REMAINS IN EFFECT UNTIL 8 PM EDT SUNDAY... * WHAT...Heat index values up to 105. * WHERE...Eastern Passaic Hudson Western Bergen Western Essex Eastern Bergen and Eastern Essex Counties. * WHEN...Until 8 PM EDT Sunday. * IMPACTS...High temperatures and high humidity may cause heat illnesses to occur.\",\n        \"instruction\": \"\"\n      }\n    ]\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "forecast.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "alerts",
                  "value": "{{alerts}}"
                },
                {
                  "key": "aqi",
                  "value": "{{aqi}}"
                },
                {
                  "key": "tp",
                  "value": "{{tp}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "forecast.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "alerts",
                  "value": "{{alerts}}"
                },
                {
                  "key": "aqi",
                  "value": "{{aqi}}"
                },
                {
                  "key": "tp",
                  "value": "{{tp}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "forecast.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "alerts",
                  "value": "{{alerts}}"
                },
                {
                  "key": "aqi",
                  "value": "{{aqi}}"
                },
                {
                  "key": "tp",
                  "value": "{{tp}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current`)) {\n                    const value = ld.get(jsonResponse, `current`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.last_updated_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.last_updated_epoch`)) {\n                    const value = ld.get(responseData, `current.last_updated_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.last_updated_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('current.last_updated_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.last_updated_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045400);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.last_updated_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.last_updated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.last_updated`)) {\n                    const value = ld.get(jsonResponse, `current.last_updated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`current.last_updated length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`current.last_updated length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.last_updated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.temp_c` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.temp_c`)) {\n                    const value = ld.get(responseData, `current.temp_c`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1034.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-965.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.temp_c:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.temp_f` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.temp_f`)) {\n                    const value = ld.get(responseData, `current.temp_f`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1093.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-906.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.temp_f:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.is_day` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.is_day`)) {\n                    const value = ld.get(responseData, `current.is_day`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.is_day:\", error.message);\n            }\n        })\n  \n        pm.test('current.is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.is_day:\", error.message);\n            }\n        })\n  \n        pm.test('current.is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.is_day:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition`)) {\n                    const value = ld.get(jsonResponse, `current.condition`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current.condition:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.text` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition.text`)) {\n                    const value = ld.get(jsonResponse, `current.condition.text`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.condition.text:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.icon` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.condition.icon`)) {\n                    const value = ld.get(jsonResponse, `current.condition.icon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`current.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.condition.code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.condition.code`)) {\n                    const value = ld.get(responseData, `current.condition.code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.condition.code:\", error.message);\n            }\n        })\n  \n        pm.test('current.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.condition.code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_mph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_mph`)) {\n                    const value = ld.get(responseData, `current.wind_mph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1016.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-983.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_mph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_kph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_kph`)) {\n                    const value = ld.get(responseData, `current.wind_kph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1025.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-974.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_kph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_degree` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.wind_degree`)) {\n                    const value = ld.get(responseData, `current.wind_degree`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1180);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('current.wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-820);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.wind_degree:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.wind_dir` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.wind_dir`)) {\n                    const value = ld.get(jsonResponse, `current.wind_dir`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field current.wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`current.wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `current.wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for current.wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`current.wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `current.wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for current.wind_dir:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.pressure_mb` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.pressure_mb`)) {\n                    const value = ld.get(responseData, `current.pressure_mb`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.pressure_mb:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2022);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.pressure_in` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.pressure_in`)) {\n                    const value = ld.get(responseData, `current.pressure_in`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.85);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.15);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.pressure_in:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.precip_mm` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.precip_mm`)) {\n                    const value = ld.get(responseData, `current.precip_mm`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.precip_mm:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.precip_in` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.precip_in`)) {\n                    const value = ld.get(responseData, `current.precip_in`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('current.precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.precip_in:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.humidity` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.humidity`)) {\n                    const value = ld.get(responseData, `current.humidity`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.humidity:\", error.message);\n            }\n        })\n  \n        pm.test('current.humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1031);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.humidity:\", error.message);\n            }\n        })\n  \n        pm.test('current.humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.humidity:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.cloud` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.cloud`)) {\n                    const value = ld.get(responseData, `current.cloud`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.cloud:\", error.message);\n            }\n        })\n  \n        pm.test('current.cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1075);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.cloud:\", error.message);\n            }\n        })\n  \n        pm.test('current.cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-925);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.cloud:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.feelslike_c` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.feelslike_c`)) {\n                    const value = ld.get(responseData, `current.feelslike_c`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1037);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-963);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.feelslike_f` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.feelslike_f`)) {\n                    const value = ld.get(responseData, `current.feelslike_f`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1098.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('current.feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-901.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.vis_km` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.vis_km`)) {\n                    const value = ld.get(responseData, `current.vis_km`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1016);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.vis_km:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.vis_miles` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.vis_miles`)) {\n                    const value = ld.get(responseData, `current.vis_miles`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('current.vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-991);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.vis_miles:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.uv` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.uv`)) {\n                    const value = ld.get(responseData, `current.uv`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.uv:\", error.message);\n            }\n        })\n  \n        pm.test('current.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.uv:\", error.message);\n            }\n        })\n  \n        pm.test('current.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.uv:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.gust_mph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.gust_mph`)) {\n                    const value = ld.get(responseData, `current.gust_mph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1011.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-988.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.gust_mph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.gust_kph` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.gust_kph`)) {\n                    const value = ld.get(responseData, `current.gust_kph`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1018.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('current.gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.gust_kph:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`current.air_quality`)) {\n                    const value = ld.get(jsonResponse, `current.air_quality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field current.air_quality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.co` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.co`)) {\n                    const value = ld.get(responseData, `current.air_quality.co`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.co:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.co maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.co`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1293.7000122070312);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.co:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.co minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.co`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-706.2999877929688);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.co:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.no2` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.no2`)) {\n                    const value = ld.get(responseData, `current.air_quality.no2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.no2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.no2 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.no2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1018.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.no2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.no2 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.no2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.no2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.o3` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.o3`)) {\n                    const value = ld.get(responseData, `current.air_quality.o3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.o3:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.o3 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.o3`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1234.6000061035156);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.o3:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.o3 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.o3`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-765.3999938964844);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.o3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.so2` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.so2`)) {\n                    const value = ld.get(responseData, `current.air_quality.so2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.so2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.so2 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.so2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.so2:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.so2 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.so2`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-988);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.so2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.pm2_5` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.pm2_5`)) {\n                    const value = ld.get(responseData, `current.air_quality.pm2_5`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.pm2_5:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm2_5 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm2_5`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1013.6000003814697);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.pm2_5:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm2_5 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm2_5`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-986.3999996185303);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.pm2_5:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.pm10` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.pm10`)) {\n                    const value = ld.get(responseData, `current.air_quality.pm10`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.pm10:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm10 maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm10`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.pm10:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.pm10 minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.pm10`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.pm10:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.us-epa-index` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.us-epa-index`)) {\n                    const value = ld.get(responseData, `current.air_quality.us-epa-index`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.us-epa-index maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.us-epa-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.us-epa-index minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.us-epa-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.us-epa-index:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `current.air_quality.gb-defra-index` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`current.air_quality.gb-defra-index`)) {\n                    const value = ld.get(responseData, `current.air_quality.gb-defra-index`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.gb-defra-index maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.gb-defra-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1002);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n  \n        pm.test('current.air_quality.gb-defra-index minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `current.air_quality.gb-defra-index`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-998);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for current.air_quality.gb-defra-index:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast`)) {\n                    const value = ld.get(jsonResponse, `forecast`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field forecast:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast.forecastday` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    const value = ld.get(jsonResponse, `forecast.forecastday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    let forecastdayArray = ld.get(jsonResponse, `forecast.forecastday`, []);\n                    if (Array.isArray(forecastdayArray)) {\n                        for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                            let iterator = forecastday_it;\n                            if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].date' has 'date' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date format to be date',function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date format for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'date_epoch' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316896000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day' has 'day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1035.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-964.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1096.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-903.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1026.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-973.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1079.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-920.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1087.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-912.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_mph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012.8);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-987.2);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_kph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1020.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-979.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_mm' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_in' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_km' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_miles' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avghumidity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1053);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-947);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.text' has 'text' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.icon' has 'icon' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.code' has 'code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'uv' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro' has 'astro' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].astro:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunrise' has 'sunrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunset' has 'sunset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonrise' has 'moonrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonset' has 'moonset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_phase' has 'moon_phase' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_illumination' has 'moon_illumination' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'hour' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday[${forecastday_it}].hour field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday[${forecastday_it}].hour`)) {\n                    let hourArray = ld.get(jsonResponse, `forecast.forecastday[${forecastday_it}].hour`, []);\n                    if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                            let iterator = hour_it;\n                            if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch' has 'time_epoch' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316924800);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time' has 'time' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c' has 'temp_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f' has 'temp_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day' has 'is_day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph' has 'wind_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph' has 'wind_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree' has 'wind_degree' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1265);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-735);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir' has 'wind_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb' has 'pressure_mb' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in' has 'pressure_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.73);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.27);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm' has 'precip_mm' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in' has 'precip_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity' has 'humidity' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1058);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-942);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud' has 'cloud' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c' has 'feelslike_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f' has 'feelslike_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c' has 'windchill_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f' has 'windchill_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c' has 'heatindex_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f' has 'heatindex_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c' has 'dewpoint_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-980.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f' has 'dewpoint_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1067.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-932.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain' has 'will_it_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain' has 'chance_of_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow' has 'will_it_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow' has 'chance_of_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km' has 'vis_km' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles' has 'vis_miles' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph' has 'gust_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph' has 'gust_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv' has 'uv' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `alerts` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`alerts`)) {\n                    const value = ld.get(jsonResponse, `alerts`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field alerts:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `alerts.alert` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`alerts.alert`)) {\n                    const value = ld.get(jsonResponse, `alerts.alert`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field alerts.alert:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for alerts.alert:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for alerts.alert:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the alerts.alert field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`alerts.alert`)) {\n                    let alertArray = ld.get(jsonResponse, `alerts.alert`, []);\n                    if (Array.isArray(alertArray)) {\n                        for (let alert_it = 0; alert_it < alertArray.length; alert_it++) {\n                            let iterator = alert_it;\n                            if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].headline' has 'headline' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].headline`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].headline:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].headline length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].headline`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].headline:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].headline length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].headline`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].headline:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].msgtype' has 'msgtype' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].msgtype`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].msgtype:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].msgtype length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].msgtype`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].msgtype:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].msgtype length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].msgtype`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].msgtype:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].severity' has 'severity' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].severity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].severity:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].severity length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].severity`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].severity:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].severity length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].severity`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].severity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].urgency' has 'urgency' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].urgency`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].urgency:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].urgency length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].urgency`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].urgency:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].urgency length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].urgency`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].urgency:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].areas' has 'areas' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].areas`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].areas:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].areas length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].areas`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].areas:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].areas length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].areas`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].areas:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].category' has 'category' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].category`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].category:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].category length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].category`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].category:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].category length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].category`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].category:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].certainty' has 'certainty' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].certainty`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].certainty:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].certainty length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].certainty`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].certainty:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].certainty length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].certainty`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].certainty:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].event' has 'event' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].event`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].event:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].event length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].event`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].event:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].event length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].event`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].event:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].note' has 'note' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].note`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].note:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].note length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].note`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].note:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].note length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].note`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].note:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].effective' has 'effective' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].effective`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].effective:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].effective length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].effective`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].effective:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].effective length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].effective`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].effective:\", error.message);\n            }\n        })\n  \n        pm.test('alerts.alert[${alert_it}].effective format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].effective`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for alerts.alert[${alert_it}].effective:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].expires' has 'expires' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].expires`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].expires:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].expires length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].expires`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].expires:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].expires length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].expires`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].expires:\", error.message);\n            }\n        })\n  \n        pm.test('alerts.alert[${alert_it}].expires format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].expires`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for alerts.alert[${alert_it}].expires:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].desc' has 'desc' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].desc`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].desc:\", error.message);\n            }\n        })\n\n  \n        pm.test(`alerts.alert[${alert_it}].desc length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].desc`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for alerts.alert[${alert_it}].desc:\", error.message);\n            }\n        })\n  \n        pm.test(`alerts.alert[${alert_it}].desc length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `alerts.alert[${alert_it}].desc`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for alerts.alert[${alert_it}].desc:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'alerts.alert[${alert_it}].instruction' has 'instruction' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `alerts.alert[${alert_it}].instruction`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for alerts.alert[${alert_it}].instruction:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for alerts.alert:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Future API",
      "request": {
        "name": "Future API",
        "description": {
          "content": "Future weather API method returns weather in a 3 hourly interval in future for a date between 14 days and 365 days from today in the future.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "future.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "Date should be between 14 days and 300 days from today in the future in yyyy-MM-dd format (i.e. dt=2023-01-01)"
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "future.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"forecast\": {\n    \"forecastday\": [\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"dolore aliqua laborum fugiat\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      },\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"reprehender\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      }\n    ]\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "future.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "future.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "future.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for future.json?q={{q}}&dt={{dt}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast`)) {\n                    const value = ld.get(jsonResponse, `forecast`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field forecast:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast.forecastday` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    const value = ld.get(jsonResponse, `forecast.forecastday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    let forecastdayArray = ld.get(jsonResponse, `forecast.forecastday`, []);\n                    if (Array.isArray(forecastdayArray)) {\n                        for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                            let iterator = forecastday_it;\n                            if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].date' has 'date' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date format to be date',function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date format for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'date_epoch' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316896000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day' has 'day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1035.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-964.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1096.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-903.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1026.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-973.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1079.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-920.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1087.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-912.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_mph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012.8);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-987.2);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_kph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1020.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-979.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_mm' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_in' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_km' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_miles' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avghumidity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1053);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-947);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.text' has 'text' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.icon' has 'icon' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.code' has 'code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'uv' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro' has 'astro' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].astro:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunrise' has 'sunrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunset' has 'sunset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonrise' has 'moonrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonset' has 'moonset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_phase' has 'moon_phase' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_illumination' has 'moon_illumination' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'hour' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday[${forecastday_it}].hour field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday[${forecastday_it}].hour`)) {\n                    let hourArray = ld.get(jsonResponse, `forecast.forecastday[${forecastday_it}].hour`, []);\n                    if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                            let iterator = hour_it;\n                            if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch' has 'time_epoch' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316924800);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time' has 'time' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c' has 'temp_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f' has 'temp_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day' has 'is_day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph' has 'wind_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph' has 'wind_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree' has 'wind_degree' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1265);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-735);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir' has 'wind_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb' has 'pressure_mb' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in' has 'pressure_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.73);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.27);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm' has 'precip_mm' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in' has 'precip_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity' has 'humidity' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1058);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-942);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud' has 'cloud' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c' has 'feelslike_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f' has 'feelslike_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c' has 'windchill_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f' has 'windchill_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c' has 'heatindex_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f' has 'heatindex_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c' has 'dewpoint_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-980.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f' has 'dewpoint_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1067.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-932.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain' has 'will_it_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain' has 'chance_of_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow' has 'will_it_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow' has 'chance_of_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km' has 'vis_km' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles' has 'vis_miles' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph' has 'gust_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph' has 'gust_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv' has 'uv' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "History API",
      "request": {
        "name": "History API",
        "description": {
          "content": "History weather API method returns historical weather for a date on or after 1st Jan, 2010 as json. The data is returned as a Forecast Object.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "history.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "(Required) Date on or after 1st Jan, 2015 in yyyy-MM-dd format"
            },
            {
              "disabled": false,
              "key": "unixdt",
              "value": "{{unixdt}}",
              "description": "Please either pass 'dt' or 'unixdt' and not both in same request.<br />unixdt should be on or after 1st Jan, 2015 in Unix format"
            },
            {
              "disabled": false,
              "key": "end_dt",
              "value": "{{end_dt}}",
              "description": "Date on or after 1st Jan, 2015 in yyyy-MM-dd format<br />'end_dt' should be greater than 'dt' parameter and difference should not be more than 30 days between the two dates."
            },
            {
              "disabled": false,
              "key": "unixend_dt",
              "value": "{{unixend_dt}}",
              "description": "Date on or after 1st Jan, 2015 in Unix Timestamp format<br />unixend_dt has same restriction as 'end_dt' parameter. Please either pass 'end_dt' or 'unixend_dt' and not both in same request. e.g. unixend_dt=1490227200"
            },
            {
              "disabled": false,
              "key": "hour",
              "value": "{{hour}}",
              "description": "Must be in 24 hour. For example 5 pm should be hour=17, 6 am as hour=6"
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "history.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "end_dt",
                  "value": "{{end_dt}}"
                },
                {
                  "key": "unixend_dt",
                  "value": "{{unixend_dt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"forecast\": {\n    \"forecastday\": [\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"dolore aliqua laborum fugiat\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      },\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"reprehender\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      }\n    ]\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "history.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "end_dt",
                  "value": "{{end_dt}}"
                },
                {
                  "key": "unixend_dt",
                  "value": "{{unixend_dt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "history.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "end_dt",
                  "value": "{{end_dt}}"
                },
                {
                  "key": "unixend_dt",
                  "value": "{{unixend_dt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "history.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "end_dt",
                  "value": "{{end_dt}}"
                },
                {
                  "key": "unixend_dt",
                  "value": "{{unixend_dt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast`)) {\n                    const value = ld.get(jsonResponse, `forecast`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field forecast:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast.forecastday` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    const value = ld.get(jsonResponse, `forecast.forecastday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    let forecastdayArray = ld.get(jsonResponse, `forecast.forecastday`, []);\n                    if (Array.isArray(forecastdayArray)) {\n                        for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                            let iterator = forecastday_it;\n                            if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].date' has 'date' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date format to be date',function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date format for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'date_epoch' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316896000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day' has 'day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1035.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-964.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1096.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-903.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1026.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-973.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1079.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-920.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1087.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-912.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_mph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012.8);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-987.2);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_kph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1020.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-979.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_mm' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_in' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_km' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_miles' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avghumidity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1053);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-947);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.text' has 'text' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.icon' has 'icon' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.code' has 'code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'uv' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro' has 'astro' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].astro:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunrise' has 'sunrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunset' has 'sunset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonrise' has 'moonrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonset' has 'moonset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_phase' has 'moon_phase' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_illumination' has 'moon_illumination' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'hour' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday[${forecastday_it}].hour field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday[${forecastday_it}].hour`)) {\n                    let hourArray = ld.get(jsonResponse, `forecast.forecastday[${forecastday_it}].hour`, []);\n                    if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                            let iterator = hour_it;\n                            if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch' has 'time_epoch' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316924800);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time' has 'time' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c' has 'temp_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f' has 'temp_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day' has 'is_day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph' has 'wind_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph' has 'wind_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree' has 'wind_degree' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1265);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-735);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir' has 'wind_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb' has 'pressure_mb' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in' has 'pressure_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.73);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.27);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm' has 'precip_mm' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in' has 'precip_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity' has 'humidity' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1058);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-942);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud' has 'cloud' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c' has 'feelslike_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f' has 'feelslike_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c' has 'windchill_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f' has 'windchill_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c' has 'heatindex_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f' has 'heatindex_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c' has 'dewpoint_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-980.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f' has 'dewpoint_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1067.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-932.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain' has 'will_it_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain' has 'chance_of_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow' has 'will_it_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow' has 'chance_of_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km' has 'vis_km' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles' has 'vis_miles' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph' has 'gust_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph' has 'gust_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv' has 'uv' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Marine Weather API",
      "request": {
        "name": "Marine Weather API",
        "description": {
          "content": "Marine weather API method returns upto next 7 day (depending upon your price plan level) marine and sailing weather forecast and tide data (depending upon your price plan level) as json or xml. The data is returned as a Marine Object.<br /><br />Marine object, depending upon your price plan level, contains astronomy data, day weather forecast and hourly interval weather information and tide data for a given sea/ocean point.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "marine.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass Latitude/Longitude (decimal degree) which is on a sea/ocean. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "days",
              "value": "{{days}}",
              "description": "(Required) Number of days of weather forecast. Value ranges from 1 to 7"
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "Date should be between today and next 7 day in yyyy-MM-dd format. e.g. '2023-05-20'"
            },
            {
              "disabled": false,
              "key": "unixdt",
              "value": "{{unixdt}}",
              "description": "Please either pass 'dt' or 'unixdt' and not both in same request. unixdt should be between today and next 7 day in Unix format. e.g. 1490227200"
            },
            {
              "disabled": false,
              "key": "hour",
              "value": "{{hour}}",
              "description": "Must be in 24 hour. For example 5 pm should be hour=17, 6 am as hour=6"
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "marine.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"forecast\": {\n    \"forecastday\": [\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"quis consectetur\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"sig_ht_mt\": 24.1,\n            \"swell_ht_mt\": 24.1,\n            \"swell_ht_ft\": 24.1,\n            \"swell_dir\": 24.1,\n            \"swell_dir_16_point\": 24.1,\n            \"swell_period_secs\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"sig_ht_mt\": 24.1,\n            \"swell_ht_mt\": 24.1,\n            \"swell_ht_ft\": 24.1,\n            \"swell_dir\": 24.1,\n            \"swell_dir_16_point\": 24.1,\n            \"swell_period_secs\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      },\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"tempor nisi eiusmod\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"sig_ht_mt\": 24.1,\n            \"swell_ht_mt\": 24.1,\n            \"swell_ht_ft\": 24.1,\n            \"swell_dir\": 24.1,\n            \"swell_dir_16_point\": 24.1,\n            \"swell_period_secs\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"sig_ht_mt\": 24.1,\n            \"swell_ht_mt\": 24.1,\n            \"swell_ht_ft\": 24.1,\n            \"swell_dir\": 24.1,\n            \"swell_dir_16_point\": 24.1,\n            \"swell_period_secs\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      }\n    ]\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "marine.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "marine.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "marine.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast`)) {\n                    const value = ld.get(jsonResponse, `forecast`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field forecast:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `forecast.forecastday` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    const value = ld.get(jsonResponse, `forecast.forecastday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday`)) {\n                    let forecastdayArray = ld.get(jsonResponse, `forecast.forecastday`, []);\n                    if (Array.isArray(forecastdayArray)) {\n                        for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                            let iterator = forecastday_it;\n                            if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].date' has 'date' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].date length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date format to be date',function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date format for forecast.forecastday[${forecastday_it}].date:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'date_epoch' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].date_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].date_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316896000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].date_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day' has 'day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1035.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-964.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1096.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-903.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1026.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-973.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'mintemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1079.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.mintemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.mintemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-920.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.mintemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_c' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgtemp_f' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1087.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgtemp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgtemp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-912.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgtemp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_mph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1012.8);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-987.2);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'maxwind_kph' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1020.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.maxwind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.maxwind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-979.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.maxwind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_mm' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'totalprecip_in' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.totalprecip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.totalprecip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.totalprecip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_km' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avgvis_miles' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avgvis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avgvis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avgvis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'avghumidity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1053);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.avghumidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.avghumidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-947);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.avghumidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_rain' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_will_it_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'daily_chance_of_snow' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.daily_chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.text' has 'text' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.icon' has 'icon' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].day.condition.icon length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.condition.icon`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].day.condition.icon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].day.condition.code' has 'code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.condition.code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.condition.code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.condition.code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'uv' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1008);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].day.uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].day.uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-992);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].day.uv:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro' has 'astro' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].astro:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunrise' has 'sunrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.sunset' has 'sunset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonrise' has 'moonrise' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moonset' has 'moonset' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_phase' has 'moon_phase' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].astro.moon_illumination' has 'moon_illumination' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].astro.moon_illumination:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecastdayArray' has 'hour' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the forecast.forecastday[${forecastday_it}].hour field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`forecast.forecastday[${forecastday_it}].hour`)) {\n                    let hourArray = ld.get(jsonResponse, `forecast.forecastday[${forecastday_it}].hour`, []);\n                    if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                            let iterator = hour_it;\n                            if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch' has 'time_epoch' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3316924800);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time_epoch:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].time' has 'time' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].time length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].time`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].time:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c' has 'temp_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f' has 'temp_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].temp_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day' has 'is_day' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].is_day:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition' has 'condition' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].condition:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph' has 'wind_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1009.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph' has 'wind_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-984.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree' has 'wind_degree' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1265);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-735);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_degree:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir' has 'wind_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n  \n        pm.test(`forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for forecast.forecastday[${forecastday_it}].hour[${hour_it}].wind_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb' has 'pressure_mb' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_mb:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in' has 'pressure_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1029.73);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-970.27);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].pressure_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm' has 'precip_mm' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_mm:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in' has 'precip_in' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].precip_in:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity' has 'humidity' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1058);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-942);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].humidity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud' has 'cloud' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-981);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].cloud:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c' has 'feelslike_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f' has 'feelslike_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].feelslike_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c' has 'windchill_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1028.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-971.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f' has 'windchill_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1083.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-916.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].windchill_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c' has 'heatindex_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1030.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-969.5);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f' has 'heatindex_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1086.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-913.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].heatindex_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c' has 'dewpoint_c' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1019.6);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-980.4);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_c:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f' has 'dewpoint_f' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1067.3);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-932.7);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].dewpoint_f:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain' has 'will_it_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain' has 'chance_of_rain' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_rain:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow' has 'will_it_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].will_it_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow' has 'chance_of_snow' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].chance_of_snow:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km' has 'vis_km' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1010);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-990);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_km:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles' has 'vis_miles' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-994);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].vis_miles:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph' has 'gust_mph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1015);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-985);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_mph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph' has 'gust_kph' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].gust_kph:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt' has 'sig_ht_mt' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].sig_ht_mt:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt' has 'swell_ht_mt' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_mt:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft' has 'swell_ht_ft' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_ht_ft:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir' has 'swell_dir' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point' has 'swell_dir_16_point' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_dir_16_point:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs' has 'swell_period_secs' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1024.1);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-975.9);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].swell_period_secs:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv' has 'uv' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n  \n        pm.test('forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for forecast.forecastday[${forecastday_it}].hour[${hour_it}].uv:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday[${forecastday_it}].hour:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for forecast.forecastday:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Search/Autocomplete API",
      "request": {
        "name": "Search/Autocomplete API",
        "description": {
          "content": "WeatherAPI.com Search or Autocomplete API returns matching cities and towns as an array of Location object.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "search.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "search.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"id\": 2796590,\n    \"name\": \"Holborn\",\n    \"region\": \"Camden Greater London\",\n    \"country\": \"United Kingdom\",\n    \"lat\": 51.52,\n    \"lon\": -0.12,\n    \"url\": \"holborn-camden-greater-london-united-kingdom\"\n  },\n  {\n    \"id\": 2796590,\n    \"name\": \"Holborn\",\n    \"region\": \"Camden Greater London\",\n    \"country\": \"United Kingdom\",\n    \"lat\": 51.52,\n    \"lon\": -0.12,\n    \"url\": \"holborn-camden-greater-london-united-kingdom\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "search.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "search.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "search.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for search.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response is an array\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n                    pm.expect(Array.isArray(responseData)).to.be.true;\n                }\n            } catch (error) {\n                console.error('Error validating array response:', error.message);\n            }\n        });\n        pm.test(\"Each array item has correct structure\", function () {\n            try {\n                if (responseData && Array.isArray(responseData) && responseData.length > 0) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test(`${iterator} element of array 'responseData' has 'id' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `item.id`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for item.id:\", error.message);\n            }\n        })\n  \n        pm.test('item.id maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.id`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(5593180);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for item.id:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'item.name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `item.name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for item.name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`item.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `item.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for item.name:\", error.message);\n            }\n        })\n  \n        pm.test(`item.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `item.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for item.name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'item.region' has 'region' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `item.region`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for item.region:\", error.message);\n            }\n        })\n\n  \n        pm.test(`item.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `item.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for item.region:\", error.message);\n            }\n        })\n  \n        pm.test(`item.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `item.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for item.region:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'item.country' has 'country' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `item.country`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for item.country:\", error.message);\n            }\n        })\n\n  \n        pm.test(`item.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `item.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for item.country:\", error.message);\n            }\n        })\n  \n        pm.test(`item.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `item.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for item.country:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'responseData' has 'lat' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `item.lat`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for item.lat:\", error.message);\n            }\n        })\n  \n        pm.test('item.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1051.52);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for item.lat:\", error.message);\n            }\n        })\n  \n        pm.test('item.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-948.48);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for item.lat:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'responseData' has 'lon' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `item.lon`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for item.lon:\", error.message);\n            }\n        })\n  \n        pm.test('item.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(999.88);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for item.lon:\", error.message);\n            }\n        })\n  \n        pm.test('item.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `item.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000.12);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for item.lon:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'item.url' has 'url' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `item.url`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for item.url:\", error.message);\n            }\n        })\n\n  \n        pm.test(`item.url length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `item.url`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for item.url:\", error.message);\n            }\n        })\n  \n        pm.test(`item.url length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `item.url`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for item.url:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            } catch (error) {\n                console.error('Error validating array item structure:', error.message);\n            }\n        });\n        pm.test(\"Array has minimum required items\", function () {\n            try {\n                if (responseData && Array.isArray(responseData)) {\n                    pm.expect(responseData.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.error('Error checking minimum array items:', error.message);\n            }\n        });\n        pm.test(\"Array does not exceed maximum items\", function () {\n            try {\n                if (responseData && Array.isArray(responseData)) {\n                    pm.expect(responseData.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.error('Error checking maximum array items:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "IP Lookup API",
      "request": {
        "name": "IP Lookup API",
        "description": {
          "content": "IP Lookup API method allows a user to get up to date information for an IP address.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "ip.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass IP address."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "ip.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"ip\": \"185.249.71.82\",\n  \"type\": \"ipv4\",\n  \"continent_code\": \"EU\",\n  \"continent_name\": \"Europe\",\n  \"country_code\": \"GB\",\n  \"country_name\": \"United Kingdom\",\n  \"is_eu\": \"ut commodo nisi in ea\",\n  \"geoname_id\": 2643743,\n  \"city\": \"London\",\n  \"region\": \"id laboris ipsum voluptate\",\n  \"lat\": 51.5264,\n  \"lon\": -0.0841,\n  \"tz_id\": \"Europe/London\",\n  \"localtime_epoch\": 1658520645,\n  \"localtime\": \"2022-07-22 21:10\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "ip.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "ip.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "ip.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for ip.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `ip` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`ip`)) {\n                    const value = ld.get(jsonResponse, `ip`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field ip:\", error.message);\n            }\n        })\n  \n        pm.test(`ip length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `ip`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for ip:\", error.message);\n            }\n        })\n  \n        pm.test(`ip length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `ip`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for ip:\", error.message);\n            }\n        })\n\n        pm.test('ip format to be ipv4',function(){  \n            try {\n                const value = ld.get(responseData, `ip`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(d{1,3}.){3}d{1,3}$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking IPv4 format for ip:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`type`)) {\n                    const value = ld.get(jsonResponse, `type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field type:\", error.message);\n            }\n        })\n  \n        pm.test(`type length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for type:\", error.message);\n            }\n        })\n  \n        pm.test(`type length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `continent_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`continent_code`)) {\n                    const value = ld.get(jsonResponse, `continent_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field continent_code:\", error.message);\n            }\n        })\n  \n        pm.test(`continent_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `continent_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for continent_code:\", error.message);\n            }\n        })\n  \n        pm.test(`continent_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `continent_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for continent_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `continent_name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`continent_name`)) {\n                    const value = ld.get(jsonResponse, `continent_name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field continent_name:\", error.message);\n            }\n        })\n  \n        pm.test(`continent_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `continent_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for continent_name:\", error.message);\n            }\n        })\n  \n        pm.test(`continent_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `continent_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for continent_name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country_code`)) {\n                    const value = ld.get(jsonResponse, `country_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country_code:\", error.message);\n            }\n        })\n  \n        pm.test(`country_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `country_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for country_code:\", error.message);\n            }\n        })\n  \n        pm.test(`country_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `country_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for country_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country_name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country_name`)) {\n                    const value = ld.get(jsonResponse, `country_name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`country_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`country_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for country_name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `is_eu` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`is_eu`)) {\n                    const value = ld.get(jsonResponse, `is_eu`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field is_eu:\", error.message);\n            }\n        })\n  \n        pm.test(`is_eu length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `is_eu`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for is_eu:\", error.message);\n            }\n        })\n  \n        pm.test(`is_eu length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `is_eu`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for is_eu:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `geoname_id` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`geoname_id`)) {\n                    const value = ld.get(responseData, `geoname_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field geoname_id:\", error.message);\n            }\n        })\n  \n        pm.test('geoname_id maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `geoname_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(5287486);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for geoname_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `city` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`city`)) {\n                    const value = ld.get(jsonResponse, `city`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field city:\", error.message);\n            }\n        })\n  \n        pm.test(`city length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `city`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for city:\", error.message);\n            }\n        })\n  \n        pm.test(`city length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `city`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for city:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`region`)) {\n                    const value = ld.get(jsonResponse, `region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field region:\", error.message);\n            }\n        })\n  \n        pm.test(`region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for region:\", error.message);\n            }\n        })\n  \n        pm.test(`region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lat`)) {\n                    const value = ld.get(responseData, `lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lat:\", error.message);\n            }\n        })\n  \n        pm.test('lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1051.5264);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for lat:\", error.message);\n            }\n        })\n  \n        pm.test('lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-948.4736);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lon`)) {\n                    const value = ld.get(responseData, `lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lon:\", error.message);\n            }\n        })\n  \n        pm.test('lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(999.9159);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for lon:\", error.message);\n            }\n        })\n  \n        pm.test('lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1000.0841);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`tz_id`)) {\n                    const value = ld.get(jsonResponse, `tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`localtime_epoch`)) {\n                    const value = ld.get(responseData, `localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317041290);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`localtime`)) {\n                    const value = ld.get(jsonResponse, `localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for localtime:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Time Zone API",
      "request": {
        "name": "Time Zone API",
        "description": {
          "content": "Return Location Object",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "timezone.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "timezone.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"name\": \"New York\",\n  \"region\": \"New York\",\n  \"country\": \"United States of America\",\n  \"lat\": 40.71,\n  \"lon\": -74.01,\n  \"tz_id\": \"America/New_York\",\n  \"localtime_epoch\": 1658522976,\n  \"localtime\": \"2022-07-22 16:49\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "timezone.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "timezone.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "timezone.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for timezone.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n  \n        pm.test(`name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for name:\", error.message);\n            }\n        })\n  \n        pm.test(`name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`region`)) {\n                    const value = ld.get(jsonResponse, `region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field region:\", error.message);\n            }\n        })\n  \n        pm.test(`region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for region:\", error.message);\n            }\n        })\n  \n        pm.test(`region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country`)) {\n                    const value = ld.get(jsonResponse, `country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country:\", error.message);\n            }\n        })\n  \n        pm.test(`country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for country:\", error.message);\n            }\n        })\n  \n        pm.test(`country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lat`)) {\n                    const value = ld.get(responseData, `lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lat:\", error.message);\n            }\n        })\n  \n        pm.test('lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for lat:\", error.message);\n            }\n        })\n  \n        pm.test('lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lon`)) {\n                    const value = ld.get(responseData, `lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lon:\", error.message);\n            }\n        })\n  \n        pm.test('lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for lon:\", error.message);\n            }\n        })\n  \n        pm.test('lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`tz_id`)) {\n                    const value = ld.get(jsonResponse, `tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`localtime_epoch`)) {\n                    const value = ld.get(responseData, `localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`localtime`)) {\n                    const value = ld.get(jsonResponse, `localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for localtime:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Astronomy API",
      "request": {
        "name": "Astronomy API",
        "description": {
          "content": "Return Location and Astronomy Object",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "astronomy.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "(Required) Date on or after 1st Jan, 2015 in yyyy-MM-dd format"
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "astronomy.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"astronomy\": {\n    \"astro\": {\n      \"sunrise\": \"05:10 AM\",\n      \"sunset\": \"09:03 PM\",\n      \"moonrise\": \"12:29 AM\",\n      \"moonset\": \"04:01 PM\",\n      \"moon_phase\": \"Third Quarter\",\n      \"moon_illumination\": \"nulla laboris non labore\"\n    }\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "astronomy.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "astronomy.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "astronomy.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test Arie-API-Test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for astronomy.json?q={{q}}&dt={{dt}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Ok\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.name`)) {\n                    const value = ld.get(jsonResponse, `location.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.name:\", error.message);\n            }\n        })\n  \n        pm.test(`location.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.region`)) {\n                    const value = ld.get(jsonResponse, `location.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.region:\", error.message);\n            }\n        })\n  \n        pm.test(`location.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.country`)) {\n                    const value = ld.get(jsonResponse, `location.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.country:\", error.message);\n            }\n        })\n  \n        pm.test(`location.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lat` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lat`)) {\n                    const value = ld.get(responseData, `location.lat`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040.71);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lat:\", error.message);\n            }\n        })\n  \n        pm.test('location.lat minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lat`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-959.29);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lat:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.lon` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.lon`)) {\n                    const value = ld.get(responseData, `location.lon`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(925.99);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.lon:\", error.message);\n            }\n        })\n  \n        pm.test('location.lon minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.lon`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-1074.01);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for location.lon:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.tz_id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.tz_id`)) {\n                    const value = ld.get(jsonResponse, `location.tz_id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.tz_id:\", error.message);\n            }\n        })\n  \n        pm.test(`location.tz_id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.tz_id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.tz_id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime_epoch` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`location.localtime_epoch`)) {\n                    const value = ld.get(responseData, `location.localtime_epoch`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field location.localtime_epoch:\", error.message);\n            }\n        })\n  \n        pm.test('location.localtime_epoch maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `location.localtime_epoch`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(3317045952);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for location.localtime_epoch:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location.localtime` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location.localtime`)) {\n                    const value = ld.get(jsonResponse, `location.localtime`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for location.localtime:\", error.message);\n            }\n        })\n  \n        pm.test(`location.localtime length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `location.localtime`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for location.localtime:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy`)) {\n                    const value = ld.get(jsonResponse, `astronomy`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field astronomy:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field astronomy.astro:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.sunrise` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.sunrise`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.sunrise`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.sunrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.sunrise:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.sunrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.sunrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.sunrise:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.sunset` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.sunset`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.sunset`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.sunset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.sunset:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.sunset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.sunset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.sunset:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.moonrise` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.moonrise`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.moonrise`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moonrise length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.moonrise:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moonrise length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moonrise`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.moonrise:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.moonset` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.moonset`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.moonset`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moonset length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.moonset:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moonset length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moonset`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.moonset:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.moon_phase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.moon_phase`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.moon_phase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moon_phase length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.moon_phase:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moon_phase length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moon_phase`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.moon_phase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `astronomy.astro.moon_illumination` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`astronomy.astro.moon_illumination`)) {\n                    const value = ld.get(jsonResponse, `astronomy.astro.moon_illumination`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field astronomy.astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moon_illumination length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for astronomy.astro.moon_illumination:\", error.message);\n            }\n        })\n  \n        pm.test(`astronomy.astro.moon_illumination length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `astronomy.astro.moon_illumination`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for astronomy.astro.moon_illumination:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2006);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(2004);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `code` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`code`)) {\n                    const value = ld.get(responseData, `code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field code:\", error.message);\n            }\n        })\n  \n        pm.test('code maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `code`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(4014);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://api.weatherapi.com/v1",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "info": {
    "_postman_id": "12bdc242-1fbc-4393-8e9e-f2a81ae86b4b",
    "name": "Weather API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "# Introduction\nWeatherAPI.com provides access to weather and geo data via a JSON/XML restful API. It allows developers to create desktop, web and mobile applications using this data very easy. We provide following data through our API:    \n- Real-time weather\n- 14 day weather forecast\n- Historical Weather\n- Marine Weather and Tide Data\n- Future Weather (Upto 365 days ahead)\n- Daily and hourly intervals\n- 15 min interval (Enterprise only)\n- Astronomy\n- Time zone\n- Location data\n- Sports\n- Search or Autocomplete API\n- Weather Alerts\n- Air Quality Data\n- Bulk Request\n\n# Getting Started  \n\nYou need to [signup](https://www.weatherapi.com/signup.aspx) and then you can find your API key under [your account](https://www.weatherapi.com/login.aspx), and start using API right away!\n\nTry our weather API by using interactive [API Explorer](https://www.weatherapi.com/api-explorer.aspx).\n\nWe also have SDK for popular framework/languages available on [Github](https://github.com/weatherapicom/) for quick integrations.\n\nIf you find any features missing or have any suggestions, please [contact us](https://www.weatherapi.com/contact.aspx).  \n\n# Authentication  \n\nAPI access to the data is protected by an API key. If at anytime, you find the API key has become vulnerable, please regenerate the key using Regenerate button next to the API key.  \n\nAuthentication to the WeatherAPI.com API is provided by passing your API key as request parameter through an API .    \n\n##  key parameter \nkey=YOUR API KEY",
      "type": "text/plain"
    }
  }
}