{
  "item": [
    {
      "name": "v2",
      "item": [
        {
          "name": "users",
          "item": [
            null,
            null
          ],
          "event": []
        },
        null,
        {
          "name": "access-tokens",
          "item": [
            null,
            null,
            {
              "name": "{uuid}",
              "item": [
                null,
                null,
                null
              ],
              "event": []
            }
          ],
          "event": []
        },
        {
          "name": "auditlogs/{account}",
          "item": [
            null,
            null
          ],
          "event": []
        },
        {
          "name": "orgs",
          "item": [
            {
              "name": "{name}",
              "item": [
                {
                  "name": "settings",
                  "item": [
                    null,
                    null
                  ],
                  "event": []
                },
                {
                  "name": "access-tokens",
                  "item": [
                    null,
                    null
                  ],
                  "event": []
                }
              ],
              "event": []
            },
            {
              "name": "{org_name}",
              "item": [
                {
                  "name": "access-tokens/{access_token_id}",
                  "item": [
                    null,
                    null,
                    null
                  ],
                  "event": []
                },
                {
                  "name": "members",
                  "item": [
                    null,
                    null,
                    {
                      "name": "{username}",
                      "item": [
                        null,
                        null
                      ],
                      "event": []
                    }
                  ],
                  "event": []
                },
                null,
                {
                  "name": "groups",
                  "item": [
                    null,
                    null,
                    {
                      "name": "{group_name}",
                      "item": [
                        null,
                        null,
                        null,
                        null,
                        {
                          "name": "members",
                          "item": [
                            null,
                            null,
                            null
                          ],
                          "event": []
                        }
                      ],
                      "event": []
                    }
                  ],
                  "event": []
                }
              ],
              "event": []
            }
          ],
          "event": []
        },
        {
          "name": "namespaces/{namespace}/repositories",
          "item": [
            {
              "name": "List repositories in a namespace",
              "request": {
                "name": "List repositories in a namespace",
                "description": {
                  "content": "Returns a list of repositories within the specified namespace (organization or user).\n\nPublic repositories are accessible to everyone, while private repositories require appropriate authentication and permissions.",
                  "type": "text/plain"
                },
                "url": {
                  "path": [
                    "v2",
                    "namespaces",
                    ":namespace",
                    "repositories"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "disabled": false,
                      "key": "page",
                      "value": "{{page}}",
                      "description": "Page number to get. Defaults to 1."
                    },
                    {
                      "disabled": false,
                      "key": "page_size",
                      "value": "{{page_size}}",
                      "description": "Number of repositories to get per page. Defaults to 10. Max of 100."
                    },
                    {
                      "disabled": false,
                      "key": "name",
                      "value": "{{name}}",
                      "description": "Filter repositories by name (partial match)."
                    },
                    {
                      "disabled": false,
                      "key": "ordering",
                      "value": "{{ordering}}",
                      "description": "Order repositories by the specified field. Prefix with '-' for descending order.\nAvailable options:\n- `name` / `-name`: Repository name (ascending/descending)\n- `last_updated` / `-last_updated`: Last update time (ascending/descending)\n- `pull_count` / `-pull_count`: Number of pulls (ascending/descending)"
                    }
                  ],
                  "variable": [
                    {
                      "disabled": false,
                      "type": "any",
                      "value": "{{namespace}}",
                      "key": "namespace",
                      "description": "(Required)"
                    }
                  ]
                },
                "header": [
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "GET",
                "auth": {
                  "type": "bearer",
                  "bearer": [
                    {
                      "key": "token",
                      "value": "{{bearerToken}}"
                    }
                  ]
                }
              },
              "response": [
                {
                  "name": "List of repositories",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "v2",
                        "namespaces",
                        ":namespace",
                        "repositories"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "page_size",
                          "value": "{{page_size}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "ordering",
                          "value": "{{ordering}}"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{namespace}}",
                          "key": "namespace",
                          "description": "(Required)"
                        }
                      ]
                    },
                    "header": [
                      {
                        "description": {
                          "content": "Added as a part of security scheme: bearer",
                          "type": "text/plain"
                        },
                        "key": "Authorization",
                        "value": "{{Authorization}}"
                      },
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "OK",
                  "code": 200,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"count\": 287,\n  \"next\": \"https://hub.docker.com/v2/namespaces/docker/repositories?page=2&page_size=2\",\n  \"previous\": null,\n  \"results\": [\n    {\n      \"name\": \"highland_builder\",\n      \"namespace\": \"docker\",\n      \"repository_type\": \"image\",\n      \"status\": 1,\n      \"status_description\": \"active\",\n      \"description\": \"Image for performing Docker build requests\",\n      \"is_private\": false,\n      \"star_count\": 7,\n      \"pull_count\": 15722123,\n      \"last_updated\": \"2023-06-20T10:44:45.459826Z\",\n      \"last_modified\": \"2024-10-16T13:48:34.145251Z\",\n      \"date_registered\": \"2015-05-19T21:13:35.937763Z\",\n      \"affiliation\": \"\",\n      \"media_types\": [\n        \"application/octet-stream\",\n        \"application/vnd.docker.container.image.v1+json\",\n        \"application/vnd.docker.distribution.manifest.v1+prettyjws\"\n      ],\n      \"content_types\": [\n        \"unrecognized\",\n        \"image\"\n      ],\n      \"categories\": [\n        {\n          \"name\": \"Languages & frameworks\",\n          \"slug\": \"languages-and-frameworks\"\n        },\n        {\n          \"name\": \"Integration & delivery\",\n          \"slug\": \"integration-and-delivery\"\n        },\n        {\n          \"name\": \"Operating systems\",\n          \"slug\": \"operating-systems\"\n        }\n      ],\n      \"storage_size\": 488723114800\n    },\n    {\n      \"name\": \"whalesay\",\n      \"namespace\": \"docker\",\n      \"repository_type\": null,\n      \"status\": 1,\n      \"status_description\": \"active\",\n      \"description\": \"An image for use in the Docker demo tutorial\",\n      \"is_private\": false,\n      \"star_count\": 757,\n      \"pull_count\": 130737682,\n      \"last_updated\": \"2015-06-19T19:06:27.388123Z\",\n      \"last_modified\": \"2024-10-16T13:48:34.145251Z\",\n      \"date_registered\": \"2015-06-09T18:16:36.527329Z\",\n      \"affiliation\": \"\",\n      \"media_types\": [\n        \"application/vnd.docker.distribution.manifest.v1+prettyjws\"\n      ],\n      \"content_types\": [\n        \"image\"\n      ],\n      \"categories\": [\n        {\n          \"name\": \"Languages & frameworks\",\n          \"slug\": \"languages-and-frameworks\"\n        },\n        {\n          \"name\": \"Integration & delivery\",\n          \"slug\": \"integration-and-delivery\"\n        }\n      ],\n      \"storage_size\": 103666708\n    }\n  ]\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                },
                {
                  "name": "Bad Request - Invalid request parameters",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "v2",
                        "namespaces",
                        ":namespace",
                        "repositories"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "page_size",
                          "value": "{{page_size}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "ordering",
                          "value": "{{ordering}}"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{namespace}}",
                          "key": "namespace",
                          "description": "(Required)"
                        }
                      ]
                    },
                    "header": [
                      {
                        "description": {
                          "content": "Added as a part of security scheme: bearer",
                          "type": "text/plain"
                        },
                        "key": "Authorization",
                        "value": "{{Authorization}}"
                      },
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "Bad Request",
                  "code": 400,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"fields\": {\n    \"ordering\": [\n      \"Invalid ordering value. Must be one of: name, -name, last_updated, -last_updated, pull_count, -pull_count\"\n    ]\n  },\n  \"text\": \"Invalid ordering value\"\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                },
                {
                  "name": "Unauthorized",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "v2",
                        "namespaces",
                        ":namespace",
                        "repositories"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "page_size",
                          "value": "{{page_size}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "ordering",
                          "value": "{{ordering}}"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{namespace}}",
                          "key": "namespace",
                          "description": "(Required)"
                        }
                      ]
                    },
                    "header": [
                      {
                        "description": {
                          "content": "Added as a part of security scheme: bearer",
                          "type": "text/plain"
                        },
                        "key": "Authorization",
                        "value": "{{Authorization}}"
                      },
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "Unauthorized",
                  "code": 401,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                },
                {
                  "name": "Forbidden",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "v2",
                        "namespaces",
                        ":namespace",
                        "repositories"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "page_size",
                          "value": "{{page_size}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "ordering",
                          "value": "{{ordering}}"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{namespace}}",
                          "key": "namespace",
                          "description": "(Required)"
                        }
                      ]
                    },
                    "header": [
                      {
                        "description": {
                          "content": "Added as a part of security scheme: bearer",
                          "type": "text/plain"
                        },
                        "key": "Authorization",
                        "value": "{{Authorization}}"
                      },
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "Forbidden",
                  "code": 403,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                },
                {
                  "name": "Page not found - occurs when requesting a page number `>1` that exceeds the available results",
                  "originalRequest": {
                    "url": {
                      "path": [
                        "v2",
                        "namespaces",
                        ":namespace",
                        "repositories"
                      ],
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "query": [
                        {
                          "key": "page",
                          "value": "{{page}}"
                        },
                        {
                          "key": "page_size",
                          "value": "{{page_size}}"
                        },
                        {
                          "key": "name",
                          "value": "{{name}}"
                        },
                        {
                          "key": "ordering",
                          "value": "{{ordering}}"
                        }
                      ],
                      "variable": [
                        {
                          "disabled": false,
                          "type": "any",
                          "value": "{{namespace}}",
                          "key": "namespace",
                          "description": "(Required)"
                        }
                      ]
                    },
                    "header": [
                      {
                        "description": {
                          "content": "Added as a part of security scheme: bearer",
                          "type": "text/plain"
                        },
                        "key": "Authorization",
                        "value": "{{Authorization}}"
                      },
                      {
                        "key": "Accept",
                        "value": "application/json"
                      }
                    ],
                    "method": "GET",
                    "body": {}
                  },
                  "status": "Not Found",
                  "code": 404,
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                  "cookie": [],
                  "_postman_previewlanguage": "json"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test dockerhub-postman-api using AI Type Open AI and AI Model gpt-5\n\n\nTest generated for v2/namespaces/{namespace}/repositories?page={{page}}&page_size={{page_size}}&name={{name}}&ordering={{ordering}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"List of repositories\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `count` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`count`)) {\n                    const value = ld.get(responseData, `count`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field count:\", error.message);\n            }\n        })\n  \n        pm.test('count maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `count`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1287);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for count:\", error.message);\n            }\n        })\n  \n        pm.test('count minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `count`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-713);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for count:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `next` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`next`)) {\n                    const value = ld.get(jsonResponse, `next`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field next:\", error.message);\n            }\n        })\n  \n        pm.test(`next length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `next`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for next:\", error.message);\n            }\n        })\n  \n        pm.test(`next length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `next`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for next:\", error.message);\n            }\n        })\n  \n        pm.test('next format to be url',function(){\n            try {\n                const value = ld.get(responseData, `next`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for next:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `previous` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`previous`)) {\n                    const value = ld.get(jsonResponse, `previous`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"null\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking null field previous:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `results` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`results`)) {\n                    const value = ld.get(jsonResponse, `results`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field results:\", error.message);\n            }\n        })\n  \n        pm.test(`results length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for results:\", error.message);\n            }\n        })\n  \n        pm.test(`results length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for results:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the results field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`results`)) {\n                    let resultsArray = ld.get(jsonResponse, `results`, []);\n                    if (Array.isArray(resultsArray)) {\n                        for (let results_it = 0; results_it < resultsArray.length; results_it++) {\n                            let iterator = results_it;\n                            if (resultsArray[results_it] !== null && resultsArray[results_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'results[${results_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].namespace' has 'namespace' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].namespace`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].namespace:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].namespace length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].namespace`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].namespace:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].namespace length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].namespace`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].namespace:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].repository_type' has 'repository_type' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].repository_type`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].repository_type:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].repository_type length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].repository_type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].repository_type:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].repository_type length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].repository_type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].repository_type:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'status' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].status`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].status:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].status maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].status`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1001);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for results[${results_it}].status:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].status minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].status`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-999);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for results[${results_it}].status:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].status_description' has 'status_description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].status_description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].status_description:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].status_description length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].status_description`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].status_description:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].status_description length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].status_description`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].status_description:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].description:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].description length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].description`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].description:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].description length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].description`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].description:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].is_private' has 'is_private' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].is_private`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for results[${results_it}].is_private:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'star_count' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].star_count`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].star_count:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].star_count maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].star_count`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1007);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for results[${results_it}].star_count:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].star_count minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].star_count`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-993);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for results[${results_it}].star_count:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'pull_count' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].pull_count`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].pull_count:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].pull_count maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].pull_count`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(31444246);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for results[${results_it}].pull_count:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].last_updated' has 'last_updated' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].last_updated`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].last_updated:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].last_updated length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].last_updated length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].last_updated:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].last_updated format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for results[${results_it}].last_updated:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].last_modified' has 'last_modified' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].last_modified`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].last_modified:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].last_modified length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_modified`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].last_modified:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].last_modified length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_modified`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].last_modified:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].last_modified format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_modified`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for results[${results_it}].last_modified:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].date_registered' has 'date_registered' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].date_registered`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].date_registered:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].date_registered length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].date_registered`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].date_registered:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].date_registered length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].date_registered`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].date_registered:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].date_registered format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].date_registered`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for results[${results_it}].date_registered:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].affiliation' has 'affiliation' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].affiliation`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].affiliation:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'media_types' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].media_types`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for results[${results_it}].media_types:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].media_types length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].media_types`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for results[${results_it}].media_types:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].media_types length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].media_types`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for results[${results_it}].media_types:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'content_types' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].content_types`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for results[${results_it}].content_types:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].content_types length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].content_types`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for results[${results_it}].content_types:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].content_types length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].content_types`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for results[${results_it}].content_types:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'categories' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].categories`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for results[${results_it}].categories:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].categories length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].categories`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for results[${results_it}].categories:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].categories length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].categories`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for results[${results_it}].categories:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the results[${results_it}].categories field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`results[${results_it}].categories`)) {\n                    let categoriesArray = ld.get(jsonResponse, `results[${results_it}].categories`, []);\n                    if (Array.isArray(categoriesArray)) {\n                        for (let categories_it = 0; categories_it < categoriesArray.length; categories_it++) {\n                            let iterator = categories_it;\n                            if (categoriesArray[categories_it] !== null && categoriesArray[categories_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'results[${results_it}].categories[${categories_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].categories[${categories_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].categories[${categories_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].categories[${categories_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].categories[${categories_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].categories[${categories_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].categories[${categories_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].categories[${categories_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].categories[${categories_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].categories[${categories_it}].slug' has 'slug' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].categories[${categories_it}].slug`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].categories[${categories_it}].slug:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].categories[${categories_it}].slug length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].categories[${categories_it}].slug`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].categories[${categories_it}].slug:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].categories[${categories_it}].slug length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].categories[${categories_it}].slug`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].categories[${categories_it}].slug:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for results[${results_it}].categories:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'storage_size' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].storage_size`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].storage_size:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].storage_size maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].storage_size`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(977446229600);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for results[${results_it}].storage_size:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for results:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Bad Request - Invalid request parameters\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `fields` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`fields`)) {\n                    const value = ld.get(jsonResponse, `fields`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field fields:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `fields.ordering` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`fields.ordering`)) {\n                    const value = ld.get(jsonResponse, `fields.ordering`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field fields.ordering:\", error.message);\n            }\n        })\n  \n        pm.test(`fields.ordering length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `fields.ordering`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for fields.ordering:\", error.message);\n            }\n        })\n  \n        pm.test(`fields.ordering length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `fields.ordering`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for fields.ordering:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `text` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`text`)) {\n                    const value = ld.get(jsonResponse, `text`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field text:\", error.message);\n            }\n        })\n  \n        pm.test(`text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for text:\", error.message);\n            }\n        })\n  \n        pm.test(`text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for text:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Unauthorized\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Forbidden\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Page not found - occurs when requesting a page number `>1` that exceeds the available results\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ],
              "protocolProfileBehavior": {
                "disableBodyPruning": true
              }
            },
            {
              "name": "{repository}",
              "item": [
                {
                  "name": "tags",
                  "item": [
                    {
                      "name": "List repository tags",
                      "request": {
                        "name": "List repository tags",
                        "description": {},
                        "url": {
                          "path": [
                            "v2",
                            "namespaces",
                            ":namespace",
                            "repositories",
                            ":repository",
                            "tags"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [
                            {
                              "disabled": false,
                              "key": "page",
                              "value": "{{page}}",
                              "description": "Page number to get. Defaults to 1."
                            },
                            {
                              "disabled": false,
                              "key": "page_size",
                              "value": "{{page_size}}",
                              "description": "Number of items to get per page. Defaults to 10. Max of 100."
                            }
                          ],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{namespace}}",
                              "key": "namespace",
                              "description": "(Required)"
                            },
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{repository}}",
                              "key": "repository",
                              "description": "(Required)"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "GET",
                        "auth": {
                          "type": "bearer",
                          "bearer": [
                            {
                              "key": "token",
                              "value": "{{bearerToken}}"
                            }
                          ]
                        }
                      },
                      "response": [
                        {
                          "name": "list repository tags",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "tags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "key": "page",
                                  "value": "{{page}}"
                                },
                                {
                                  "key": "page_size",
                                  "value": "{{page_size}}"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "body": {}
                          },
                          "status": "OK",
                          "code": 200,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"count\": -92813924,\n  \"next\": \"enim quis\",\n  \"previous\": \"aliquip sunt\",\n  \"results\": [\n    {\n      \"id\": 6575960,\n      \"images\": {\n        \"architecture\": \"dolor magna voluptate\",\n        \"features\": \"laboris in et eiusmod\",\n        \"variant\": \"non veniam nisi ad\",\n        \"digest\": \"in sit elit non\",\n        \"layers\": [\n          {\n            \"digest\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"size\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"instruction\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          {\n            \"digest\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"size\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"instruction\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        ],\n        \"os\": \"Excepteur quis sed tempor\",\n        \"os_features\": \"occaecat aliqua\",\n        \"os_version\": \"consectetur Ut eiusmod comm\",\n        \"size\": 29704512,\n        \"status\": \"active\",\n        \"last_pulled\": \"2021-01-05T21:06:53.506400Z\",\n        \"last_pushed\": \"2021-01-05T21:06:53.506400Z\"\n      },\n      \"creator\": -60407054,\n      \"last_updated\": \"2021-01-05T21:06:53.506400Z\",\n      \"last_updater\": 80199282,\n      \"last_updater_username\": \"labore dolor\",\n      \"name\": \"quis adipisicing elit\",\n      \"repository\": -79101366,\n      \"full_size\": -71697139,\n      \"v2\": \"cupidatat enim aliqua ullamco\",\n      \"status\": \"active\",\n      \"tag_last_pulled\": \"2021-01-05T21:06:53.506400Z\",\n      \"tag_last_pushed\": \"2021-01-05T21:06:53.506400Z\"\n    },\n    {\n      \"id\": 72220543,\n      \"images\": {\n        \"architecture\": \"veniam consectetur dolor\",\n        \"features\": \"nulla nisi tempor\",\n        \"variant\": \"dolore Duis fugiat\",\n        \"digest\": \"occaecat ex\",\n        \"layers\": [\n          {\n            \"digest\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"size\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"instruction\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          {\n            \"digest\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"size\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"instruction\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        ],\n        \"os\": \"elit in\",\n        \"os_features\": \"quis ex id voluptate in\",\n        \"os_version\": \"ullamco dolor ut dolore\",\n        \"size\": 50944706,\n        \"status\": \"active\",\n        \"last_pulled\": \"2021-01-05T21:06:53.506400Z\",\n        \"last_pushed\": \"2021-01-05T21:06:53.506400Z\"\n      },\n      \"creator\": 88009778,\n      \"last_updated\": \"2021-01-05T21:06:53.506400Z\",\n      \"last_updater\": -72109310,\n      \"last_updater_username\": \"exercitation a\",\n      \"name\": \"velit mollit est quis\",\n      \"repository\": 86633914,\n      \"full_size\": -45400615,\n      \"v2\": \"in\",\n      \"status\": \"inactive\",\n      \"tag_last_pulled\": \"2021-01-05T21:06:53.506400Z\",\n      \"tag_last_pushed\": \"2021-01-05T21:06:53.506400Z\"\n    }\n  ]\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Forbidden",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "tags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "key": "page",
                                  "value": "{{page}}"
                                },
                                {
                                  "key": "page_size",
                                  "value": "{{page_size}}"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "body": {}
                          },
                          "status": "Forbidden",
                          "code": 403,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Not Found",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "tags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [
                                {
                                  "key": "page",
                                  "value": "{{page}}"
                                },
                                {
                                  "key": "page_size",
                                  "value": "{{page_size}}"
                                }
                              ],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "body": {}
                          },
                          "status": "Not Found",
                          "code": 404,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        }
                      ],
                      "event": [
                        {
                          "listen": "test",
                          "script": {
                            "exec": [
                              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test dockerhub-postman-api using AI Type Open AI and AI Model gpt-5\n\n\nTest generated for v2/namespaces/{namespace}/repositories/{repository}/tags?page={{page}}&page_size={{page_size}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"list repository tags\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `count` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`count`)) {\n                    const value = ld.get(responseData, `count`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field count:\", error.message);\n            }\n        })\n  \n        pm.test('count minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `count`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-185627848);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for count:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `next` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`next`)) {\n                    const value = ld.get(jsonResponse, `next`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field next:\", error.message);\n            }\n        })\n  \n        pm.test(`next length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `next`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for next:\", error.message);\n            }\n        })\n  \n        pm.test(`next length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `next`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for next:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `previous` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`previous`)) {\n                    const value = ld.get(jsonResponse, `previous`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field previous:\", error.message);\n            }\n        })\n  \n        pm.test(`previous length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `previous`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for previous:\", error.message);\n            }\n        })\n  \n        pm.test(`previous length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `previous`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for previous:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `results` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`results`)) {\n                    const value = ld.get(jsonResponse, `results`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field results:\", error.message);\n            }\n        })\n  \n        pm.test(`results length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for results:\", error.message);\n            }\n        })\n  \n        pm.test(`results length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for results:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the results field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`results`)) {\n                    let resultsArray = ld.get(jsonResponse, `results`, []);\n                    if (Array.isArray(resultsArray)) {\n                        for (let results_it = 0; results_it < resultsArray.length; results_it++) {\n                            let iterator = results_it;\n                            if (resultsArray[results_it] !== null && resultsArray[results_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'resultsArray' has 'id' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].id`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].id:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].id maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].id`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(13151920);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for results[${results_it}].id:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images' has 'images' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for results[${results_it}].images:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.architecture' has 'architecture' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.architecture`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.architecture:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.architecture length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.architecture`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.architecture:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.architecture length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.architecture`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.architecture:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.features' has 'features' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.features`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.features:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.features length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.features`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.features:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.features length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.features`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.features:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.variant' has 'variant' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.variant`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.variant:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.variant length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.variant`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.variant:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.variant length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.variant`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.variant:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.digest' has 'digest' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.digest`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.digest:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.digest length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.digest`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.digest:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.digest length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.digest`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.digest:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'layers' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.layers`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for results[${results_it}].images.layers:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.layers length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.layers`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for results[${results_it}].images.layers:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.layers length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.layers`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for results[${results_it}].images.layers:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the results[${results_it}].images.layers field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`results[${results_it}].images.layers`)) {\n                    let layersArray = ld.get(jsonResponse, `results[${results_it}].images.layers`, []);\n                    if (Array.isArray(layersArray)) {\n                        for (let layers_it = 0; layers_it < layersArray.length; layers_it++) {\n                            let iterator = layers_it;\n                            if (layersArray[layers_it] !== null && layersArray[layers_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'results[${results_it}].images.layers[${layers_it}].digest' has 'digest' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.layers[${layers_it}].digest`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for results[${results_it}].images.layers[${layers_it}].digest:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.layers[${layers_it}].size' has 'size' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.layers[${layers_it}].size`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for results[${results_it}].images.layers[${layers_it}].size:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.layers[${layers_it}].instruction' has 'instruction' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.layers[${layers_it}].instruction`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for results[${results_it}].images.layers[${layers_it}].instruction:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for results[${results_it}].images.layers:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.os' has 'os' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.os`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.os:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.os length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.os`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.os:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.os length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.os`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.os:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.os_features' has 'os_features' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.os_features`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.os_features:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.os_features length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.os_features`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.os_features:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.os_features length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.os_features`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.os_features:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.os_version' has 'os_version' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.os_version`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.os_version:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.os_version length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.os_version`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.os_version:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.os_version length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.os_version`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.os_version:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'size' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.size`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].images.size:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].images.size maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.size`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(59409024);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for results[${results_it}].images.size:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.status' has 'status' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.status`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.status:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.status length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.status`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.status:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.status length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.status`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.status:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.last_pulled' has 'last_pulled' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.last_pulled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.last_pulled:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.last_pulled length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.last_pulled`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.last_pulled:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.last_pulled length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.last_pulled`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.last_pulled:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].images.last_pulled format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.last_pulled`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for results[${results_it}].images.last_pulled:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].images.last_pushed' has 'last_pushed' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].images.last_pushed`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].images.last_pushed:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].images.last_pushed length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.last_pushed`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].images.last_pushed:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].images.last_pushed length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.last_pushed`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].images.last_pushed:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].images.last_pushed format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].images.last_pushed`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for results[${results_it}].images.last_pushed:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'creator' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].creator`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].creator:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].creator minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].creator`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-120814108);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for results[${results_it}].creator:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].last_updated' has 'last_updated' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].last_updated`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].last_updated:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].last_updated length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].last_updated:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].last_updated length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].last_updated:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].last_updated format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for results[${results_it}].last_updated:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'last_updater' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updater`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].last_updater:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].last_updater maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].last_updater`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(160398564);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for results[${results_it}].last_updater:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].last_updater_username' has 'last_updater_username' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].last_updater_username`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].last_updater_username:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].last_updater_username length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updater_username`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].last_updater_username:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].last_updater_username length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].last_updater_username`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].last_updater_username:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'repository' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].repository`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].repository:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].repository minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].repository`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-158202732);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for results[${results_it}].repository:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultsArray' has 'full_size' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `results[${results_it}].full_size`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for results[${results_it}].full_size:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].full_size minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].full_size`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-143394278);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for results[${results_it}].full_size:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].v2' has 'v2' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].v2`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].v2:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].v2 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].v2`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].v2:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].v2 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].v2`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].v2:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].status' has 'status' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].status`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].status:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].status length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].status`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].status:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].status length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].status`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].status:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].tag_last_pulled' has 'tag_last_pulled' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].tag_last_pulled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].tag_last_pulled:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].tag_last_pulled length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].tag_last_pulled`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].tag_last_pulled:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].tag_last_pulled length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].tag_last_pulled`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].tag_last_pulled:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].tag_last_pulled format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].tag_last_pulled`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for results[${results_it}].tag_last_pulled:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'results[${results_it}].tag_last_pushed' has 'tag_last_pushed' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `results[${results_it}].tag_last_pushed`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for results[${results_it}].tag_last_pushed:\", error.message);\n            }\n        })\n\n  \n        pm.test(`results[${results_it}].tag_last_pushed length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].tag_last_pushed`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for results[${results_it}].tag_last_pushed:\", error.message);\n            }\n        })\n  \n        pm.test(`results[${results_it}].tag_last_pushed length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].tag_last_pushed`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for results[${results_it}].tag_last_pushed:\", error.message);\n            }\n        })\n  \n        pm.test('results[${results_it}].tag_last_pushed format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `results[${results_it}].tag_last_pushed`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for results[${results_it}].tag_last_pushed:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for results:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Forbidden\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
                            ],
                            "type": "text/javascript"
                          }
                        }
                      ],
                      "protocolProfileBehavior": {
                        "disableBodyPruning": true
                      }
                    },
                    {
                      "name": "Check repository tags",
                      "request": {
                        "name": "Check repository tags",
                        "description": {},
                        "url": {
                          "path": [
                            "v2",
                            "namespaces",
                            ":namespace",
                            "repositories",
                            ":repository",
                            "tags"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "<string>",
                              "key": "namespace",
                              "description": "(Required)"
                            },
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "<string>",
                              "key": "repository",
                              "description": "(Required)"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "HEAD",
                        "auth": {
                          "type": "bearer",
                          "bearer": [
                            {
                              "key": "token",
                              "value": "{{bearerToken}}"
                            }
                          ]
                        }
                      },
                      "response": [
                        {
                          "name": "Repository contains tags",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "tags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "Bearer <token>"
                              }
                            ],
                            "method": "HEAD",
                            "body": {}
                          },
                          "status": "OK",
                          "code": 200,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "text/plain"
                            }
                          ],
                          "body": "",
                          "cookie": [],
                          "_postman_previewlanguage": "text"
                        },
                        {
                          "name": "Forbidden",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "tags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "Bearer <token>"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "HEAD",
                            "body": {}
                          },
                          "status": "Forbidden",
                          "code": 403,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Not Found",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "tags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "Bearer <token>"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "HEAD",
                            "body": {}
                          },
                          "status": "Not Found",
                          "code": 404,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        }
                      ],
                      "event": [],
                      "protocolProfileBehavior": {
                        "disableBodyPruning": true
                      }
                    },
                    {
                      "name": "{tag}",
                      "item": [
                        {
                          "name": "Read repository tag",
                          "request": {
                            "name": "Read repository tag",
                            "description": {},
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "tags",
                                ":tag"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{tag}}",
                                  "key": "tag",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "GET",
                            "auth": {
                              "type": "bearer",
                              "bearer": [
                                {
                                  "key": "token",
                                  "value": "{{bearerToken}}"
                                }
                              ]
                            }
                          },
                          "response": [
                            {
                              "name": "repository tag",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "v2",
                                    "namespaces",
                                    ":namespace",
                                    "repositories",
                                    ":repository",
                                    "tags",
                                    ":tag"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{namespace}}",
                                      "key": "namespace",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{repository}}",
                                      "key": "repository",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{tag}}",
                                      "key": "tag",
                                      "description": "(Required)"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "description": {
                                      "content": "Added as a part of security scheme: bearer",
                                      "type": "text/plain"
                                    },
                                    "key": "Authorization",
                                    "value": "{{Authorization}}"
                                  },
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "GET",
                                "body": {}
                              },
                              "status": "OK",
                              "code": 200,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"id\": -44676632,\n  \"images\": {\n    \"architecture\": \"ut cillum\",\n    \"features\": \"dolor laboris\",\n    \"variant\": \"Duis ut reprehenderit qui\",\n    \"digest\": \"\",\n    \"layers\": [\n      {\n        \"digest\": \"ut ex consectetur dolor\",\n        \"size\": 20817889,\n        \"instruction\": \"magna reprehenderit eu\"\n      },\n      {\n        \"digest\": \"veniam sint\",\n        \"size\": 80233374,\n        \"instruction\": \"voluptate Exce\"\n      }\n    ],\n    \"os\": \"dolore ut\",\n    \"os_features\": \"enim eu sint in\",\n    \"os_version\": \"aute officia mollit\",\n    \"size\": 35750967,\n    \"status\": \"inactive\",\n    \"last_pulled\": \"2021-01-05T21:06:53.506400Z\",\n    \"last_pushed\": \"2021-01-05T21:06:53.506400Z\"\n  },\n  \"creator\": -43216791,\n  \"last_updated\": \"2021-01-05T21:06:53.506400Z\",\n  \"last_updater\": -32943941,\n  \"last_updater_username\": \"mollit voluptate\",\n  \"name\": \"magna aliquip dolor dolore\",\n  \"repository\": 96848904,\n  \"full_size\": 65157514,\n  \"v2\": \"anim laboris qui ut Duis\",\n  \"status\": \"active\",\n  \"tag_last_pulled\": \"2021-01-05T21:06:53.506400Z\",\n  \"tag_last_pushed\": \"2021-01-05T21:06:53.506400Z\"\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            },
                            {
                              "name": "Forbidden",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "v2",
                                    "namespaces",
                                    ":namespace",
                                    "repositories",
                                    ":repository",
                                    "tags",
                                    ":tag"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{namespace}}",
                                      "key": "namespace",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{repository}}",
                                      "key": "repository",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{tag}}",
                                      "key": "tag",
                                      "description": "(Required)"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "description": {
                                      "content": "Added as a part of security scheme: bearer",
                                      "type": "text/plain"
                                    },
                                    "key": "Authorization",
                                    "value": "{{Authorization}}"
                                  },
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "GET",
                                "body": {}
                              },
                              "status": "Forbidden",
                              "code": 403,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            },
                            {
                              "name": "Not Found",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "v2",
                                    "namespaces",
                                    ":namespace",
                                    "repositories",
                                    ":repository",
                                    "tags",
                                    ":tag"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{namespace}}",
                                      "key": "namespace",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{repository}}",
                                      "key": "repository",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "{{tag}}",
                                      "key": "tag",
                                      "description": "(Required)"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "description": {
                                      "content": "Added as a part of security scheme: bearer",
                                      "type": "text/plain"
                                    },
                                    "key": "Authorization",
                                    "value": "{{Authorization}}"
                                  },
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "GET",
                                "body": {}
                              },
                              "status": "Not Found",
                              "code": 404,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            }
                          ],
                          "event": [
                            {
                              "listen": "test",
                              "script": {
                                "exec": [
                                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test dockerhub-postman-api using AI Type Open AI and AI Model gpt-5\n\n\nTest generated for v2/namespaces/{namespace}/repositories/{repository}/tags/{tag} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"repository tag\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `id` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`id`)) {\n                    const value = ld.get(responseData, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field id:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images`)) {\n                    const value = ld.get(jsonResponse, `images`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field images:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.architecture` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.architecture`)) {\n                    const value = ld.get(jsonResponse, `images.architecture`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.architecture:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.features` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.features`)) {\n                    const value = ld.get(jsonResponse, `images.features`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.features:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.variant` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.variant`)) {\n                    const value = ld.get(jsonResponse, `images.variant`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.variant:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.digest` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.digest`)) {\n                    const value = ld.get(jsonResponse, `images.digest`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.digest:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.layers` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.layers`)) {\n                    const value = ld.get(jsonResponse, `images.layers`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field images.layers:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the images.layers field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.layers`)) {\n                    let layersArray = ld.get(jsonResponse, `images.layers`, []);\n                    if (Array.isArray(layersArray)) {\n                        for (let layers_it = 0; layers_it < layersArray.length; layers_it++) {\n                            let iterator = layers_it;\n                            if (layersArray[layers_it] !== null && layersArray[layers_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'images.layers[${layers_it}].digest' has 'digest' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `images.layers[${layers_it}].digest`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for images.layers[${layers_it}].digest:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'layersArray' has 'size' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `images.layers[${layers_it}].size`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for images.layers[${layers_it}].size:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'images.layers[${layers_it}].instruction' has 'instruction' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `images.layers[${layers_it}].instruction`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for images.layers[${layers_it}].instruction:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for images.layers:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.os` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.os`)) {\n                    const value = ld.get(jsonResponse, `images.os`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.os:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.os_features` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.os_features`)) {\n                    const value = ld.get(jsonResponse, `images.os_features`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.os_features:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.os_version` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.os_version`)) {\n                    const value = ld.get(jsonResponse, `images.os_version`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.os_version:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.size` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`images.size`)) {\n                    const value = ld.get(responseData, `images.size`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field images.size:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.status`)) {\n                    const value = ld.get(jsonResponse, `images.status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.status:\", error.message);\n            }\n        })\n \n        pm.test(`images.status to be one of enum`, function(){ \n            try {\n                const value = ld.get(responseData, `images.status`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect([\"active\",\"inactive\"]).to.include(value);\n                }\n            } catch (error) {\n                console.log(\"Error checking enum for images.status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.last_pulled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.last_pulled`)) {\n                    const value = ld.get(jsonResponse, `images.last_pulled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.last_pulled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `images.last_pushed` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`images.last_pushed`)) {\n                    const value = ld.get(jsonResponse, `images.last_pushed`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field images.last_pushed:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `creator` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`creator`)) {\n                    const value = ld.get(responseData, `creator`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field creator:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `last_updated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`last_updated`)) {\n                    const value = ld.get(jsonResponse, `last_updated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field last_updated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `last_updater` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`last_updater`)) {\n                    const value = ld.get(responseData, `last_updater`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field last_updater:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `last_updater_username` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`last_updater_username`)) {\n                    const value = ld.get(jsonResponse, `last_updater_username`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field last_updater_username:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `repository` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`repository`)) {\n                    const value = ld.get(responseData, `repository`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field repository:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `full_size` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`full_size`)) {\n                    const value = ld.get(responseData, `full_size`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field full_size:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `v2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`v2`)) {\n                    const value = ld.get(jsonResponse, `v2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field v2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n \n        pm.test(`status to be one of enum`, function(){ \n            try {\n                const value = ld.get(responseData, `status`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect([\"active\",\"inactive\"]).to.include(value);\n                }\n            } catch (error) {\n                console.log(\"Error checking enum for status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `tag_last_pulled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`tag_last_pulled`)) {\n                    const value = ld.get(jsonResponse, `tag_last_pulled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field tag_last_pulled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `tag_last_pushed` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`tag_last_pushed`)) {\n                    const value = ld.get(jsonResponse, `tag_last_pushed`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field tag_last_pushed:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Forbidden\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
                                ],
                                "type": "text/javascript"
                              }
                            }
                          ],
                          "protocolProfileBehavior": {
                            "disableBodyPruning": true
                          }
                        },
                        {
                          "name": "Check repository tag",
                          "request": {
                            "name": "Check repository tag",
                            "description": {},
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "tags",
                                ":tag"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "repository",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "<string>",
                                  "key": "tag",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "HEAD",
                            "auth": {
                              "type": "bearer",
                              "bearer": [
                                {
                                  "key": "token",
                                  "value": "{{bearerToken}}"
                                }
                              ]
                            }
                          },
                          "response": [
                            {
                              "name": "Repository tag exists",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "v2",
                                    "namespaces",
                                    ":namespace",
                                    "repositories",
                                    ":repository",
                                    "tags",
                                    ":tag"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "namespace",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "repository",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "tag",
                                      "description": "(Required)"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "description": {
                                      "content": "Added as a part of security scheme: bearer",
                                      "type": "text/plain"
                                    },
                                    "key": "Authorization",
                                    "value": "Bearer <token>"
                                  }
                                ],
                                "method": "HEAD",
                                "body": {}
                              },
                              "status": "OK",
                              "code": 200,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "text/plain"
                                }
                              ],
                              "body": "",
                              "cookie": [],
                              "_postman_previewlanguage": "text"
                            },
                            {
                              "name": "Forbidden",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "v2",
                                    "namespaces",
                                    ":namespace",
                                    "repositories",
                                    ":repository",
                                    "tags",
                                    ":tag"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "namespace",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "repository",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "tag",
                                      "description": "(Required)"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "description": {
                                      "content": "Added as a part of security scheme: bearer",
                                      "type": "text/plain"
                                    },
                                    "key": "Authorization",
                                    "value": "Bearer <token>"
                                  },
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "HEAD",
                                "body": {}
                              },
                              "status": "Forbidden",
                              "code": 403,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            },
                            {
                              "name": "Not Found",
                              "originalRequest": {
                                "url": {
                                  "path": [
                                    "v2",
                                    "namespaces",
                                    ":namespace",
                                    "repositories",
                                    ":repository",
                                    "tags",
                                    ":tag"
                                  ],
                                  "host": [
                                    "{{baseUrl}}"
                                  ],
                                  "query": [],
                                  "variable": [
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "namespace",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "repository",
                                      "description": "(Required)"
                                    },
                                    {
                                      "disabled": false,
                                      "type": "any",
                                      "value": "<string>",
                                      "key": "tag",
                                      "description": "(Required)"
                                    }
                                  ]
                                },
                                "header": [
                                  {
                                    "description": {
                                      "content": "Added as a part of security scheme: bearer",
                                      "type": "text/plain"
                                    },
                                    "key": "Authorization",
                                    "value": "Bearer <token>"
                                  },
                                  {
                                    "key": "Accept",
                                    "value": "application/json"
                                  }
                                ],
                                "method": "HEAD",
                                "body": {}
                              },
                              "status": "Not Found",
                              "code": 404,
                              "header": [
                                {
                                  "key": "Content-Type",
                                  "value": "application/json"
                                }
                              ],
                              "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
                              "cookie": [],
                              "_postman_previewlanguage": "json"
                            }
                          ],
                          "event": [],
                          "protocolProfileBehavior": {
                            "disableBodyPruning": true
                          }
                        }
                      ],
                      "event": []
                    }
                  ],
                  "event": []
                },
                {
                  "name": "immutabletags",
                  "item": [
                    {
                      "name": "Update repository immutable tags",
                      "request": {
                        "name": "Update repository immutable tags",
                        "description": {
                          "content": "Updates the immutable tags configuration for this repository.\n\n**Only users with administrative privileges for the repository can modify these settings.**",
                          "type": "text/plain"
                        },
                        "url": {
                          "path": [
                            "v2",
                            "namespaces",
                            ":namespace",
                            "repositories",
                            ":repository",
                            "immutabletags"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{namespace}}",
                              "key": "namespace",
                              "description": "(Required)"
                            },
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{repository}}",
                              "key": "repository",
                              "description": "(Required)"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Content-Type",
                            "value": "application/json"
                          },
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "PATCH",
                        "auth": {
                          "type": "bearer",
                          "bearer": [
                            {
                              "key": "token",
                              "value": "{{bearerToken}}"
                            }
                          ]
                        },
                        "body": {
                          "mode": "raw",
                          "raw": "{\n    \"immutable_tags\": \"{{immutable_tags_*boolean}}\",\n    \"immutable_tags_rules\": [\n        \"{{immutable_tags_rules_0_*string}}\",\n        \"{{immutable_tags_rules_1_*string}}\"\n    ]\n}",
                          "options": {
                            "raw": {
                              "language": "json"
                            }
                          }
                        }
                      },
                      "response": [
                        {
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "PATCH",
                            "body": {}
                          },
                          "status": "OK",
                          "code": 200,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"user\": \"aute\",\n  \"name\": \"sint labore commodo\",\n  \"namespace\": \"eu\",\n  \"status\": 8082104,\n  \"status_description\": \"ea quis minim\",\n  \"description\": \"anim dolore\",\n  \"is_private\": false,\n  \"is_automated\": true,\n  \"star_count\": -43303491,\n  \"pull_count\": -86488804,\n  \"last_updated\": \"2021-01-05T21:06:53.506400Z\",\n  \"date_registered\": \"2021-01-05T21:06:53.506400Z\",\n  \"collaborator_count\": 1520006,\n  \"has_starred\": false,\n  \"permissions\": {\n    \"read\": false,\n    \"write\": false,\n    \"admin\": false\n  },\n  \"media_types\": [\n    \"ut irure ipsum\",\n    \"voluptate veniam in nulla\"\n  ],\n  \"content_types\": [\n    \"fugiat laborum\",\n    \"ut dolore velit in eiusmod\"\n  ],\n  \"categories\": [\n    {\n      \"name\": \"Databases\",\n      \"slug\": \"databases\"\n    },\n    {\n      \"name\": \"Databases\",\n      \"slug\": \"databases\"\n    }\n  ],\n  \"immutable_tags_settings\": {\n    \"enabled\": false,\n    \"rules\": [\n      \"mollit et\",\n      \"officia reprehenderit esse\"\n    ]\n  },\n  \"repository_type\": \"minim dolor incididunt velit\",\n  \"last_modified\": \"2021-01-05T21:06:53.506400Z\",\n  \"affiliation\": \"ea deserunt ut\",\n  \"hub_user\": \"consectetur Ut et\",\n  \"full_description\": \"Ut mollit id ullamco\",\n  \"storage_size\": 29407833\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Bad Request",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "PATCH",
                            "body": {}
                          },
                          "status": "Bad Request",
                          "code": 400,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Unauthorized",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "PATCH",
                            "body": {}
                          },
                          "status": "Unauthorized",
                          "code": 401,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Forbidden",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "PATCH",
                            "body": {}
                          },
                          "status": "Forbidden",
                          "code": 403,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Not Found",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "PATCH",
                            "body": {}
                          },
                          "status": "Not Found",
                          "code": 404,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        }
                      ],
                      "event": [
                        {
                          "listen": "test",
                          "script": {
                            "exec": [
                              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test dockerhub-postman-api using AI Type Open AI and AI Model gpt-5\n\n\nTest generated for v2/namespaces/{namespace}/repositories/{repository}/immutabletags for http method type patch in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"undefined\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `user` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`user`)) {\n                    const value = ld.get(jsonResponse, `user`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field user:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `namespace` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`namespace`)) {\n                    const value = ld.get(jsonResponse, `namespace`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field namespace:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `repository_type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`repository_type`)) {\n                    const value = ld.get(jsonResponse, `repository_type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field repository_type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`status`)) {\n                    const value = ld.get(responseData, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status_description` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status_description`)) {\n                    const value = ld.get(jsonResponse, `status_description`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status_description:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `description` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`description`)) {\n                    const value = ld.get(jsonResponse, `description`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field description:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `is_private` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`is_private`)) {\n                    const value = ld.get(jsonResponse, `is_private`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field is_private:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `is_automated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`is_automated`)) {\n                    const value = ld.get(jsonResponse, `is_automated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field is_automated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `star_count` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`star_count`)) {\n                    const value = ld.get(responseData, `star_count`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field star_count:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `pull_count` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`pull_count`)) {\n                    const value = ld.get(responseData, `pull_count`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field pull_count:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `last_updated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`last_updated`)) {\n                    const value = ld.get(jsonResponse, `last_updated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field last_updated:\", error.message);\n            }\n        })\n  \n        pm.test('last_updated format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `last_updated`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for last_updated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `last_modified` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`last_modified`)) {\n                    const value = ld.get(jsonResponse, `last_modified`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field last_modified:\", error.message);\n            }\n        })\n  \n        pm.test('last_modified format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `last_modified`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for last_modified:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `date_registered` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`date_registered`)) {\n                    const value = ld.get(jsonResponse, `date_registered`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field date_registered:\", error.message);\n            }\n        })\n  \n        pm.test('date_registered format to be date-time',function(){\n            try {\n                const value = ld.get(responseData, `date_registered`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking date-time format for date_registered:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `collaborator_count` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`collaborator_count`)) {\n                    const value = ld.get(responseData, `collaborator_count`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field collaborator_count:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `affiliation` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`affiliation`)) {\n                    const value = ld.get(jsonResponse, `affiliation`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field affiliation:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `hub_user` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`hub_user`)) {\n                    const value = ld.get(jsonResponse, `hub_user`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field hub_user:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `has_starred` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`has_starred`)) {\n                    const value = ld.get(jsonResponse, `has_starred`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field has_starred:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `full_description` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`full_description`)) {\n                    const value = ld.get(jsonResponse, `full_description`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field full_description:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `permissions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`permissions`)) {\n                    const value = ld.get(jsonResponse, `permissions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field permissions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `permissions.read` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`permissions.read`)) {\n                    const value = ld.get(jsonResponse, `permissions.read`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field permissions.read:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `permissions.write` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`permissions.write`)) {\n                    const value = ld.get(jsonResponse, `permissions.write`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field permissions.write:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `permissions.admin` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`permissions.admin`)) {\n                    const value = ld.get(jsonResponse, `permissions.admin`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field permissions.admin:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `media_types` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`media_types`)) {\n                    const value = ld.get(jsonResponse, `media_types`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field media_types:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `content_types` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`content_types`)) {\n                    const value = ld.get(jsonResponse, `content_types`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field content_types:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `categories` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`categories`)) {\n                    const value = ld.get(jsonResponse, `categories`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field categories:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the categories field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`categories`)) {\n                    let categoriesArray = ld.get(jsonResponse, `categories`, []);\n                    if (Array.isArray(categoriesArray)) {\n                        for (let categories_it = 0; categories_it < categoriesArray.length; categories_it++) {\n                            let iterator = categories_it;\n                            if (categoriesArray[categories_it] !== null && categoriesArray[categories_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'categories[${categories_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `categories[${categories_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for categories[${categories_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`categories[${categories_it}].name length to be alteast '1'`,function(){\n            try {\n                const value = ld.get(responseData, `categories[${categories_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for categories[${categories_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'categories[${categories_it}].slug' has 'slug' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `categories[${categories_it}].slug`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for categories[${categories_it}].slug:\", error.message);\n            }\n        })\n\n  \n        pm.test(`categories[${categories_it}].slug length to be alteast '1'`,function(){\n            try {\n                const value = ld.get(responseData, `categories[${categories_it}].slug`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(1);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for categories[${categories_it}].slug:\", error.message);\n            }\n        })\n \n        pm.test('categories[${categories_it}].slug has same pattern as `^[a-z0-9]+(?:-[a-z0-9]+)*$`',function(){ \n            try {\n                const value = ld.get(responseData, `categories[${categories_it}].slug`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^[a-z0-9]+(?:-[a-z0-9]+)*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking pattern for categories[${categories_it}].slug:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for categories:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `immutable_tags_settings` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`immutable_tags_settings`)) {\n                    const value = ld.get(jsonResponse, `immutable_tags_settings`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field immutable_tags_settings:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `immutable_tags_settings.enabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`immutable_tags_settings.enabled`)) {\n                    const value = ld.get(jsonResponse, `immutable_tags_settings.enabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field immutable_tags_settings.enabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `immutable_tags_settings.rules` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`immutable_tags_settings.rules`)) {\n                    const value = ld.get(jsonResponse, `immutable_tags_settings.rules`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field immutable_tags_settings.rules:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `storage_size` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`storage_size`)) {\n                    const value = ld.get(responseData, `storage_size`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field storage_size:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Bad Request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Unauthorized\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Forbidden\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
                            ],
                            "type": "text/javascript"
                          }
                        }
                      ],
                      "protocolProfileBehavior": {
                        "disableBodyPruning": true
                      }
                    },
                    {
                      "name": "Verify repository immutable tags",
                      "request": {
                        "name": "Verify repository immutable tags",
                        "description": {
                          "content": "Validates  the immutable tags regex pass in parameter and returns a list of tags matching it in this repository.\n\n**Only users with administrative privileges for the repository call this endpoint.**",
                          "type": "text/plain"
                        },
                        "url": {
                          "path": [
                            "v2",
                            "namespaces",
                            ":namespace",
                            "repositories",
                            ":repository",
                            "immutabletags",
                            "verify"
                          ],
                          "host": [
                            "{{baseUrl}}"
                          ],
                          "query": [],
                          "variable": [
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{namespace}}",
                              "key": "namespace",
                              "description": "(Required)"
                            },
                            {
                              "disabled": false,
                              "type": "any",
                              "value": "{{repository}}",
                              "key": "repository",
                              "description": "(Required)"
                            }
                          ]
                        },
                        "header": [
                          {
                            "key": "Content-Type",
                            "value": "application/json"
                          },
                          {
                            "key": "Accept",
                            "value": "application/json"
                          }
                        ],
                        "method": "POST",
                        "auth": {
                          "type": "bearer",
                          "bearer": [
                            {
                              "key": "token",
                              "value": "{{bearerToken}}"
                            }
                          ]
                        },
                        "body": {
                          "mode": "raw",
                          "raw": "{\n    \"regex\": \"{{regex_*string}}\"\n}",
                          "options": {
                            "raw": {
                              "language": "json"
                            }
                          }
                        }
                      },
                      "response": [
                        {
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags",
                                "verify"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "POST",
                            "body": {}
                          },
                          "status": "OK",
                          "code": 200,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"tags\": [\n    \"v1.0.0\",\n    \"v2.1.3\",\n    \"latest\"\n  ]\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Bad Request",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags",
                                "verify"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "POST",
                            "body": {}
                          },
                          "status": "Bad Request",
                          "code": 400,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Unauthorized",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags",
                                "verify"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "POST",
                            "body": {}
                          },
                          "status": "Unauthorized",
                          "code": 401,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Forbidden",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags",
                                "verify"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "POST",
                            "body": {}
                          },
                          "status": "Forbidden",
                          "code": 403,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        },
                        {
                          "name": "Not Found",
                          "originalRequest": {
                            "url": {
                              "path": [
                                "v2",
                                "namespaces",
                                ":namespace",
                                "repositories",
                                ":repository",
                                "immutabletags",
                                "verify"
                              ],
                              "host": [
                                "{{baseUrl}}"
                              ],
                              "query": [],
                              "variable": [
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{namespace}}",
                                  "key": "namespace",
                                  "description": "(Required)"
                                },
                                {
                                  "disabled": false,
                                  "type": "any",
                                  "value": "{{repository}}",
                                  "key": "repository",
                                  "description": "(Required)"
                                }
                              ]
                            },
                            "header": [
                              {
                                "description": {
                                  "content": "Added as a part of security scheme: bearer",
                                  "type": "text/plain"
                                },
                                "key": "Authorization",
                                "value": "{{Authorization}}"
                              },
                              {
                                "key": "Accept",
                                "value": "application/json"
                              }
                            ],
                            "method": "POST",
                            "body": {}
                          },
                          "status": "Not Found",
                          "code": 404,
                          "header": [
                            {
                              "key": "Content-Type",
                              "value": "application/json"
                            }
                          ],
                          "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
                          "cookie": [],
                          "_postman_previewlanguage": "json"
                        }
                      ],
                      "event": [
                        {
                          "listen": "test",
                          "script": {
                            "exec": [
                              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test dockerhub-postman-api using AI Type Open AI and AI Model gpt-5\n\n\nTest generated for v2/namespaces/{namespace}/repositories/{repository}/immutabletags/verify for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"undefined\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `tags` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`tags`)) {\n                    const value = ld.get(jsonResponse, `tags`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field tags:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Bad Request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Unauthorized\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Forbidden\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
                            ],
                            "type": "text/javascript"
                          }
                        }
                      ],
                      "protocolProfileBehavior": {
                        "disableBodyPruning": true
                      }
                    }
                  ],
                  "event": []
                }
              ],
              "event": []
            }
          ],
          "event": []
        },
        {
          "name": "Assign a group (Team) to a repository for access",
          "request": {
            "name": "Assign a group (Team) to a repository for access",
            "description": {},
            "url": {
              "path": [
                "v2",
                "repositories",
                ":namespace",
                ":repository",
                "groups"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "disabled": false,
                  "key": "group_name",
                  "value": "{{group_name}}",
                  "description": "(Required) Name of the group (team) in the organization."
                },
                {
                  "disabled": false,
                  "key": "permission",
                  "value": "{{permission}}",
                  "description": "(Required)"
                }
              ],
              "variable": [
                {
                  "disabled": false,
                  "type": "any",
                  "value": "{{namespace}}",
                  "key": "namespace",
                  "description": "(Required)"
                },
                {
                  "disabled": false,
                  "type": "any",
                  "value": "{{repository}}",
                  "key": "repository",
                  "description": "(Required)"
                }
              ]
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{bearerToken}}"
                }
              ]
            }
          },
          "response": [
            {
              "name": "Team assigned to repository successfully",
              "originalRequest": {
                "url": {
                  "path": [
                    "v2",
                    "repositories",
                    ":namespace",
                    ":repository",
                    "groups"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "key": "group_name",
                      "value": "{{group_name}}"
                    },
                    {
                      "key": "permission",
                      "value": "{{permission}}"
                    }
                  ],
                  "variable": [
                    {
                      "disabled": false,
                      "type": "any",
                      "value": "{{namespace}}",
                      "key": "namespace",
                      "description": "(Required)"
                    },
                    {
                      "disabled": false,
                      "type": "any",
                      "value": "{{repository}}",
                      "key": "repository",
                      "description": "(Required)"
                    }
                  ]
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: bearer",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {}
              },
              "status": "OK",
              "code": 200,
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"group_name\": \"amet laboris eiusmod minim\",\n  \"permission\": \"read\"\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "name": "Forbidden",
              "originalRequest": {
                "url": {
                  "path": [
                    "v2",
                    "repositories",
                    ":namespace",
                    ":repository",
                    "groups"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "key": "group_name",
                      "value": "{{group_name}}"
                    },
                    {
                      "key": "permission",
                      "value": "{{permission}}"
                    }
                  ],
                  "variable": [
                    {
                      "disabled": false,
                      "type": "any",
                      "value": "{{namespace}}",
                      "key": "namespace",
                      "description": "(Required)"
                    },
                    {
                      "disabled": false,
                      "type": "any",
                      "value": "{{repository}}",
                      "key": "repository",
                      "description": "(Required)"
                    }
                  ]
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: bearer",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {}
              },
              "status": "Forbidden",
              "code": 403,
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"errinfo\": {},\n  \"detail\": \"eu dolor officia sit\",\n  \"message\": \"laborum aute\"\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "name": "Not Found",
              "originalRequest": {
                "url": {
                  "path": [
                    "v2",
                    "repositories",
                    ":namespace",
                    ":repository",
                    "groups"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [
                    {
                      "key": "group_name",
                      "value": "{{group_name}}"
                    },
                    {
                      "key": "permission",
                      "value": "{{permission}}"
                    }
                  ],
                  "variable": [
                    {
                      "disabled": false,
                      "type": "any",
                      "value": "{{namespace}}",
                      "key": "namespace",
                      "description": "(Required)"
                    },
                    {
                      "disabled": false,
                      "type": "any",
                      "value": "{{repository}}",
                      "key": "repository",
                      "description": "(Required)"
                    }
                  ]
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: bearer",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {}
              },
              "status": "Not Found",
              "code": 404,
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"detail\": \"mollit\",\n  \"message\": \"fugiat occaecat\"\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test dockerhub-postman-api using AI Type Open AI and AI Model gpt-5\n\n\nTest generated for v2/repositories/{namespace}/{repository}/groups?group_name={{group_name}}&permission={{permission}} for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Team assigned to repository successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `group_name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`group_name`)) {\n                    const value = ld.get(jsonResponse, `group_name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field group_name:\", error.message);\n            }\n        })\n  \n        pm.test(`group_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `group_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for group_name:\", error.message);\n            }\n        })\n  \n        pm.test(`group_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `group_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for group_name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `permission` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`permission`)) {\n                    const value = ld.get(jsonResponse, `permission`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field permission:\", error.message);\n            }\n        })\n  \n        pm.test(`permission length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `permission`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for permission:\", error.message);\n            }\n        })\n  \n        pm.test(`permission length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `permission`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for permission:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"Forbidden\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `errinfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`errinfo`)) {\n                    const value = ld.get(jsonResponse, `errinfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field errinfo:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `detail` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`detail`)) {\n                    const value = ld.get(jsonResponse, `detail`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for detail:\", error.message);\n            }\n        })\n  \n        pm.test(`detail length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `detail`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for detail:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`message`)) {\n                    const value = ld.get(jsonResponse, `message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for message:\", error.message);\n            }\n        })\n  \n        pm.test(`message length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `message`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for message:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          }
        },
        {
          "name": "invites",
          "item": [
            {
              "name": "{id}",
              "item": [
                null,
                null
              ],
              "event": []
            },
            null
          ],
          "event": []
        },
        {
          "name": "scim/2.0",
          "item": [
            null,
            {
              "name": "ResourceTypes",
              "item": [
                null,
                null
              ],
              "event": []
            },
            {
              "name": "Schemas",
              "item": [
                null,
                null
              ],
              "event": []
            },
            {
              "name": "Users",
              "item": [
                null,
                null,
                {
                  "name": "{id}",
                  "item": [
                    null,
                    null
                  ],
                  "event": []
                }
              ],
              "event": []
            }
          ],
          "event": []
        }
      ],
      "event": []
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://hub.docker.com",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "info": {
    "_postman_id": "6934a6ed-b2a6-4b79-982c-144297370849",
    "name": "Docker HUB API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "Docker Hub is a service provided by Docker for finding and sharing container images with your team.\n\nIt is the world's largest library and community for container images.\n\nIn addition to the [Docker Hub UI](https://docs.docker.com/docker-hub/) and [Docker Hub CLI tool](https://github.com/docker/hub-tool#readme) (currently experimental), Docker provides an API that allows you to interact with Docker Hub.\n\nBrowse through the Docker Hub API documentation to explore the supported endpoints.",
      "type": "text/plain"
    }
  }
}