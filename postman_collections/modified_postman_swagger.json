{
  "item": [
    {
      "name": "Submit Request",
      "request": {
        "name": "Submit Request",
        "description": {
          "content": "Meta API request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "submitRequest"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "<object>",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for submitRequest for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AuthToken",
      "request": {
        "name": "AuthToken",
        "description": {
          "content": "Get authentication token",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "authToken"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null
      },
      "response": [
        {
          "name": "successful login",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"token\": \"token\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for authToken for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful login\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `token` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`token`)) {\n                    const value = ld.get(jsonResponse, `token`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field token:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Deposit",
      "request": {
        "name": "Deposit",
        "description": {
          "content": "Deposit amount to customer's account",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deposit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*string}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Deposit success",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deposit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Deposit success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetAccountInfo",
      "request": {
        "name": "GetAccountInfo",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"customerId\": 3868837.051717654,\n  \"accounts\": [\n    {\n      \"customerId\": 64982861.88302517,\n      \"accountName\": \"magna Excepteur eiusmod ex\",\n      \"accountNickname\": \"ut esse incididunt\",\n      \"accountNumber\": \"sed sint\",\n      \"accountType\": \"ex pariatur tempor esse\",\n      \"activatedDate\": \"dolore\",\n      \"availableBalance\": 87001239.14489236,\n      \"availableCash\": -88720567.0824231,\n      \"availableCashLimit\": 85925833.3132118,\n      \"availableCredit\": 59368617.712807626,\n      \"bankName\": \"anim ma\",\n      \"branchName\": \"labore elit ullamco tempor\",\n      \"cardName\": \"sit id aute\",\n      \"cardNumber\": \"anim ullamco\",\n      \"cardStatus\": \"ut exercitation\",\n      \"cardType\": \"dolor Ut minim laborum\",\n      \"creditLimit\": 53175543.59896377,\n      \"currency\": \"ullamco\",\n      \"currentBalance\": 36955820.64085698,\n      \"deactivatedDate\": \"dolor sed\",\n      \"dueAmount\": 21638511.257499978,\n      \"dueDate\": \"officia incididunt irure magna\",\n      \"earlyWithdrawalPenalty\": 11791354.19573471,\n      \"email\": \"non esse elit sit\",\n      \"expDate\": \"\",\n      \"fdType\": \"tempor quis in in dolor\",\n      \"image\": \"dolor consequat est nisi ex\",\n      \"interestRate\": 56173837.99263963,\n      \"internalTransferFromEnabled\": false,\n      \"internalTransferToEnabled\": false,\n      \"isPrimaryMobile\": false,\n      \"isAlternateMobileNumber\": true,\n      \"isStatement\": true,\n      \"lastDrawDate\": \"occaecat Ut\",\n      \"loanMaturityDate\": \"sed\",\n      \"loanOriginationDate\": \"exercitation quis pariatur dolor Lorem\",\n      \"location\": \"reprehenderit cillum do consectetur\",\n      \"lastUpdated\": \"d\",\n      \"maxTransactionLimit\": \"nulla exercitation velit dolore amet\",\n      \"maturityDate\": \"dolore Ut non commodo\",\n      \"minimumPaymentDue\": \"veniam occaec\",\n      \"minimumBalance\": \"laboris dolor amet reprehenderit\",\n      \"monthlyPayment\": -87739716.98623733,\n      \"openingBalance\": 89531464.7834863,\n      \"originalLoanAmount\": -37141142.54223642,\n      \"P2PLimit\": 10419003.766143039,\n      \"p2pEnabled\": -35044521.60886795,\n      \"paybillEnabled\": true,\n      \"payoffAmount\": -92578425.01341952,\n      \"personalBankerName\": \"laboris Excepteur Duis et aliquip\",\n      \"personalBankerContact\": {\n        \"email\": \"laborum\",\n        \"mobileNumber\": \"incididunt ullamco qui est\"\n      },\n      \"phone\": 42498678.95451641,\n      \"postedBalance\": -29908898.951704368,\n      \"principalBalance\": \"dolor qui ipsum\",\n      \"productCode\": \"qui pariatur ut\",\n      \"productName\": \"ullamco nisi\",\n      \"propertyAddress\": \"ad anim magna labore\",\n      \"rewardPoints\": \"sint nulla enim elit deserunt\",\n      \"routingNumber\": \"adipisicing\",\n      \"statementDate\": \"aliquip proident eiusmod cillum laboris\",\n      \"status\": \"nisi commodo magna irure qui\",\n      \"swiftCode\": \"laborum\",\n      \"totalBalance\": -49063959.054829895,\n      \"unbilledAmount\": -98786196.48254934,\n      \"valueAtMaturity\": 2535415.063860208,\n      \"holdAmount\": 82357752.53531227,\n      \"unclearFundsAmount\": -75017992.41735116,\n      \"averageMonthlyBalance\": -3715315.842456639,\n      \"netWithdrawableBalance\": 9700264.764029637,\n      \"totalTenure\": \"esse conse\",\n      \"remainingTenure\": \"mollit cupidatat incididunt\",\n      \"debitAccountNumber\": \"ea non\",\n      \"lateFee\": -6914019.106730729,\n      \"bounceCharge\": 5220160.456523046,\n      \"totalCharges\": -94944227.9733439,\n      \"overDueAmount\": -96732590.16721274,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"sint eiusmod nulla officia quis\",\n          \"cardNumber\": \"do minim cillum est\",\n          \"cardStatus\": \"aliquip commodo\",\n          \"cardImage\": \"adipisicing sunt eu\",\n          \"cardType\": \"eu consequat eiusmod\",\n          \"expDate\": \"eu esse qui nostrud amet\",\n          \"displayCardStatus\": \"enim incididunt consectetur\",\n          \"primaryCard\": \"eu laborum deserunt incididunt nisi\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"proident ipsum adipi\",\n          \"nameOnCard\": \"ut laborum et dolor\",\n          \"cardNetwork\": \"aliquip\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"laboris dolor minim est nulla\",\n            \"paymentType\": \"incididunt ullamco consectetur et anim\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"magna in consequat Duis sed\"\n          },\n          \"dueAmount\": -61977988.228680395,\n          \"dueDate\": \"nisi reprehenderit officia\",\n          \"minimumPaymentDue\": 3291762.138101533,\n          \"partialPaymentPaid\": 292405.7137571722\n        },\n        {\n          \"cardName\": \"qu\",\n          \"cardNumber\": \"culpa nulla proident\",\n          \"cardStatus\": \"elit tempor ullamco\",\n          \"cardImage\": \"non labore\",\n          \"cardType\": \"non Lorem in\",\n          \"expDate\": \"ipsum et aliquip\",\n          \"displayCardStatus\": \"veniam Lorem dolor minim\",\n          \"primaryCard\": \"ut occaecat reprehenderit\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"qui Excepteur ad\",\n          \"nameOnCard\": \"incididunt reprehenderit sint\",\n          \"cardNetwork\": \"sit incididunt sed enim velit\",\n          \"autopay\": {\n            \"enabled\": false,\n            \"sourceAccountId\": \"sit dolor\",\n            \"paymentType\": \"amet ullamco sint esse\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"pariatur cillum\"\n          },\n          \"dueAmount\": -85742275.24681225,\n          \"dueDate\": \"cillum dolor sed\",\n          \"minimumPaymentDue\": -27573731.963050157,\n          \"partialPaymentPaid\": -98932892.77026543\n        }\n      ],\n      \"IsCrossAccount\": true\n    },\n    {\n      \"customerId\": -52302523.347036935,\n      \"accountName\": \"irure ipsum\",\n      \"accountNickname\": \"cupidatat elit minim commodo exercitation\",\n      \"accountNumber\": \"elit Lorem\",\n      \"accountType\": \"adipisicing et ani\",\n      \"activatedDate\": \"exercitation pro\",\n      \"availableBalance\": 61119905.98489654,\n      \"availableCash\": 67837386.38836008,\n      \"availableCashLimit\": -96919548.08869867,\n      \"availableCredit\": 78669394.67837217,\n      \"bankName\": \"elit esse sit\",\n      \"branchName\": \"adip\",\n      \"cardName\": \"deserunt dolor\",\n      \"cardNumber\": \"adipisicing in minim enim\",\n      \"cardStatus\": \"quis laborum qui aute\",\n      \"cardType\": \"amet ex\",\n      \"creditLimit\": -34001585.15455574,\n      \"currency\": \"consequa\",\n      \"currentBalance\": 51860363.793281615,\n      \"deactivatedDate\": \"in ullamco sunt enim\",\n      \"dueAmount\": 90509346.32075176,\n      \"dueDate\": \"consequat occaecat elit\",\n      \"earlyWithdrawalPenalty\": 3000712.90743427,\n      \"email\": \"dolor incididunt\",\n      \"expDate\": \"fugiat laboris nostrud elit\",\n      \"fdType\": \"officia\",\n      \"image\": \"officia ea anim\",\n      \"interestRate\": -69774025.82494894,\n      \"internalTransferFromEnabled\": true,\n      \"internalTransferToEnabled\": true,\n      \"isPrimaryMobile\": true,\n      \"isAlternateMobileNumber\": false,\n      \"isStatement\": false,\n      \"lastDrawDate\": \"Excepteur eu in laborum fugiat\",\n      \"loanMaturityDate\": \"Duis exercitation reprehenderit\",\n      \"loanOriginationDate\": \"aliquip cillum nisi\",\n      \"location\": \"aliquip in\",\n      \"lastUpdated\": \"dolor occaecat ullamco nostrud\",\n      \"maxTransactionLimit\": \"dolor eiusmod ipsum\",\n      \"maturityDate\": \"ut in culpa\",\n      \"minimumPaymentDue\": \"do eiusmod\",\n      \"minimumBalance\": \"in\",\n      \"monthlyPayment\": 75011818.41445273,\n      \"openingBalance\": -86962410.11682777,\n      \"originalLoanAmount\": 13962706.10579151,\n      \"P2PLimit\": 53701270.580810905,\n      \"p2pEnabled\": 61668798.88704878,\n      \"paybillEnabled\": false,\n      \"payoffAmount\": -33909104.41171893,\n      \"personalBankerName\": \"est proident\",\n      \"personalBankerContact\": {\n        \"email\": \"aliqua sint\",\n        \"mobileNumber\": \"Duis ut\"\n      },\n      \"phone\": 60350663.79844579,\n      \"postedBalance\": 30640527.439039916,\n      \"principalBalance\": \"do aliqua\",\n      \"productCode\": \"officia\",\n      \"productName\": \"consequat cillum est aute\",\n      \"propertyAddress\": \"tempor qui aliqua consectetur\",\n      \"rewardPoints\": \"exercitation in sed occaecat\",\n      \"routingNumber\": \"ut velit incididunt Duis occaecat\",\n      \"statementDate\": \"do dolor\",\n      \"status\": \"cillum proident\",\n      \"swiftCode\": \"incididunt Excepteur\",\n      \"totalBalance\": -39120456.41362871,\n      \"unbilledAmount\": 3014047.896242559,\n      \"valueAtMaturity\": 66578153.00329378,\n      \"holdAmount\": -37035746.78915218,\n      \"unclearFundsAmount\": -44897872.08176446,\n      \"averageMonthlyBalance\": -2589891.944025129,\n      \"netWithdrawableBalance\": 67340622.6918157,\n      \"totalTenure\": \"in fugiat aliquip\",\n      \"remainingTenure\": \"et in sit laboris\",\n      \"debitAccountNumber\": \"elit nostrud commodo tempor\",\n      \"lateFee\": 27439338.034478888,\n      \"bounceCharge\": -46146486.38344714,\n      \"totalCharges\": 11996439.358813584,\n      \"overDueAmount\": 22211543.105568007,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"cupidatat\",\n          \"cardNumber\": \"cillum veniam et\",\n          \"cardStatus\": \"incididunt deserunt tempor\",\n          \"cardImage\": \"in sit\",\n          \"cardType\": \"dolor Duis minim ut\",\n          \"expDate\": \"aliquip\",\n          \"displayCardStatus\": \"am\",\n          \"primaryCard\": \"occaecat in minim\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"ipsum fugiat\",\n          \"nameOnCard\": \"aliquip laboris dolore tempor sint\",\n          \"cardNetwork\": \"sit est pariatur ullamco occaecat\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"laboris quis fugiat anim\",\n            \"paymentType\": \"ad culpa dolor ea aliquip\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"non ad tempor eiusmod commodo\"\n          },\n          \"dueAmount\": 27546469.818322226,\n          \"dueDate\": \"pariatur in in proident laborum\",\n          \"minimumPaymentDue\": -77478784.43800622,\n          \"partialPaymentPaid\": 78614184.00346637\n        },\n        {\n          \"cardName\": \"quis aliqua\",\n          \"cardNumber\": \"Ut in cupida\",\n          \"cardStatus\": \"ut vo\",\n          \"cardImage\": \"in Duis voluptate\",\n          \"cardType\": \"Duis amet\",\n          \"expDate\": \"officia ex Ut\",\n          \"displayCardStatus\": \"qui laboris\",\n          \"primaryCard\": \"ea elit non\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"enim nulla\",\n          \"nameOnCard\": \"et ea\",\n          \"cardNetwork\": \"qui dolore non elit anim\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"magna\",\n            \"paymentType\": \"culpa non cillum esse\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"pariatur ut cillum\"\n          },\n          \"dueAmount\": -41654271.89846982,\n          \"dueDate\": \"anim dolor quis eiusmod\",\n          \"minimumPaymentDue\": -42196685.20742785,\n          \"partialPaymentPaid\": 58655574.534342945\n        }\n      ],\n      \"IsCrossAccount\": false\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accounts` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts`)) {\n                    const value = ld.get(jsonResponse, `accounts`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field accounts:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the accounts field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts`)) {\n                    let accountsArray = ld.get(jsonResponse, `accounts`, []);\n                    if (Array.isArray(accountsArray)) {\n                        for (let accounts_it = 0; accounts_it < accountsArray.length; accounts_it++) {\n                            let iterator = accounts_it;\n                            if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accountsArray' has 'customerId' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].customerId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].customerId:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountName' has 'accountName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountNickname' has 'accountNickname' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountNickname`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountNickname:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountNumber' has 'accountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountType' has 'accountType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].activatedDate' has 'activatedDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].activatedDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].activatedDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCash' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCash`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCash:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCashLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCashLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCredit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCredit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCredit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].bankName' has 'bankName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].bankName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].bankName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].branchName' has 'branchName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].branchName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].branchName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'creditLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].creditLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].creditLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].currency' has 'currency' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].currency`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].currency:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'currentBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].currentBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].currentBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].deactivatedDate' has 'deactivatedDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].deactivatedDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].deactivatedDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'earlyWithdrawalPenalty' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].earlyWithdrawalPenalty`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].earlyWithdrawalPenalty:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].fdType' has 'fdType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].fdType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].fdType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].image' has 'image' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].image`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].image:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'interestRate' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].interestRate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].interestRate:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].internalTransferFromEnabled' has 'internalTransferFromEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].internalTransferFromEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].internalTransferFromEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].internalTransferToEnabled' has 'internalTransferToEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].internalTransferToEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].internalTransferToEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isPrimaryMobile' has 'isPrimaryMobile' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isPrimaryMobile`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isPrimaryMobile:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isAlternateMobileNumber' has 'isAlternateMobileNumber' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isAlternateMobileNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isStatement' has 'isStatement' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isStatement`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isStatement:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].lastDrawDate' has 'lastDrawDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].lastDrawDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].lastDrawDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].loanMaturityDate' has 'loanMaturityDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].loanMaturityDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].loanMaturityDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].loanOriginationDate' has 'loanOriginationDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].loanOriginationDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].loanOriginationDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].location' has 'location' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].location`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].location:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].lastUpdated' has 'lastUpdated' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].lastUpdated`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].lastUpdated:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].maxTransactionLimit' has 'maxTransactionLimit' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].maxTransactionLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].maxTransactionLimit:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].maturityDate' has 'maturityDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].maturityDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].maturityDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].minimumPaymentDue' has 'minimumPaymentDue' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].minimumBalance' has 'minimumBalance' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].minimumBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].minimumBalance:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'monthlyPayment' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].monthlyPayment`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].monthlyPayment:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'openingBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].openingBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].openingBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'originalLoanAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].originalLoanAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].originalLoanAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'P2PLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].P2PLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].P2PLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'p2pEnabled' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].p2pEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].p2pEnabled:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].paybillEnabled' has 'paybillEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].paybillEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].paybillEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'payoffAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].payoffAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].payoffAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerName' has 'personalBankerName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact' has 'personalBankerContact' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].personalBankerContact:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact.email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact.email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerContact.email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact.mobileNumber' has 'mobileNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact.mobileNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerContact.mobileNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'phone' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].phone`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].phone:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'postedBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].postedBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].postedBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].principalBalance' has 'principalBalance' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].principalBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].principalBalance:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].productCode' has 'productCode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].productCode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].productCode:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].productName' has 'productName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].productName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].productName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].propertyAddress' has 'propertyAddress' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].propertyAddress`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].propertyAddress:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].rewardPoints' has 'rewardPoints' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].rewardPoints`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].rewardPoints:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].routingNumber' has 'routingNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].routingNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].routingNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].statementDate' has 'statementDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].statementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].statementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].status' has 'status' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].status`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].status:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].swiftCode' has 'swiftCode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].swiftCode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].swiftCode:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'totalBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].totalBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].totalBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'unbilledAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].unbilledAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].unbilledAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'valueAtMaturity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].valueAtMaturity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].valueAtMaturity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'holdAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].holdAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].holdAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'unclearFundsAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].unclearFundsAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].unclearFundsAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'averageMonthlyBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].averageMonthlyBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].averageMonthlyBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'netWithdrawableBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].netWithdrawableBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].netWithdrawableBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].totalTenure' has 'totalTenure' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].totalTenure`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].totalTenure:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].remainingTenure' has 'remainingTenure' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].remainingTenure`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].remainingTenure:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].debitAccountNumber' has 'debitAccountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].debitAccountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].debitAccountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'lateFee' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].lateFee`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].lateFee:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'bounceCharge' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].bounceCharge`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].bounceCharge:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'totalCharges' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].totalCharges`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].totalCharges:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'overDueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].overDueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].overDueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'cardDetails' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails`)) {\n                    let cardDetailsArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails`, []);\n                    if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                            let iterator = cardDetails_it;\n                            if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage' has 'cardImage' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus' has 'displayCardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard' has 'primaryCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo' has 'cardChannelInfo' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM' has 'ATM' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline' has 'offline' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international' has 'international' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online' has 'online' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless' has 'contactless' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions' has 'cardRestrictions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'countries' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`)) {\n                    let countriesArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`, []);\n                    if (Array.isArray(countriesArray)) {\n                        for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                            let iterator = countries_it;\n                            if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode' has 'countrycode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'MCC' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`)) {\n                    let MCCArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`, []);\n                    if (Array.isArray(MCCArray)) {\n                        for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                            let iterator = MCC_it;\n                            if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason' has 'blockReason' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard' has 'nameOnCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork' has 'cardNetwork' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay' has 'autopay' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled' has 'enabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId' has 'sourceAccountId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType' has 'paymentType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate' has 'onStatementDate' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth' has 'dayOfMonth' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'minimumPaymentDue' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'partialPaymentPaid' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].partialPaymentPaid`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].partialPaymentPaid:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].IsCrossAccount' has 'IsCrossAccount' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].IsCrossAccount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].IsCrossAccount:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the details of the mentioned customer account",
      "request": {
        "name": "to get the details of the mentioned customer account",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountDetails"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*string}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*string}}\"\n        }\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 84082453.40818423,\n    \"accountName\": \"labore anim\",\n    \"accountNickname\": \"et ullamco\",\n    \"accountNumber\": \"voluptate amet exercitation officia est\",\n    \"accountType\": \"non nulla\",\n    \"activatedDate\": \"adipisicing voluptate in aute\",\n    \"availableBalance\": -51116268.417016506,\n    \"availableCash\": -49322301.20884218,\n    \"availableCashLimit\": -93319240.56611642,\n    \"availableCredit\": 20593561.958909005,\n    \"bankName\": \"nisi consectetur consequat dolore\",\n    \"branchName\": \"nulla voluptate\",\n    \"cardName\": \"dolore ipsum labore sed\",\n    \"cardNumber\": \"enim ex\",\n    \"cardStatus\": \"aliqua et eu magna Ut\",\n    \"cardType\": \"et in magna nisi\",\n    \"creditLimit\": -52162237.66055239,\n    \"currency\": \"do\",\n    \"currentBalance\": -10238955.590793535,\n    \"deactivatedDate\": \"non et nostrud\",\n    \"dueAmount\": 83231799.32855651,\n    \"dueDate\": \"labore aute occaecat aliqua\",\n    \"earlyWithdrawalPenalty\": 126175.86975349486,\n    \"email\": \"nulla in reprehenderit\",\n    \"expDate\": \"dolore mollit\",\n    \"fdType\": \"nisi voluptate anim\",\n    \"image\": \"Ut ut est\",\n    \"interestRate\": 10452473.212482393,\n    \"internalTransferFromEnabled\": true,\n    \"internalTransferToEnabled\": false,\n    \"isPrimaryMobile\": true,\n    \"isAlternateMobileNumber\": false,\n    \"isStatement\": true,\n    \"lastDrawDate\": \"ut dolore occaecat\",\n    \"loanMaturityDate\": \"et laboris dolor dolore\",\n    \"loanOriginationDate\": \"ullamco\",\n    \"location\": \"id sunt\",\n    \"lastUpdated\": \"laborum nostrud quis\",\n    \"maxTransactionLimit\": \"anim officia\",\n    \"maturityDate\": \"reprehenderit aute enim\",\n    \"minimumPaymentDue\": \"veniam cillum\",\n    \"minimumBalance\": \"ea in magna minim\",\n    \"monthlyPayment\": 5481279.555219665,\n    \"openingBalance\": -42407454.96150202,\n    \"originalLoanAmount\": 29101934.344163597,\n    \"P2PLimit\": -66318151.82405583,\n    \"p2pEnabled\": -94484148.6543683,\n    \"paybillEnabled\": true,\n    \"payoffAmount\": 45284253.4650996,\n    \"personalBankerName\": \"officia\",\n    \"personalBankerContact\": {\n      \"email\": \"irure\",\n      \"mobileNumber\": \"laboris sit sunt et\"\n    },\n    \"phone\": 4045244.6675511003,\n    \"postedBalance\": 7795134.962447166,\n    \"principalBalance\": \"consectetur et proident labore\",\n    \"productCode\": \"proident ad nisi irure eiusmod\",\n    \"productName\": \"dolor commodo consequat ipsum\",\n    \"propertyAddress\": \"cillum sunt sed in\",\n    \"rewardPoints\": \"quis fugiat Excepteur ea\",\n    \"routingNumber\": \"quis anim esse\",\n    \"statementDate\": \"ullamco ea ex Lorem\",\n    \"status\": \"incididunt cillum\",\n    \"swiftCode\": \"ut Duis ullamco est\",\n    \"totalBalance\": -4710116.06772764,\n    \"unbilledAmount\": 22134818.030485228,\n    \"valueAtMaturity\": -39119087.618427925,\n    \"holdAmount\": -35937799.12593229,\n    \"unclearFundsAmount\": 78033493.38849372,\n    \"averageMonthlyBalance\": 17508335.13871987,\n    \"netWithdrawableBalance\": 64942853.99382472,\n    \"totalTenure\": \"ipsum velit\",\n    \"remainingTenure\": \"qui\",\n    \"debitAccountNumber\": \"et proident\",\n    \"lateFee\": -9718140.94815375,\n    \"bounceCharge\": -90263444.87221074,\n    \"totalCharges\": -18523246.47227435,\n    \"overDueAmount\": -10559621.576873735,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"commodo in\",\n        \"cardNumber\": \"en\",\n        \"cardStatus\": \"consectetur dolore quis eiusmod\",\n        \"cardImage\": \"pariatur do Lorem eiusmod\",\n        \"cardType\": \"reprehenderit ipsum Excepteur\",\n        \"expDate\": \"Ut in laborum\",\n        \"displayCardStatus\": \"non nulla ipsum\",\n        \"primaryCard\": \"ex amet anim consequat\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"tempor ea\",\n        \"nameOnCard\": \"nostrud dolore\",\n        \"cardNetwork\": \"sint ea\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"veniam quis cupidatat laboris\",\n          \"paymentType\": \"quis esse veniam\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"veniam voluptate\"\n        },\n        \"dueAmount\": -17313677.594183967,\n        \"dueDate\": \"deserunt magna ullamco\",\n        \"minimumPaymentDue\": 75231779.14039731,\n        \"partialPaymentPaid\": 46482403.23340255\n      },\n      {\n        \"cardName\": \"incididunt voluptate\",\n        \"cardNumber\": \"adipisicing ad nisi consectetur\",\n        \"cardStatus\": \"cupidatat ullamco eu minim reprehenderit\",\n        \"cardImage\": \"eiusm\",\n        \"cardType\": \"ex exercitation qui consequat labore\",\n        \"expDate\": \"cillum sint in amet\",\n        \"displayCardStatus\": \"eiusmod cillum eu\",\n        \"primaryCard\": \"aliquip quis consequat\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"ullamco par\",\n        \"nameOnCard\": \"enim dolor eiusmod labore consectetur\",\n        \"cardNetwork\": \"reprehenderit laborum commodo\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"Lorem non anim qui\",\n          \"paymentType\": \"et par\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"non ea ullamco\"\n        },\n        \"dueAmount\": -25630807.386179373,\n        \"dueDate\": \"laborum sint\",\n        \"minimumPaymentDue\": 76035783.40366954,\n        \"partialPaymentPaid\": -4439928.4709727615\n      }\n    ],\n    \"IsCrossAccount\": true\n  },\n  {\n    \"customerId\": -21467520.08711794,\n    \"accountName\": \"veniam\",\n    \"accountNickname\": \"dolore ullamco\",\n    \"accountNumber\": \"ullamco fugiat commodo in enim\",\n    \"accountType\": \"eiusmod Lorem incididunt\",\n    \"activatedDate\": \"deserunt ipsum enim nisi\",\n    \"availableBalance\": 54676986.99107003,\n    \"availableCash\": 74654792.4097592,\n    \"availableCashLimit\": -19853450.32661949,\n    \"availableCredit\": -2235652.2269111723,\n    \"bankName\": \"in est id\",\n    \"branchName\": \"irure in incididunt cupidatat\",\n    \"cardName\": \"aliquip pariatur eiusmod\",\n    \"cardNumber\": \"est proident ullamco commodo dolore\",\n    \"cardStatus\": \"nisi officia fugiat\",\n    \"cardType\": \"non proident ex in laboris\",\n    \"creditLimit\": 56398771.42160308,\n    \"currency\": \"qui\",\n    \"currentBalance\": 97303904.11390951,\n    \"deactivatedDate\": \"ipsum id enim\",\n    \"dueAmount\": 11543116.968677402,\n    \"dueDate\": \"Lorem ipsum in sint\",\n    \"earlyWithdrawalPenalty\": -85332406.20262665,\n    \"email\": \"in magna qui aliquip non\",\n    \"expDate\": \"nostrud deserunt voluptate\",\n    \"fdType\": \"consequat proident minim magna dolore\",\n    \"image\": \"et pariatur veniam sit\",\n    \"interestRate\": -7591668.329067498,\n    \"internalTransferFromEnabled\": true,\n    \"internalTransferToEnabled\": false,\n    \"isPrimaryMobile\": true,\n    \"isAlternateMobileNumber\": false,\n    \"isStatement\": true,\n    \"lastDrawDate\": \"adipisicing nulla ad aliqua\",\n    \"loanMaturityDate\": \"deserunt laborum sint\",\n    \"loanOriginationDate\": \"aliqua incididunt\",\n    \"location\": \"dolore aute nisi sunt\",\n    \"lastUpdated\": \"velit\",\n    \"maxTransactionLimit\": \"eu minim\",\n    \"maturityDate\": \"nulla\",\n    \"minimumPaymentDue\": \"ipsum Duis\",\n    \"minimumBalance\": \"veniam eiusmod\",\n    \"monthlyPayment\": 24899481.580168724,\n    \"openingBalance\": -59734327.04886883,\n    \"originalLoanAmount\": -55536626.46230131,\n    \"P2PLimit\": 69774599.65214434,\n    \"p2pEnabled\": -82028171.21752179,\n    \"paybillEnabled\": false,\n    \"payoffAmount\": 95431316.0508093,\n    \"personalBankerName\": \"reprehenderit ex non\",\n    \"personalBankerContact\": {\n      \"email\": \"exercitation ea officia\",\n      \"mobileNumber\": \"Excepteur esse D\"\n    },\n    \"phone\": -932086.1373539418,\n    \"postedBalance\": -2269403.8050501794,\n    \"principalBalance\": \"id commodo\",\n    \"productCode\": \"aliquip Excepteur nulla ad\",\n    \"productName\": \"eu dolor sint laboris exercitation\",\n    \"propertyAddress\": \"sit fugiat\",\n    \"rewardPoints\": \"cillum\",\n    \"routingNumber\": \"labore nulla\",\n    \"statementDate\": \"adipisicing mollit deserunt\",\n    \"status\": \"voluptate incididunt sint\",\n    \"swiftCode\": \"dolore aliquip non fugiat\",\n    \"totalBalance\": -9630627.308878735,\n    \"unbilledAmount\": 97553169.55901548,\n    \"valueAtMaturity\": -24326821.474909097,\n    \"holdAmount\": 95737202.58053288,\n    \"unclearFundsAmount\": -3775061.835515544,\n    \"averageMonthlyBalance\": 14623405.718206868,\n    \"netWithdrawableBalance\": -71996087.76169649,\n    \"totalTenure\": \"dolore mollit\",\n    \"remainingTenure\": \"Lorem in\",\n    \"debitAccountNumber\": \"ut eiusmod laboris Ut non\",\n    \"lateFee\": 67698456.17649284,\n    \"bounceCharge\": -51133305.714971215,\n    \"totalCharges\": 66497939.00893068,\n    \"overDueAmount\": 32453274.576549962,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"nostrud\",\n        \"cardNumber\": \"non aliquip Duis consequat\",\n        \"cardStatus\": \"consectetur officia cillum pariatur\",\n        \"cardImage\": \"elit dolore est proident\",\n        \"cardType\": \"dolor dolor magna ullamco\",\n        \"expDate\": \"ullamco tempor \",\n        \"displayCardStatus\": \"deserunt eiusmod nisi\",\n        \"primaryCard\": \"in eu\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"ipsum incididunt sed id Ut\",\n        \"nameOnCard\": \"laboris eu\",\n        \"cardNetwork\": \"quis ex sint\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"minim\",\n          \"paymentType\": \"aliquip nostrud elit nulla\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"qui ullamco ipsum consectetur\"\n        },\n        \"dueAmount\": -52446443.046205446,\n        \"dueDate\": \"commodo\",\n        \"minimumPaymentDue\": -45175387.70281888,\n        \"partialPaymentPaid\": 65590343.208099484\n      },\n      {\n        \"cardName\": \"non\",\n        \"cardNumber\": \"pariatur id\",\n        \"cardStatus\": \"sint\",\n        \"cardImage\": \"labore sint\",\n        \"cardType\": \"reprehenderit eiusmod laboris officia proident\",\n        \"expDate\": \"ad et mollit cillum ex\",\n        \"displayCardStatus\": \"amet sit mollit aliqua\",\n        \"primaryCard\": \"do aliqua nisi ess\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"pariatur Duis magna in\",\n        \"nameOnCard\": \"nisi nostrud\",\n        \"cardNetwork\": \"dolor in officia Lorem dolore\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"cillum Excepte\",\n          \"paymentType\": \"sed elit Duis in\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"consequat dolore Duis non d\"\n        },\n        \"dueAmount\": 56777168.74531543,\n        \"dueDate\": \"elit do non\",\n        \"minimumPaymentDue\": -2548851.9464759827,\n        \"partialPaymentPaid\": 23706994.681990817\n      }\n    ],\n    \"IsCrossAccount\": false\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountDetails for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountName`)) {\n                    const value = ld.get(jsonResponse, `accountName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNickname` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNickname`)) {\n                    const value = ld.get(jsonResponse, `accountNickname`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNickname:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountType`)) {\n                    const value = ld.get(jsonResponse, `accountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `activatedDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`activatedDate`)) {\n                    const value = ld.get(jsonResponse, `activatedDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field activatedDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableBalance`)) {\n                    const value = ld.get(responseData, `availableBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCash` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCash`)) {\n                    const value = ld.get(responseData, `availableCash`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCash:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCashLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCashLimit`)) {\n                    const value = ld.get(responseData, `availableCashLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCredit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCredit`)) {\n                    const value = ld.get(responseData, `availableCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `bankName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`bankName`)) {\n                    const value = ld.get(jsonResponse, `bankName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field bankName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `branchName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`branchName`)) {\n                    const value = ld.get(jsonResponse, `branchName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field branchName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardName`)) {\n                    const value = ld.get(jsonResponse, `cardName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardStatus` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardStatus`)) {\n                    const value = ld.get(jsonResponse, `cardStatus`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardStatus:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardType`)) {\n                    const value = ld.get(jsonResponse, `cardType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `creditLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`creditLimit`)) {\n                    const value = ld.get(responseData, `creditLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field creditLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currentBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`currentBalance`)) {\n                    const value = ld.get(responseData, `currentBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field currentBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `deactivatedDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`deactivatedDate`)) {\n                    const value = ld.get(jsonResponse, `deactivatedDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field deactivatedDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `dueAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`dueAmount`)) {\n                    const value = ld.get(responseData, `dueAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field dueAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `dueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`dueDate`)) {\n                    const value = ld.get(jsonResponse, `dueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field dueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `earlyWithdrawalPenalty` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`earlyWithdrawalPenalty`)) {\n                    const value = ld.get(responseData, `earlyWithdrawalPenalty`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field earlyWithdrawalPenalty:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `expDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`expDate`)) {\n                    const value = ld.get(jsonResponse, `expDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field expDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `fdType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`fdType`)) {\n                    const value = ld.get(jsonResponse, `fdType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field fdType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `interestRate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`interestRate`)) {\n                    const value = ld.get(responseData, `interestRate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field interestRate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `internalTransferFromEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`internalTransferFromEnabled`)) {\n                    const value = ld.get(jsonResponse, `internalTransferFromEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field internalTransferFromEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `internalTransferToEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`internalTransferToEnabled`)) {\n                    const value = ld.get(jsonResponse, `internalTransferToEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field internalTransferToEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobile` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobile`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobile`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobile:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isStatement` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isStatement`)) {\n                    const value = ld.get(jsonResponse, `isStatement`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isStatement:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastDrawDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastDrawDate`)) {\n                    const value = ld.get(jsonResponse, `lastDrawDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastDrawDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `loanMaturityDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`loanMaturityDate`)) {\n                    const value = ld.get(jsonResponse, `loanMaturityDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field loanMaturityDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `loanOriginationDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`loanOriginationDate`)) {\n                    const value = ld.get(jsonResponse, `loanOriginationDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field loanOriginationDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastUpdated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastUpdated`)) {\n                    const value = ld.get(jsonResponse, `lastUpdated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastUpdated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `maxTransactionLimit` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`maxTransactionLimit`)) {\n                    const value = ld.get(jsonResponse, `maxTransactionLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field maxTransactionLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `maturityDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`maturityDate`)) {\n                    const value = ld.get(jsonResponse, `maturityDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field maturityDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `minimumPaymentDue` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`minimumPaymentDue`)) {\n                    const value = ld.get(jsonResponse, `minimumPaymentDue`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `minimumBalance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`minimumBalance`)) {\n                    const value = ld.get(jsonResponse, `minimumBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field minimumBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `monthlyPayment` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`monthlyPayment`)) {\n                    const value = ld.get(responseData, `monthlyPayment`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field monthlyPayment:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `openingBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`openingBalance`)) {\n                    const value = ld.get(responseData, `openingBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field openingBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `originalLoanAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`originalLoanAmount`)) {\n                    const value = ld.get(responseData, `originalLoanAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field originalLoanAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `P2PLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`P2PLimit`)) {\n                    const value = ld.get(responseData, `P2PLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field P2PLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `p2pEnabled` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`p2pEnabled`)) {\n                    const value = ld.get(responseData, `p2pEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field p2pEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `paybillEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`paybillEnabled`)) {\n                    const value = ld.get(jsonResponse, `paybillEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field paybillEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `payoffAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`payoffAmount`)) {\n                    const value = ld.get(responseData, `payoffAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field payoffAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerName`)) {\n                    const value = ld.get(jsonResponse, `personalBankerName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBankerContact:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact.email`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerContact.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerContact.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `postedBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`postedBalance`)) {\n                    const value = ld.get(responseData, `postedBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field postedBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `principalBalance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`principalBalance`)) {\n                    const value = ld.get(jsonResponse, `principalBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field principalBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `productCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`productCode`)) {\n                    const value = ld.get(jsonResponse, `productCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field productCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `productName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`productName`)) {\n                    const value = ld.get(jsonResponse, `productName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field productName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `propertyAddress` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`propertyAddress`)) {\n                    const value = ld.get(jsonResponse, `propertyAddress`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field propertyAddress:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `rewardPoints` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`rewardPoints`)) {\n                    const value = ld.get(jsonResponse, `rewardPoints`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field rewardPoints:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `routingNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`routingNumber`)) {\n                    const value = ld.get(jsonResponse, `routingNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field routingNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `statementDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`statementDate`)) {\n                    const value = ld.get(jsonResponse, `statementDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field statementDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `swiftCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`swiftCode`)) {\n                    const value = ld.get(jsonResponse, `swiftCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field swiftCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`totalBalance`)) {\n                    const value = ld.get(responseData, `totalBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field totalBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `unbilledAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`unbilledAmount`)) {\n                    const value = ld.get(responseData, `unbilledAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field unbilledAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `valueAtMaturity` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`valueAtMaturity`)) {\n                    const value = ld.get(responseData, `valueAtMaturity`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field valueAtMaturity:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `holdAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`holdAmount`)) {\n                    const value = ld.get(responseData, `holdAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field holdAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `unclearFundsAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`unclearFundsAmount`)) {\n                    const value = ld.get(responseData, `unclearFundsAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field unclearFundsAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `averageMonthlyBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`averageMonthlyBalance`)) {\n                    const value = ld.get(responseData, `averageMonthlyBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field averageMonthlyBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `netWithdrawableBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`netWithdrawableBalance`)) {\n                    const value = ld.get(responseData, `netWithdrawableBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field netWithdrawableBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalTenure` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`totalTenure`)) {\n                    const value = ld.get(jsonResponse, `totalTenure`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field totalTenure:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `remainingTenure` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`remainingTenure`)) {\n                    const value = ld.get(jsonResponse, `remainingTenure`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field remainingTenure:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `debitAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`debitAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `debitAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field debitAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lateFee` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lateFee`)) {\n                    const value = ld.get(responseData, `lateFee`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lateFee:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `bounceCharge` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`bounceCharge`)) {\n                    const value = ld.get(responseData, `bounceCharge`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field bounceCharge:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalCharges` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`totalCharges`)) {\n                    const value = ld.get(responseData, `totalCharges`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field totalCharges:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `overDueAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`overDueAmount`)) {\n                    const value = ld.get(responseData, `overDueAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field overDueAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    const value = ld.get(jsonResponse, `cardDetails`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field cardDetails:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the cardDetails field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    let cardDetailsArray = ld.get(jsonResponse, `cardDetails`, []);\n                    if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                            let iterator = cardDetails_it;\n                            if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardImage' has 'cardImage' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardImage`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardImage:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].displayCardStatus' has 'displayCardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].displayCardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].displayCardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].primaryCard' has 'primaryCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].primaryCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].primaryCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo' has 'cardChannelInfo' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.ATM' has 'ATM' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.ATM`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.offline' has 'offline' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.offline`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.offline:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.international' has 'international' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.international`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.international:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.international.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.international.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.international.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.international.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.international.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.online' has 'online' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.online`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.online:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.online.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.online.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.online.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.online.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.online.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.contactless' has 'contactless' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.contactless`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions' has 'cardRestrictions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardRestrictions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'countries' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.countries`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the cardDetails[${cardDetails_it}].cardRestrictions.countries field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails[${cardDetails_it}].cardRestrictions.countries`)) {\n                    let countriesArray = ld.get(jsonResponse, `cardDetails[${cardDetails_it}].cardRestrictions.countries`, []);\n                    if (Array.isArray(countriesArray)) {\n                        for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                            let iterator = countries_it;\n                            if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode' has 'countrycode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'MCC' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the cardDetails[${cardDetails_it}].cardRestrictions.MCC field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails[${cardDetails_it}].cardRestrictions.MCC`)) {\n                    let MCCArray = ld.get(jsonResponse, `cardDetails[${cardDetails_it}].cardRestrictions.MCC`, []);\n                    if (Array.isArray(MCCArray)) {\n                        for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                            let iterator = MCC_it;\n                            if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].blockReason' has 'blockReason' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].blockReason`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].blockReason:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].nameOnCard' has 'nameOnCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].nameOnCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].nameOnCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardNetwork' has 'cardNetwork' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardNetwork`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardNetwork:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay' has 'autopay' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].autopay:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.enabled' has 'enabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.enabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].autopay.enabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.sourceAccountId' has 'sourceAccountId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.sourceAccountId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.sourceAccountId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.paymentType' has 'paymentType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.paymentType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.paymentType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.onStatementDate' has 'onStatementDate' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.onStatementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].autopay.onStatementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.dayOfMonth' has 'dayOfMonth' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.dayOfMonth`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.dayOfMonth:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'minimumPaymentDue' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'partialPaymentPaid' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].partialPaymentPaid`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].partialPaymentPaid:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `IsCrossAccount` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`IsCrossAccount`)) {\n                    const value = ld.get(jsonResponse, `IsCrossAccount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field IsCrossAccount:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountsLimit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"accountName\": \"Ut ex\",\n    \"accountNickname\": \"Duis enim\",\n    \"accountNumber\": \"commodo eu adi\",\n    \"accountType\": \"aliqua ut id ex\",\n    \"balance\": \"ex exercitation aute et\",\n    \"cardName\": \"nostrud ipsum\",\n    \"cardNumber\": \"cupidatat deserunt consequat laborum\",\n    \"currency\": \"tempor dolore enim ipsum\",\n    \"customerId\": -13111362.619605199,\n    \"perTxn\": -69085821.4546482,\n    \"status\": \"sit pariatur\",\n    \"availableCashLimit\": 6485463.601287872,\n    \"creditLimit\": 91229608.13280544,\n    \"availableCredit\": 90291879.29464686,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 49529005.97124234,\n          \"maximum\": -45095664.8173384,\n          \"spent\": 12190178.419489056\n        },\n        \"daily\": {\n          \"available\": -29836743.031516686,\n          \"maximum\": -92727070.16429776,\n          \"spent\": -89817023.56854214\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 19516026.84276557,\n          \"maximum\": 68322991.21218899,\n          \"usedup\": -78265123.16916281\n        },\n        \"daily\": {\n          \"available\": -29649817.18015927,\n          \"maximum\": -44197858.778605156,\n          \"usedup\": 22647139.26834126\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": -43437033.14536498,\n      \"maximum\": 5701149.398803502,\n      \"usedup\": 62078753.75655326,\n      \"amountperday\": -56579512.229906246\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 30604719.84915711,\n          \"maximum\": -68718685.09838395,\n          \"spent\": 86721534.06410468\n        },\n        \"daily\": {\n          \"available\": 75760928.84995663,\n          \"maximum\": 15979763.089003816,\n          \"spent\": -33488245.89858137\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 74573382.36184573,\n          \"maximum\": -74764479.6572232,\n          \"usedup\": 49419077.655306816\n        },\n        \"daily\": {\n          \"available\": -36200374.68411206,\n          \"maximum\": -3548008.9835453928,\n          \"usedup\": -54209787.61201591\n        }\n      }\n    }\n  },\n  {\n    \"accountName\": \"ex pariatur\",\n    \"accountNickname\": \"cillum sit\",\n    \"accountNumber\": \"ve\",\n    \"accountType\": \"pariatur voluptate\",\n    \"balance\": \"ad\",\n    \"cardName\": \"in do\",\n    \"cardNumber\": \"quis sunt minim deserunt in\",\n    \"currency\": \"ullamco dolore eu\",\n    \"customerId\": 98823217.84161258,\n    \"perTxn\": 35657530.337956846,\n    \"status\": \"commodo veniam ut in eiusm\",\n    \"availableCashLimit\": -23078009.840082496,\n    \"creditLimit\": 18952718.114947096,\n    \"availableCredit\": 42817373.65610877,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 50844331.362986,\n          \"maximum\": -9804855.790194675,\n          \"spent\": 279237.72830194235\n        },\n        \"daily\": {\n          \"available\": 26410800.04528007,\n          \"maximum\": 4053664.9234449267,\n          \"spent\": 74174691.90626839\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": -7093608.120024398,\n          \"maximum\": -12465728.555221751,\n          \"usedup\": -3523672.0505382717\n        },\n        \"daily\": {\n          \"available\": -76376384.56419796,\n          \"maximum\": 44588828.81609839,\n          \"usedup\": 85250192.18669775\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 54976738.57621437,\n      \"maximum\": 3686955.8602406383,\n      \"usedup\": -70369728.85045886,\n      \"amountperday\": 576642.9708704948\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 23527977.073285997,\n          \"maximum\": 38785459.0357784,\n          \"spent\": 68459496.15829915\n        },\n        \"daily\": {\n          \"available\": -60946087.83666224,\n          \"maximum\": 88332873.4381068,\n          \"spent\": 64709023.83578777\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": -88647815.94963707,\n          \"maximum\": 24326699.168567553,\n          \"usedup\": -60444221.98438584\n        },\n        \"daily\": {\n          \"available\": 37555485.50008649,\n          \"maximum\": -35495952.8353751,\n          \"usedup\": 78224952.27919796\n        }\n      }\n    }\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountsLimit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `accountName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountName`)) {\n                    const value = ld.get(jsonResponse, `accountName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNickname` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNickname`)) {\n                    const value = ld.get(jsonResponse, `accountNickname`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNickname:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountType`)) {\n                    const value = ld.get(jsonResponse, `accountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `balance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`balance`)) {\n                    const value = ld.get(jsonResponse, `balance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field balance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardName`)) {\n                    const value = ld.get(jsonResponse, `cardName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `perTxn` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`perTxn`)) {\n                    const value = ld.get(responseData, `perTxn`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field perTxn:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCashLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCashLimit`)) {\n                    const value = ld.get(responseData, `availableCashLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `creditLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`creditLimit`)) {\n                    const value = ld.get(responseData, `creditLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field creditLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCredit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCredit`)) {\n                    const value = ld.get(responseData, `availableCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase`)) {\n                    const value = ld.get(jsonResponse, `purchase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`txnsPerDay`)) {\n                    const value = ld.get(jsonResponse, `txnsPerDay`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field txnsPerDay:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.available` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.available`)) {\n                    const value = ld.get(responseData, `txnsPerDay.available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.maximum` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.maximum`)) {\n                    const value = ld.get(responseData, `txnsPerDay.maximum`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.maximum:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.usedup` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.usedup`)) {\n                    const value = ld.get(responseData, `txnsPerDay.usedup`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.usedup:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.amountperday` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.amountperday`)) {\n                    const value = ld.get(responseData, `txnsPerDay.amountperday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.amountperday:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal`)) {\n                    const value = ld.get(jsonResponse, `withdrawal`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.daily:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountSpecificLimitsInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 1045300,\n    \"currency\": \"USD\",\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 5,\n      \"maximum\": 8,\n      \"usedup\": 3,\n      \"amount\": 500\n    },\n    \"perTxn\": 500\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountSpecificLimitsInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `perTxn` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`perTxn`)) {\n                    const value = ld.get(responseData, `perTxn`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field perTxn:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase`)) {\n                    const value = ld.get(jsonResponse, `purchase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`txnsPerDay`)) {\n                    const value = ld.get(jsonResponse, `txnsPerDay`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field txnsPerDay:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.available` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.available`)) {\n                    const value = ld.get(responseData, `txnsPerDay.available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.maximum` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.maximum`)) {\n                    const value = ld.get(responseData, `txnsPerDay.maximum`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.maximum:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.usedup` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.usedup`)) {\n                    const value = ld.get(responseData, `txnsPerDay.usedup`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.usedup:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.amount`)) {\n                    const value = ld.get(responseData, `txnsPerDay.amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal`)) {\n                    const value = ld.get(jsonResponse, `withdrawal`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.daily:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateAccountInfo",
      "request": {
        "name": "UpdateAccountInfo",
        "description": {
          "content": "Update customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateAccountInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCustomerInfo",
      "request": {
        "name": "GetCustomerInfo",
        "description": {
          "content": "fetch customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"alternatePhoneNumber\": 39493416.20522851,\n  \"customerId\": \"reprehenderit pariatur elit\",\n  \"email\": \"sit est\",\n  \"identificationNumber\": 80910098.71952522,\n  \"identificationType\": \"ex est velit irure\",\n  \"image\": \"dolor eiusmod\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": false,\n  \"location\": \"minim tempor officia nostrud qui\",\n  \"name\": \"culpa nulla\",\n  \"firstName\": \"anim aliquip amet exercitation ut\",\n  \"lastName\": \"ut adipisicing\",\n  \"personalBanker\": {\n    \"name\": \"Lorem elit officia non ex\",\n    \"email\": \"aute laborum minim vol\",\n    \"mobileNumber\": \"consequat cillum laboris ex\"\n  },\n  \"phone\": 50094974.084962904,\n  \"securityQuestions\": [\n    \"Excepteur dolore labore cillum\",\n    \"culpa dolor laborum anim\"\n  ],\n  \"segmentId\": 88739575.23265103\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCustomerInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `alternatePhoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`alternatePhoneNumber`)) {\n                    const value = ld.get(responseData, `alternatePhoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(jsonResponse, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`identificationNumber`)) {\n                    const value = ld.get(responseData, `identificationNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field identificationNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationType`)) {\n                    const value = ld.get(jsonResponse, `identificationType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `firstName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`firstName`)) {\n                    const value = ld.get(jsonResponse, `firstName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field firstName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastName`)) {\n                    const value = ld.get(jsonResponse, `lastName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker`)) {\n                    const value = ld.get(jsonResponse, `personalBanker`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBanker:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.name`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.email`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `securityQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`securityQuestions`)) {\n                    const value = ld.get(jsonResponse, `securityQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field securityQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `segmentId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`segmentId`)) {\n                    const value = ld.get(responseData, `segmentId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field segmentId:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateCustomerInfo",
      "request": {
        "name": "UpdateCustomerInfo",
        "description": {
          "content": "Update customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateCustomerInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetTransactions",
      "request": {
        "name": "GetTransactions",
        "description": {
          "content": "Fetch transactions information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetTransactions"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetTransactions"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": -99631831.18173543,\n    \"transactionId\": 46391087.45804608,\n    \"accountNumber\": \"dolore\",\n    \"timestamp\": 66949823.29395223,\n    \"amount\": 54994522.89601833,\n    \"currency\": \"molli\",\n    \"debitOrCredit\": \"magna labore do cupidatat in\",\n    \"description\": \"Excepteur sit\",\n    \"paymentMode\": \"enim ex\",\n    \"DBANames\": \"laborum ut dolor consectetur nisi\",\n    \"status\": \"exercitation ullamco adipisicing\",\n    \"closingBalance\": 59975873.24970874,\n    \"transacitonType\": \"Duis laboris Ut minim in\",\n    \"ACHCode\": \"in dolor ut aliqua\",\n    \"MCCCode\": \"ex magna reprehenderit\",\n    \"SICCode\": \"ad in deserunt\",\n    \"name\": \"tempor qui velit\",\n    \"address\": \"exercitation\",\n    \"street\": \"enim dolor ex\",\n    \"city\": \"velit qui Duis Excepteur\",\n    \"state\": \"consectetur voluptate\",\n    \"zip\": \"et aliquip\",\n    \"country\": \"cupidatat nostrud tempor minim\",\n    \"phoneNumber\": -45571478.263453536,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  },\n  {\n    \"customerId\": 70069538.61632347,\n    \"transactionId\": -66854812.030459285,\n    \"accountNumber\": \"commodo et \",\n    \"timestamp\": 27650337.85086572,\n    \"amount\": 49924531.79965466,\n    \"currency\": \"esse\",\n    \"debitOrCredit\": \"mollit pariatur magna quis culpa\",\n    \"description\": \"est deserunt\",\n    \"paymentMode\": \"mollit\",\n    \"DBANames\": \"eu commodo\",\n    \"status\": \"esse consequat amet labor\",\n    \"closingBalance\": 70488361.070602,\n    \"transacitonType\": \"eu culpa dolor ut\",\n    \"ACHCode\": \"esse dolore\",\n    \"MCCCode\": \"mollit non ullamco labore cupidatat\",\n    \"SICCode\": \"veniam\",\n    \"name\": \"dolore esse\",\n    \"address\": \"incididunt nisi reprehenderit\",\n    \"street\": \"ad sit\",\n    \"city\": \"sit minim eiusmod\",\n    \"state\": \"ipsum dolore aute dolor deserunt\",\n    \"zip\": \"in\",\n    \"country\": \"ex nostrud\",\n    \"phoneNumber\": -50715390.482197,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetTransactions for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `transactionId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`transactionId`)) {\n                    const value = ld.get(responseData, `transactionId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field transactionId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `timestamp` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`timestamp`)) {\n                    const value = ld.get(responseData, `timestamp`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field timestamp:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`amount`)) {\n                    const value = ld.get(responseData, `amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `debitOrCredit` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`debitOrCredit`)) {\n                    const value = ld.get(jsonResponse, `debitOrCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field debitOrCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `description` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`description`)) {\n                    const value = ld.get(jsonResponse, `description`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field description:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `paymentMode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`paymentMode`)) {\n                    const value = ld.get(jsonResponse, `paymentMode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field paymentMode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DBANames` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DBANames`)) {\n                    const value = ld.get(jsonResponse, `DBANames`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DBANames:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `closingBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`closingBalance`)) {\n                    const value = ld.get(responseData, `closingBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field closingBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `transacitonType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`transacitonType`)) {\n                    const value = ld.get(jsonResponse, `transacitonType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field transacitonType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ACHCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`ACHCode`)) {\n                    const value = ld.get(jsonResponse, `ACHCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field ACHCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `MCCCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`MCCCode`)) {\n                    const value = ld.get(jsonResponse, `MCCCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field MCCCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SICCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SICCode`)) {\n                    const value = ld.get(jsonResponse, `SICCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SICCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `address` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`address`)) {\n                    const value = ld.get(jsonResponse, `address`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field address:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `street` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`street`)) {\n                    const value = ld.get(jsonResponse, `street`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field street:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `city` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`city`)) {\n                    const value = ld.get(jsonResponse, `city`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field city:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `state` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`state`)) {\n                    const value = ld.get(jsonResponse, `state`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field state:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `zip` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`zip`)) {\n                    const value = ld.get(jsonResponse, `zip`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field zip:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country`)) {\n                    const value = ld.get(jsonResponse, `country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phoneNumber`)) {\n                    const value = ld.get(responseData, `phoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metaInfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metaInfo`)) {\n                    const value = ld.get(jsonResponse, `metaInfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field metaInfo:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the metaInfo field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metaInfo`)) {\n                    let metaInfoArray = ld.get(jsonResponse, `metaInfo`, []);\n                    if (Array.isArray(metaInfoArray)) {\n                        for (let metaInfo_it = 0; metaInfo_it < metaInfoArray.length; metaInfo_it++) {\n                            let iterator = metaInfo_it;\n                            if (metaInfoArray[metaInfo_it] !== null && metaInfoArray[metaInfo_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'metaInfo[${metaInfo_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `metaInfo[${metaInfo_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for metaInfo[${metaInfo_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'metaInfo[${metaInfo_it}].value' has 'value' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `metaInfo[${metaInfo_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for metaInfo[${metaInfo_it}].value:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for metaInfo:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "TransferFunds",
      "request": {
        "name": "TransferFunds",
        "description": {
          "content": "Transfers funds between accounts",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "TransferFunds"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*string}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Transaction success",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for TransferFunds for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Transaction success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetScheduleTransfers",
      "request": {
        "name": "GetScheduleTransfers",
        "description": {
          "content": "Fetches the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"sunt est do\",\n    \"CustomerId\": 83918858.2408207,\n    \"Amount\": 7549985.945837006,\n    \"SourceAccountNumber\": \"Ut sed veniam incididunt\",\n    \"TargetAccountNumber\": \"qui anim cillum in\",\n    \"DueDate\": \"veniam dolore\",\n    \"InvoiceNumber\": -33551524.433842413,\n    \"Currency\": \"enim consequat cillum amet\",\n    \"Status\": \"id eiusmod cillum ad\",\n    \"ScheduledDate\": -57366738.02992027,\n    \"NextScheduleDate\": 16367063.729045391,\n    \"id\": \"labore in in\"\n  },\n  {\n    \"Type\": \"exercitati\",\n    \"CustomerId\": -95790266.69455098,\n    \"Amount\": 73526013.9439666,\n    \"SourceAccountNumber\": \"sunt\",\n    \"TargetAccountNumber\": \"tempor reprehenderit in Duis\",\n    \"DueDate\": \"dolor do consectetur Lorem\",\n    \"InvoiceNumber\": 30986085.69801958,\n    \"Currency\": \"consequat veniam sed\",\n    \"Status\": \"nulla\",\n    \"ScheduledDate\": 15301985.732630193,\n    \"NextScheduleDate\": -30830163.301588476,\n    \"id\": \"sunt incididunt in\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `InvoiceNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`InvoiceNumber`)) {\n                    const value = ld.get(responseData, `InvoiceNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field InvoiceNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ScheduledDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ScheduledDate`)) {\n                    const value = ld.get(responseData, `ScheduledDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ScheduledDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `NextScheduleDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`NextScheduleDate`)) {\n                    const value = ld.get(responseData, `NextScheduleDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field NextScheduleDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateScheduleTransfers",
      "request": {
        "name": "UpdateScheduleTransfers",
        "description": {
          "content": "Update the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateScheduleTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Scheduled transfer updated successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteScheduleTransfers",
      "request": {
        "name": "DeleteScheduleTransfers",
        "description": {
          "content": "Delete the scheduled transfer",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Scheduled transfer deleted successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AddRecurringTransfers",
      "request": {
        "name": "AddRecurringTransfers",
        "description": {
          "content": "Adds the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "AddRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer added successfully",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for AddRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer added successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetRecurringTransfers",
      "request": {
        "name": "GetRecurringTransfers",
        "description": {
          "content": "Fetches all the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"commodo id laboris culpa Excepteur\",\n    \"CustomerId\": 98741453.64038455,\n    \"Amount\": -27355964.119235486,\n    \"SourceAccountNumber\": \"minim reprehenderit\",\n    \"TargetAccountNumber\": \"exercitation sunt laborum veniam\",\n    \"DueDate\": \"qui et\",\n    \"Currency\": \"eu officia consectetur\",\n    \"Status\": \"laborum elit nulla sit deserunt\",\n    \"ScheduledDate\": 41381345.951936364,\n    \"recurringOptions\": {\n      \"amountType\": \"eu officia\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"labore tempor ipsum\",\n          \"untilDate\": \"ea commodo\",\n          \"numberOfPayments\": \"anim commodo velit dolore\"\n        },\n        \"iterate\": \"laborum\"\n      }\n    },\n    \"id\": \"Duis culpa aliquip\"\n  },\n  {\n    \"Type\": \"id do minim esse\",\n    \"CustomerId\": -88485085.92866766,\n    \"Amount\": -92512414.87726864,\n    \"SourceAccountNumber\": \"non Ut in dolore\",\n    \"TargetAccountNumber\": \"minim\",\n    \"DueDate\": \"non\",\n    \"Currency\": \"laborum nulla fugiat deserunt\",\n    \"Status\": \"eu commodo\",\n    \"ScheduledDate\": -76635025.40155572,\n    \"recurringOptions\": {\n      \"amountType\": \"nulla\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"ipsum\",\n          \"untilDate\": \"tempor qui exercitation nulla\",\n          \"numberOfPayments\": \"minim labore pariatur\"\n        },\n        \"iterate\": \"proident ea sint\"\n      }\n    },\n    \"id\": \"cupid\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ScheduledDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ScheduledDate`)) {\n                    const value = ld.get(responseData, `ScheduledDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ScheduledDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.amountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.amountType`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.amountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field recurringOptions.amountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions.frequency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency.duration` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency.duration`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency.duration`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions.frequency.duration:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency.iterate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency.iterate`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency.iterate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field recurringOptions.frequency.iterate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateRecurringTransfers",
      "request": {
        "name": "UpdateRecurringTransfers",
        "description": {
          "content": "Update the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            },\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\"\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateRecurringTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Recurring transfer updated successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteRecurringTransfers",
      "request": {
        "name": "DeleteRecurringTransfers",
        "description": {
          "content": "Delete the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Recurring transfer deleted successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "resetPassword",
      "request": {
        "name": "resetPassword",
        "description": {
          "content": "It allows to reset the password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "resetPassword"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"password\": \"{{password_*string}}\",\n    \"username\": \"{{username_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "password has been updated successfully.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for resetPassword for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"password has been updated successfully.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "debitcardInfoValidation",
      "request": {
        "name": "debitcardInfoValidation",
        "description": {
          "content": "for validating card info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "debitcardInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*string}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*string}}\",\n    \"expiryDate\": \"{{expiryDate_*string}}\",\n    \"pin\": \"{{pin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for debitcardInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Validated Successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "personalInfoValidation",
      "request": {
        "name": "personalInfoValidation",
        "description": {
          "content": "for validating personal info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "personalInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*string}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*string}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for personalInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Validated Successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "disputeTransaction",
      "request": {
        "name": "disputeTransaction",
        "description": {
          "content": "dispute a transaction",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "disputeTransaction"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Dispute Transactions reported successfully",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for disputeTransaction for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Dispute Transactions reported successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "ccPay",
      "request": {
        "name": "ccPay",
        "description": {
          "content": "to pay cc bill",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "ccPay"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Credit Card payment scheduled successfully",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for ccPay for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Credit Card payment scheduled successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCCSchedule",
      "request": {
        "name": "GetCCSchedule",
        "description": {
          "content": "Fetch cc payment list",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCCSchedule"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"dolor nisi ipsum irure\",\n    \"CustomerId\": 77295598.36510599,\n    \"Amount\": -66110614.65167789,\n    \"SourceAccountNumber\": \"dolor ut\",\n    \"TargetAccountNumber\": \"irure amet et\",\n    \"DueDate\": \"repreh\",\n    \"Currency\": \"eiusmod in occaecat\",\n    \"Status\": \"cupidatat sunt magna elit pariatur\",\n    \"id\": \"commodo\"\n  },\n  {\n    \"Type\": \"adipisicing ut labore consectetur\",\n    \"CustomerId\": -29500179.317725644,\n    \"Amount\": -5417872.331367195,\n    \"SourceAccountNumber\": \"sunt aliqua anim ullamco\",\n    \"TargetAccountNumber\": \"sint cupidatat est\",\n    \"DueDate\": \"est\",\n    \"Currency\": \"adipisicing consequat irure\",\n    \"Status\": \"sint enim Lorem dolor\",\n    \"id\": \"occaecat\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCCSchedule for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendsecuremessage",
      "request": {
        "name": "sendsecuremessage",
        "description": {
          "content": "send secure message",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendsecuremessage"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendsecuremessage for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "locateProfile",
      "request": {
        "name": "locateProfile",
        "description": {
          "content": "get profile details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "locateProfile"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"accountNumber\": \"Excepteur commodo\",\n  \"cardDetails\": {\n    \"cardNumber\": \"ut Ut\",\n    \"expiryDate\": \"commodo officia\",\n    \"cvv\": \"dolore deserunt\",\n    \"pin\": \"in anim aliqua laboris\"\n  },\n  \"personalQuestions\": {\n    \"DOB\": \"adipisicing\",\n    \"SSN\": 34259526.63554165,\n    \"SecretPassword\": \"consequat in\",\n    \"LDAmount\": -51484314.80944184,\n    \"AccNumber\": \"consectetur fugiat\"\n  },\n  \"ssNumber\": 72180341.00182784,\n  \"ssnShort\": -30981890.273043394,\n  \"alternatePhoneNumber\": -78329406.40104246,\n  \"customerId\": \"qui deserunt\",\n  \"email\": \"tempor et anim Lorem\",\n  \"identificationNumber\": \"velit deserunt ea\",\n  \"identificationType\": \"eiusmod\",\n  \"image\": \"ut ea\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": false,\n  \"location\": \"magna incididun\",\n  \"name\": \"deserunt\",\n  \"personalBanker\": {\n    \"name\": \"eu nostrud exercitation\",\n    \"email\": \"voluptate nostrud\",\n    \"mobileNumber\": \"amet aute\"\n  },\n  \"phone\": 41495766.05944604,\n  \"securityQuestions\": [\n    \"Excepteur dolor eiusmod cillum ex\",\n    \"enim voluptate\"\n  ],\n  \"segmentId\": 2905695.0758274496,\n  \"multiAccounts\": [\n    {\n      \"accountNumber\": \"amet sint laborum\",\n      \"cardDetails\": {\n        \"cardNumber\": \"reprehenderit L\",\n        \"expiryDate\": \"aliqua laboris in consequat\",\n        \"cvv\": \"occaecat id minim mollit\",\n        \"pin\": \"commodo\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"commodo occaecat\",\n        \"SSN\": -95916853.76613727,\n        \"SecretPassword\": \"amet est\",\n        \"LDAmount\": -51773139.335106276,\n        \"AccNumber\": \"incididunt enim ad labore adipisicing\"\n      },\n      \"ssNumber\": 89526120.16154543,\n      \"ssnShort\": -42011632.10079923,\n      \"alternatePhoneNumber\": 2741000.6483315825,\n      \"customerId\": \"dolore laboris fugiat dolor\",\n      \"email\": \"mollit\",\n      \"identificationNumber\": \"aliquip amet laborum est\",\n      \"identificationType\": \"consectetur sunt commodo veniam\",\n      \"location\": \"dolore magna ipsum\",\n      \"name\": \"velit proident\",\n      \"phone\": 80405175.41453868\n    },\n    {\n      \"accountNumber\": \"sunt ut minim aliquip\",\n      \"cardDetails\": {\n        \"cardNumber\": \"mollit dolore \",\n        \"expiryDate\": \"voluptate esse sit aliqua eiusmod\",\n        \"cvv\": \"exercitation et\",\n        \"pin\": \"incididunt ex labore in mollit\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"sunt quis\",\n        \"SSN\": 1191979.1901120394,\n        \"SecretPassword\": \"labore eiusmod\",\n        \"LDAmount\": 48120796.21437192,\n        \"AccNumber\": \"Lorem ullamco nulla do sunt\"\n      },\n      \"ssNumber\": 61285784.88849771,\n      \"ssnShort\": 26111272.357349202,\n      \"alternatePhoneNumber\": -64742820.94873649,\n      \"customerId\": \"dolore\",\n      \"email\": \"magna dolor veniam Excepteur\",\n      \"identificationNumber\": \"magna Lorem\",\n      \"identificationType\": \"ut sed quis Ut do\",\n      \"location\": \"sit adipisicing Lorem cupidatat\",\n      \"name\": \"consectetur sunt ut eiusmod non\",\n      \"phone\": -66091273.85797797\n    }\n  ],\n  \"warningCodes\": [\n    {\n      \"code\": 56848393.83885524,\n      \"level\": \"ullamco eiusmod Ut sit culpa\",\n      \"description\": \"occaecat Duis do\"\n    },\n    {\n      \"code\": -34277040.238763414,\n      \"level\": \"commodo aliqua\",\n      \"description\": \"sunt incididunt proident\"\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for locateProfile for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    const value = ld.get(jsonResponse, `cardDetails`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field cardDetails:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.expiryDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.expiryDate`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.expiryDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.expiryDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.cvv` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.cvv`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.cvv`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.cvv:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.pin` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.pin`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.pin`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.pin:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.DOB` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.DOB`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.DOB`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.DOB:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.SSN` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`personalQuestions.SSN`)) {\n                    const value = ld.get(responseData, `personalQuestions.SSN`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field personalQuestions.SSN:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.SecretPassword` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.SecretPassword`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.SecretPassword`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.SecretPassword:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.LDAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`personalQuestions.LDAmount`)) {\n                    const value = ld.get(responseData, `personalQuestions.LDAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field personalQuestions.LDAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.AccNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.AccNumber`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.AccNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.AccNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ssNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ssNumber`)) {\n                    const value = ld.get(responseData, `ssNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ssNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ssnShort` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ssnShort`)) {\n                    const value = ld.get(responseData, `ssnShort`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ssnShort:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `alternatePhoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`alternatePhoneNumber`)) {\n                    const value = ld.get(responseData, `alternatePhoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(jsonResponse, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationNumber`)) {\n                    const value = ld.get(jsonResponse, `identificationNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationType`)) {\n                    const value = ld.get(jsonResponse, `identificationType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker`)) {\n                    const value = ld.get(jsonResponse, `personalBanker`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBanker:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.name`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.email`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `securityQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`securityQuestions`)) {\n                    const value = ld.get(jsonResponse, `securityQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field securityQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `segmentId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`segmentId`)) {\n                    const value = ld.get(responseData, `segmentId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field segmentId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `multiAccounts` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`multiAccounts`)) {\n                    const value = ld.get(jsonResponse, `multiAccounts`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field multiAccounts:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the multiAccounts field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`multiAccounts`)) {\n                    let multiAccountsArray = ld.get(jsonResponse, `multiAccounts`, []);\n                    if (Array.isArray(multiAccountsArray)) {\n                        for (let multiAccounts_it = 0; multiAccounts_it < multiAccountsArray.length; multiAccounts_it++) {\n                            let iterator = multiAccounts_it;\n                            if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].accountNumber' has 'accountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].accountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].accountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails' has 'cardDetails' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for multiAccounts[${multiAccounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.expiryDate' has 'expiryDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.expiryDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.expiryDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.cvv' has 'cvv' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.cvv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.cvv:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.pin' has 'pin' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.pin`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.pin:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions' has 'personalQuestions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for multiAccounts[${multiAccounts_it}].personalQuestions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.DOB' has 'DOB' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.DOB`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.DOB:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'SSN' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].personalQuestions.SSN`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].personalQuestions.SSN:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword' has 'SecretPassword' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'LDAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].personalQuestions.LDAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].personalQuestions.LDAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber' has 'AccNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'ssNumber' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].ssNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].ssNumber:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'ssnShort' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].ssnShort`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].ssnShort:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'alternatePhoneNumber' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].alternatePhoneNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].customerId' has 'customerId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].customerId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].customerId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].identificationNumber' has 'identificationNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].identificationNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].identificationNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].identificationType' has 'identificationType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].identificationType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].identificationType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].location' has 'location' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].location`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].location:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'phone' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].phone`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].phone:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for multiAccounts:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `warningCodes` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`warningCodes`)) {\n                    const value = ld.get(jsonResponse, `warningCodes`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field warningCodes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the warningCodes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`warningCodes`)) {\n                    let warningCodesArray = ld.get(jsonResponse, `warningCodes`, []);\n                    if (Array.isArray(warningCodesArray)) {\n                        for (let warningCodes_it = 0; warningCodes_it < warningCodesArray.length; warningCodes_it++) {\n                            let iterator = warningCodes_it;\n                            if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'warningCodesArray' has 'code' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `warningCodes[${warningCodes_it}].code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for warningCodes[${warningCodes_it}].code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'warningCodes[${warningCodes_it}].level' has 'level' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `warningCodes[${warningCodes_it}].level`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for warningCodes[${warningCodes_it}].level:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'warningCodes[${warningCodes_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `warningCodes[${warningCodes_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for warningCodes[${warningCodes_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for warningCodes:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the exiting user",
      "request": {
        "name": "to validate the exiting user",
        "description": {
          "content": "to validate the in of existing user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validateUser"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validateUser for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PINs matched\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the pins entered by the new user",
      "request": {
        "name": "to validate the pins entered by the new user",
        "description": {
          "content": "to validate the pins entered by the new user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePIN"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePIN for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PINs matched\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate if pin entered by new user follows pin rules",
      "request": {
        "name": "to validate if pin entered by new user follows pin rules",
        "description": {
          "content": "to validate if pin entered by new user follows pin rules",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePINRules"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PIN rules satisfied",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePINRules for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PIN rules satisfied\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the account closure status",
      "request": {
        "name": "to fetch the account closure status",
        "description": {
          "content": "to fetch the account closure status",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "getRequestStatus"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for getRequestStatus for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to place the request",
      "request": {
        "name": "to place the request",
        "description": {
          "content": "to place the request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "request"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for request for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to enable or disable e or paper statements at profile level",
      "request": {
        "name": "to enable or disable e or paper statements at profile level",
        "description": {
          "content": "to enable or disable e or paper statements at profile level",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "enableEStatement"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for enableEStatement for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to update the cheque book details of customer accounts",
      "request": {
        "name": "to update the cheque book details of customer accounts",
        "description": {
          "content": "Update customer cheque book details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "RequestChequeBook"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for RequestChequeBook for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendOTP",
      "request": {
        "name": "sendOTP",
        "description": {
          "content": "sends OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "verification code has been sent to your mobile number",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"verification code has been sent to your mobile number\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "verifyOTP",
      "request": {
        "name": "verifyOTP",
        "description": {
          "content": " to verify OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "verifyOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "OTP verifid successfully",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for verifyOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"OTP verifid successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the deeplink",
      "request": {
        "name": "to fetch the deeplink",
        "description": {
          "content": "to fetch the deeplink",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deeplink"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "tenantId",
            "value": "{{tenantId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "environment",
            "value": "{{environment}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "channel",
            "value": "{{channel}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"usecase\": \"addbeneficiary\",\n    \"link\": \"www.google.com\",\n    \"linkType\": \"deeplink\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"e\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756359807365 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deeplink for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `usecase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`usecase`)) {\n                    const value = ld.get(jsonResponse, `usecase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field usecase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `link` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`link`)) {\n                    const value = ld.get(jsonResponse, `link`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field link:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `linkType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`linkType`)) {\n                    const value = ld.get(jsonResponse, `linkType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field linkType:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://localhost:8080/smt",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{bearerToken}}"
      }
    ]
  },
  "info": {
    "_postman_id": "d0a05a9e-1a07-4d8d-a861-9870c621fa89",
    "name": "BankAssist SMT Core Banking API Specification",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "kore.ai banking bot apis.",
      "type": "text/plain"
    }
  }
}