{
  "item": [
    {
      "name": "Submit Request",
      "request": {
        "name": "Submit Request",
        "description": {
          "content": "Meta API request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "submitRequest"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "<object>",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for submitRequest for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AuthToken",
      "request": {
        "name": "AuthToken",
        "description": {
          "content": "Get authentication token",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "authToken"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null
      },
      "response": [
        {
          "name": "successful login",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"token\": \"token\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for authToken for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful login\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `token` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`token`)) {\n                    const value = ld.get(jsonResponse, `token`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field token:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Deposit",
      "request": {
        "name": "Deposit",
        "description": {
          "content": "Deposit amount to customer's account",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deposit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*string}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Deposit success",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deposit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Deposit success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetAccountInfo",
      "request": {
        "name": "GetAccountInfo",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"customerId\": 23763110.25935757,\n  \"accounts\": [\n    {\n      \"customerId\": -82674555.3357329,\n      \"accountName\": \"id eu fugiat consectetur\",\n      \"accountNickname\": \"consectetur minim amet\",\n      \"accountNumber\": \"Duis non aliquip\",\n      \"accountType\": \"irure consectetur aute\",\n      \"activatedDate\": \"in anim\",\n      \"availableBalance\": 55491128.920758694,\n      \"availableCash\": -58583180.46084689,\n      \"availableCashLimit\": -36630400.8808708,\n      \"availableCredit\": 99930728.97203887,\n      \"bankName\": \"dolor pariatur nulla esse ven\",\n      \"branchName\": \"exercitation in\",\n      \"cardName\": \"sunt ut\",\n      \"cardNumber\": \"laborum sed amet nulla\",\n      \"cardStatus\": \"et Lorem anim esse\",\n      \"cardType\": \"sint culpa\",\n      \"creditLimit\": 38024712.125225514,\n      \"currency\": \"magna consequat Lorem\",\n      \"currentBalance\": 66510876.020297915,\n      \"deactivatedDate\": \"cillum ut aliqua officia qui\",\n      \"dueAmount\": -10527044.862848848,\n      \"dueDate\": \"nostrud\",\n      \"earlyWithdrawalPenalty\": -68011297.81919761,\n      \"email\": \"non sint tempor dolore\",\n      \"expDate\": \"magna ullamco\",\n      \"fdType\": \"reprehenderit dolore anim mini\",\n      \"image\": \"non sunt adipisicing do\",\n      \"interestRate\": 66686145.09540093,\n      \"internalTransferFromEnabled\": true,\n      \"internalTransferToEnabled\": true,\n      \"isPrimaryMobile\": false,\n      \"isAlternateMobileNumber\": false,\n      \"isStatement\": true,\n      \"lastDrawDate\": \"reprehenderit\",\n      \"loanMaturityDate\": \"aute incididunt\",\n      \"loanOriginationDate\": \"fugiat\",\n      \"location\": \"cillum\",\n      \"lastUpdated\": \"mollit \",\n      \"maxTransactionLimit\": \"Excepteur\",\n      \"maturityDate\": \"dolor id\",\n      \"minimumPaymentDue\": \"ipsum ea\",\n      \"minimumBalance\": \"qui velit officia\",\n      \"monthlyPayment\": -11679128.53327766,\n      \"openingBalance\": 84276468.34943515,\n      \"originalLoanAmount\": -49912713.63042431,\n      \"P2PLimit\": 89258645.11834273,\n      \"p2pEnabled\": -26554715.193702057,\n      \"paybillEnabled\": false,\n      \"payoffAmount\": 42462565.894011915,\n      \"personalBankerName\": \"voluptate non\",\n      \"personalBankerContact\": {\n        \"email\": \"elit sit sint adipisicing\",\n        \"mobileNumber\": \"dolore voluptate et\"\n      },\n      \"phone\": -92506810.93135396,\n      \"postedBalance\": 25897433.359595284,\n      \"principalBalance\": \"dolore ad culpa esse\",\n      \"productCode\": \"ut sunt eu\",\n      \"productName\": \"sunt irure laborum do\",\n      \"propertyAddress\": \"laboris enim commodo exercitation\",\n      \"rewardPoints\": \"amet Ut reprehenderit culpa\",\n      \"routingNumber\": \"culpa minim mo\",\n      \"statementDate\": \"nisi do\",\n      \"status\": \"do aliqua proident anim reprehenderit\",\n      \"swiftCode\": \"do nostrud in culpa\",\n      \"totalBalance\": 67004035.56891915,\n      \"unbilledAmount\": 85696010.01965833,\n      \"valueAtMaturity\": -59884608.348104164,\n      \"holdAmount\": 83488547.66188091,\n      \"unclearFundsAmount\": 15756990.144964963,\n      \"averageMonthlyBalance\": 84068246.33040634,\n      \"netWithdrawableBalance\": 23538132.454641804,\n      \"totalTenure\": \"ullamco mollit\",\n      \"remainingTenure\": \"ut eni\",\n      \"debitAccountNumber\": \"Ut nulla\",\n      \"lateFee\": 46762172.36599371,\n      \"bounceCharge\": -25588069.197917208,\n      \"totalCharges\": -76851735.22329314,\n      \"overDueAmount\": 25314168.373246953,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"voluptate aliquip sunt ea\",\n          \"cardNumber\": \"sit voluptate\",\n          \"cardStatus\": \"nulla dolore cillum\",\n          \"cardImage\": \"proident est\",\n          \"cardType\": \"nostrud et esse ex\",\n          \"expDate\": \"aliquip sint mollit sit tempor\",\n          \"displayCardStatus\": \"Ut\",\n          \"primaryCard\": \"incididunt nisi Lorem voluptate\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"esse cillum fugiat\",\n          \"nameOnCard\": \"tempor\",\n          \"cardNetwork\": \"aute incididunt et\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"aliquip nulla aute\",\n            \"paymentType\": \"pariatur tempor aute\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"eu do\"\n          },\n          \"dueAmount\": 43457135.11294934,\n          \"dueDate\": \"magna velit ad\",\n          \"minimumPaymentDue\": -79702490.71952233,\n          \"partialPaymentPaid\": -75267828.14295503\n        },\n        {\n          \"cardName\": \"laboris enim laborum voluptate\",\n          \"cardNumber\": \"tempor\",\n          \"cardStatus\": \"laboris\",\n          \"cardImage\": \"Excepteur quis\",\n          \"cardType\": \"nulla occaecat dolor min\",\n          \"expDate\": \"sit cupidatat anim\",\n          \"displayCardStatus\": \"aliquip sint\",\n          \"primaryCard\": \"tempor eiusmod ea\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"sunt veniam incididunt\",\n          \"nameOnCard\": \"culpa incididunt ut\",\n          \"cardNetwork\": \"culpa voluptate\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"cupidatat do\",\n            \"paymentType\": \"ea velit Duis sunt\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"veniam eiusmod laboris\"\n          },\n          \"dueAmount\": 45014096.0735077,\n          \"dueDate\": \"ipsum lab\",\n          \"minimumPaymentDue\": 65337957.48886731,\n          \"partialPaymentPaid\": 43203967.00697869\n        }\n      ],\n      \"IsCrossAccount\": true\n    },\n    {\n      \"customerId\": -78673265.44018635,\n      \"accountName\": \"officia adipisicing qui\",\n      \"accountNickname\": \"aute officia pariatur\",\n      \"accountNumber\": \"sit culpa Excepteur Duis qui\",\n      \"accountType\": \"Excepteur dolore\",\n      \"activatedDate\": \"do des\",\n      \"availableBalance\": 24914028.34994258,\n      \"availableCash\": -78593051.07004383,\n      \"availableCashLimit\": 36397478.8907851,\n      \"availableCredit\": -95649611.49059199,\n      \"bankName\": \"eu\",\n      \"branchName\": \"Excepteur tempor adipisicing ullamco\",\n      \"cardName\": \"sit Excepteur\",\n      \"cardNumber\": \"id officia ipsum\",\n      \"cardStatus\": \"non officia\",\n      \"cardType\": \"consequat culpa dolor Duis\",\n      \"creditLimit\": -29369383.288791835,\n      \"currency\": \"veniam aliquip\",\n      \"currentBalance\": 31305397.67801985,\n      \"deactivatedDate\": \"in eu culpa\",\n      \"dueAmount\": -1952117.1318541765,\n      \"dueDate\": \"consectetur\",\n      \"earlyWithdrawalPenalty\": -82778354.8388341,\n      \"email\": \"d\",\n      \"expDate\": \"aute consectetur\",\n      \"fdType\": \"esse reprehenderit\",\n      \"image\": \"nulla proident\",\n      \"interestRate\": -49385378.52373561,\n      \"internalTransferFromEnabled\": false,\n      \"internalTransferToEnabled\": false,\n      \"isPrimaryMobile\": false,\n      \"isAlternateMobileNumber\": false,\n      \"isStatement\": true,\n      \"lastDrawDate\": \"ea labore sunt occaecat dolore\",\n      \"loanMaturityDate\": \"nisi v\",\n      \"loanOriginationDate\": \"id\",\n      \"location\": \"enim\",\n      \"lastUpdated\": \"dolor Duis ut\",\n      \"maxTransactionLimit\": \"aliquip\",\n      \"maturityDate\": \"ullamco enim\",\n      \"minimumPaymentDue\": \"Duis enim\",\n      \"minimumBalance\": \"quis pariatur\",\n      \"monthlyPayment\": 32245754.956610903,\n      \"openingBalance\": -86337572.81026556,\n      \"originalLoanAmount\": -77693394.8334209,\n      \"P2PLimit\": 26935937.044749722,\n      \"p2pEnabled\": 8541759.939827546,\n      \"paybillEnabled\": true,\n      \"payoffAmount\": 44894273.41694197,\n      \"personalBankerName\": \"cu\",\n      \"personalBankerContact\": {\n        \"email\": \"eu reprehenderit cupidatat nostrud\",\n        \"mobileNumber\": \"cillum ad nostrud occaecat in\"\n      },\n      \"phone\": -30672615.942391828,\n      \"postedBalance\": 31575757.798661813,\n      \"principalBalance\": \"ut consectetur\",\n      \"productCode\": \"molli\",\n      \"productName\": \"consequat laboris eu\",\n      \"propertyAddress\": \"aute pariatur\",\n      \"rewardPoints\": \"ipsum nostrud\",\n      \"routingNumber\": \"esse officia\",\n      \"statementDate\": \"labore\",\n      \"status\": \"in velit eiusmod\",\n      \"swiftCode\": \"ipsum sunt reprehenderit\",\n      \"totalBalance\": -80903024.54649954,\n      \"unbilledAmount\": 79815234.67470929,\n      \"valueAtMaturity\": 83551961.59913799,\n      \"holdAmount\": 77339077.28572425,\n      \"unclearFundsAmount\": -39629904.465052724,\n      \"averageMonthlyBalance\": -27532324.53382632,\n      \"netWithdrawableBalance\": 2232388.39736481,\n      \"totalTenure\": \"elit\",\n      \"remainingTenure\": \"ea amet\",\n      \"debitAccountNumber\": \"labore exercitation do ut\",\n      \"lateFee\": -60210034.976976834,\n      \"bounceCharge\": 62978894.05688393,\n      \"totalCharges\": -3952921.886439815,\n      \"overDueAmount\": -31669692.790292457,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"Ut anim aute esse aliqua\",\n          \"cardNumber\": \"Lore\",\n          \"cardStatus\": \"proident in culpa laborum non\",\n          \"cardImage\": \"sint dolore magna fugiat\",\n          \"cardType\": \"ullamco aliquip do\",\n          \"expDate\": \"qui commodo aliquip\",\n          \"displayCardStatus\": \"ullamco in ad Excepteur\",\n          \"primaryCard\": \"laborum exercitation fugiat dolor\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"sed Excepteur ut\",\n          \"nameOnCard\": \"in aute commodo labore\",\n          \"cardNetwork\": \"nisi in\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"temp\",\n            \"paymentType\": \"veniam ut mollit\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"adipisicing culpa consequat\"\n          },\n          \"dueAmount\": 20101645.396430805,\n          \"dueDate\": \"Excepteur cupidatat ut deserunt\",\n          \"minimumPaymentDue\": 37385433.183690876,\n          \"partialPaymentPaid\": 72659431.86328071\n        },\n        {\n          \"cardName\": \"est do\",\n          \"cardNumber\": \"ipsum sint\",\n          \"cardStatus\": \"sed ullamco Lorem laboris dolor\",\n          \"cardImage\": \"adipisicing\",\n          \"cardType\": \"nisi fugiat\",\n          \"expDate\": \"proident commodo occaecat\",\n          \"displayCardStatus\": \"con\",\n          \"primaryCard\": \"sint minim quis Duis\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"ullamco ad\",\n          \"nameOnCard\": \"quis tempor non amet\",\n          \"cardNetwork\": \"Lorem proident nisi in ut\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"est voluptate tempor\",\n            \"paymentType\": \"et qui eiusmod laboris\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"tempor\"\n          },\n          \"dueAmount\": -23827929.047972456,\n          \"dueDate\": \"labore\",\n          \"minimumPaymentDue\": -24777128.507624418,\n          \"partialPaymentPaid\": -42122902.48797306\n        }\n      ],\n      \"IsCrossAccount\": true\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accounts` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts`)) {\n                    const value = ld.get(jsonResponse, `accounts`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field accounts:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the accounts field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts`)) {\n                    let accountsArray = ld.get(jsonResponse, `accounts`, []);\n                    if (Array.isArray(accountsArray)) {\n                        for (let accounts_it = 0; accounts_it < accountsArray.length; accounts_it++) {\n                            let iterator = accounts_it;\n                            if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accountsArray' has 'customerId' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].customerId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].customerId:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountName' has 'accountName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountNickname' has 'accountNickname' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountNickname`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountNickname:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountNumber' has 'accountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountType' has 'accountType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].activatedDate' has 'activatedDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].activatedDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].activatedDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCash' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCash`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCash:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCashLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCashLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCredit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCredit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCredit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].bankName' has 'bankName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].bankName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].bankName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].branchName' has 'branchName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].branchName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].branchName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'creditLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].creditLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].creditLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].currency' has 'currency' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].currency`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].currency:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'currentBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].currentBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].currentBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].deactivatedDate' has 'deactivatedDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].deactivatedDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].deactivatedDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'earlyWithdrawalPenalty' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].earlyWithdrawalPenalty`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].earlyWithdrawalPenalty:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].fdType' has 'fdType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].fdType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].fdType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].image' has 'image' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].image`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].image:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'interestRate' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].interestRate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].interestRate:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].internalTransferFromEnabled' has 'internalTransferFromEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].internalTransferFromEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].internalTransferFromEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].internalTransferToEnabled' has 'internalTransferToEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].internalTransferToEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].internalTransferToEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isPrimaryMobile' has 'isPrimaryMobile' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isPrimaryMobile`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isPrimaryMobile:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isAlternateMobileNumber' has 'isAlternateMobileNumber' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isAlternateMobileNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isStatement' has 'isStatement' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isStatement`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isStatement:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].lastDrawDate' has 'lastDrawDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].lastDrawDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].lastDrawDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].loanMaturityDate' has 'loanMaturityDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].loanMaturityDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].loanMaturityDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].loanOriginationDate' has 'loanOriginationDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].loanOriginationDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].loanOriginationDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].location' has 'location' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].location`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].location:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].lastUpdated' has 'lastUpdated' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].lastUpdated`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].lastUpdated:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].maxTransactionLimit' has 'maxTransactionLimit' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].maxTransactionLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].maxTransactionLimit:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].maturityDate' has 'maturityDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].maturityDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].maturityDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].minimumPaymentDue' has 'minimumPaymentDue' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].minimumBalance' has 'minimumBalance' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].minimumBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].minimumBalance:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'monthlyPayment' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].monthlyPayment`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].monthlyPayment:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'openingBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].openingBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].openingBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'originalLoanAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].originalLoanAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].originalLoanAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'P2PLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].P2PLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].P2PLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'p2pEnabled' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].p2pEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].p2pEnabled:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].paybillEnabled' has 'paybillEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].paybillEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].paybillEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'payoffAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].payoffAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].payoffAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerName' has 'personalBankerName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact' has 'personalBankerContact' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].personalBankerContact:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact.email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact.email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerContact.email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact.mobileNumber' has 'mobileNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact.mobileNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerContact.mobileNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'phone' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].phone`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].phone:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'postedBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].postedBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].postedBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].principalBalance' has 'principalBalance' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].principalBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].principalBalance:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].productCode' has 'productCode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].productCode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].productCode:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].productName' has 'productName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].productName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].productName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].propertyAddress' has 'propertyAddress' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].propertyAddress`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].propertyAddress:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].rewardPoints' has 'rewardPoints' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].rewardPoints`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].rewardPoints:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].routingNumber' has 'routingNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].routingNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].routingNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].statementDate' has 'statementDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].statementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].statementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].status' has 'status' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].status`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].status:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].swiftCode' has 'swiftCode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].swiftCode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].swiftCode:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'totalBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].totalBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].totalBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'unbilledAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].unbilledAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].unbilledAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'valueAtMaturity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].valueAtMaturity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].valueAtMaturity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'holdAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].holdAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].holdAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'unclearFundsAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].unclearFundsAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].unclearFundsAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'averageMonthlyBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].averageMonthlyBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].averageMonthlyBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'netWithdrawableBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].netWithdrawableBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].netWithdrawableBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].totalTenure' has 'totalTenure' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].totalTenure`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].totalTenure:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].remainingTenure' has 'remainingTenure' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].remainingTenure`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].remainingTenure:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].debitAccountNumber' has 'debitAccountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].debitAccountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].debitAccountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'lateFee' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].lateFee`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].lateFee:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'bounceCharge' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].bounceCharge`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].bounceCharge:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'totalCharges' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].totalCharges`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].totalCharges:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'overDueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].overDueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].overDueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'cardDetails' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails`)) {\n                    let cardDetailsArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails`, []);\n                    if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                            let iterator = cardDetails_it;\n                            if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage' has 'cardImage' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus' has 'displayCardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard' has 'primaryCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo' has 'cardChannelInfo' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM' has 'ATM' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline' has 'offline' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international' has 'international' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online' has 'online' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless' has 'contactless' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions' has 'cardRestrictions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'countries' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`)) {\n                    let countriesArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`, []);\n                    if (Array.isArray(countriesArray)) {\n                        for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                            let iterator = countries_it;\n                            if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode' has 'countrycode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'MCC' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`)) {\n                    let MCCArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`, []);\n                    if (Array.isArray(MCCArray)) {\n                        for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                            let iterator = MCC_it;\n                            if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason' has 'blockReason' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard' has 'nameOnCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork' has 'cardNetwork' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay' has 'autopay' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled' has 'enabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId' has 'sourceAccountId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType' has 'paymentType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate' has 'onStatementDate' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth' has 'dayOfMonth' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'minimumPaymentDue' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'partialPaymentPaid' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].partialPaymentPaid`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].partialPaymentPaid:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].IsCrossAccount' has 'IsCrossAccount' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].IsCrossAccount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].IsCrossAccount:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the details of the mentioned customer account",
      "request": {
        "name": "to get the details of the mentioned customer account",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountDetails"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*string}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*string}}\"\n        }\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": -27835335.622688234,\n    \"accountName\": \"est labor\",\n    \"accountNickname\": \"pariatur elit id ad\",\n    \"accountNumber\": \"ad id est\",\n    \"accountType\": \"ad officia nostrud\",\n    \"activatedDate\": \"la\",\n    \"availableBalance\": 71990768.32438812,\n    \"availableCash\": -593477.0826755613,\n    \"availableCashLimit\": 61396704.02713686,\n    \"availableCredit\": -46890483.07768111,\n    \"bankName\": \"Lorem u\",\n    \"branchName\": \"quis aute fugiat\",\n    \"cardName\": \"et velit\",\n    \"cardNumber\": \"reprehenderit\",\n    \"cardStatus\": \"ut\",\n    \"cardType\": \"Excepteur deserunt irure\",\n    \"creditLimit\": -26790130.371700108,\n    \"currency\": \"la\",\n    \"currentBalance\": 19289111.22916639,\n    \"deactivatedDate\": \"enim ipsum ex in\",\n    \"dueAmount\": -10316049.361079529,\n    \"dueDate\": \"id officia exercitation non\",\n    \"earlyWithdrawalPenalty\": 91041574.73416445,\n    \"email\": \"ut eu\",\n    \"expDate\": \"enim qui quis\",\n    \"fdType\": \"officia amet ni\",\n    \"image\": \"qui aliquip tempor\",\n    \"interestRate\": -82424191.90122044,\n    \"internalTransferFromEnabled\": false,\n    \"internalTransferToEnabled\": false,\n    \"isPrimaryMobile\": false,\n    \"isAlternateMobileNumber\": true,\n    \"isStatement\": false,\n    \"lastDrawDate\": \"in sed\",\n    \"loanMaturityDate\": \"nostrud velit aliqua esse laboris\",\n    \"loanOriginationDate\": \"aliqua Excepteur fugiat\",\n    \"location\": \"reprehenderit consequat ex\",\n    \"lastUpdated\": \"velit tempor sint anim ma\",\n    \"maxTransactionLimit\": \"amet est Lorem Ut\",\n    \"maturityDate\": \"eiusmod reprehenderit dolore\",\n    \"minimumPaymentDue\": \"aliqui\",\n    \"minimumBalance\": \"exercitation sint voluptate culpa\",\n    \"monthlyPayment\": -54929540.500451334,\n    \"openingBalance\": -40889306.58205947,\n    \"originalLoanAmount\": 62234172.67003545,\n    \"P2PLimit\": 43203571.87100327,\n    \"p2pEnabled\": -65633710.54337645,\n    \"paybillEnabled\": false,\n    \"payoffAmount\": -42409088.003999874,\n    \"personalBankerName\": \"occaecat adipisicing fugi\",\n    \"personalBankerContact\": {\n      \"email\": \"laborum et voluptate\",\n      \"mobileNumber\": \"consectetur in velit fugiat\"\n    },\n    \"phone\": -6663730.051017806,\n    \"postedBalance\": -26968425.958492488,\n    \"principalBalance\": \"labore fugiat sunt\",\n    \"productCode\": \"dolore nisi occaecat labore\",\n    \"productName\": \"incid\",\n    \"propertyAddress\": \"dolor incididunt\",\n    \"rewardPoints\": \"amet velit occaecat\",\n    \"routingNumber\": \"aute ut dolor sit\",\n    \"statementDate\": \"proident\",\n    \"status\": \"occaecat esse Ut nulla\",\n    \"swiftCode\": \"aliquip nisi in\",\n    \"totalBalance\": 5047355.672142699,\n    \"unbilledAmount\": -53598704.616642,\n    \"valueAtMaturity\": -32206653.437553227,\n    \"holdAmount\": 54049918.794734925,\n    \"unclearFundsAmount\": -54415677.25994294,\n    \"averageMonthlyBalance\": 28594194.57292618,\n    \"netWithdrawableBalance\": 75783965.34073809,\n    \"totalTenure\": \"in ea\",\n    \"remainingTenure\": \"in\",\n    \"debitAccountNumber\": \"in dolore sint\",\n    \"lateFee\": 79964118.89673066,\n    \"bounceCharge\": -30932426.887798935,\n    \"totalCharges\": 33912269.50185309,\n    \"overDueAmount\": 90740597.47880635,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"irure proident veniam\",\n        \"cardNumber\": \"laborum\",\n        \"cardStatus\": \"laborum consequat nostrud non\",\n        \"cardImage\": \"ullamco do tempor eiusmod\",\n        \"cardType\": \"amet dolore quis\",\n        \"expDate\": \"dolor\",\n        \"displayCardStatus\": \"sed et\",\n        \"primaryCard\": \"dolore sit pariatur minim veniam\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"Lorem est irure aute Ut\",\n        \"nameOnCard\": \"adipisicing reprehende\",\n        \"cardNetwork\": \"ea mollit \",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"Duis id\",\n          \"paymentType\": \"sunt sit eiusmod labore\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"do\"\n        },\n        \"dueAmount\": 37647508.50166428,\n        \"dueDate\": \"mollit ad pariatur in cillum\",\n        \"minimumPaymentDue\": 47759347.48353407,\n        \"partialPaymentPaid\": 6273433.899705917\n      },\n      {\n        \"cardName\": \"commodo adipisicing enim nisi in\",\n        \"cardNumber\": \"aliqua dolore\",\n        \"cardStatus\": \"est dolore id veniam\",\n        \"cardImage\": \"deserunt consectetur ea\",\n        \"cardType\": \"voluptate\",\n        \"expDate\": \"est elit labore cil\",\n        \"displayCardStatus\": \"aliqua do\",\n        \"primaryCard\": \"aliquip reprehenderit culpa\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"Lorem dolore labore ipsum\",\n        \"nameOnCard\": \"Excepteur fugiat non\",\n        \"cardNetwork\": \"sit Excepteur\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"veniam o\",\n          \"paymentType\": \"irure laborum ex i\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"i\"\n        },\n        \"dueAmount\": 36304773.69899303,\n        \"dueDate\": \"sed Lorem\",\n        \"minimumPaymentDue\": 82288434.0301365,\n        \"partialPaymentPaid\": -69248712.62800041\n      }\n    ],\n    \"IsCrossAccount\": false\n  },\n  {\n    \"customerId\": 44587711.784669995,\n    \"accountName\": \"pariatur ut\",\n    \"accountNickname\": \"ut magna\",\n    \"accountNumber\": \"Ut aliqua\",\n    \"accountType\": \"fugiat labore ad\",\n    \"activatedDate\": \"irure enim\",\n    \"availableBalance\": 71010589.54355216,\n    \"availableCash\": -25194091.27810736,\n    \"availableCashLimit\": 81005055.87391788,\n    \"availableCredit\": 33267653.85164374,\n    \"bankName\": \"eiusmod occaecat\",\n    \"branchName\": \"laborum\",\n    \"cardName\": \"cupidatat consectetur\",\n    \"cardNumber\": \"dolore voluptate nisi magna cupidatat\",\n    \"cardStatus\": \"voluptate\",\n    \"cardType\": \"pariatur aliquip ipsum\",\n    \"creditLimit\": 12994922.025982141,\n    \"currency\": \"dolore\",\n    \"currentBalance\": -77934610.1705972,\n    \"deactivatedDate\": \"amet magna ipsum\",\n    \"dueAmount\": 41335093.58043176,\n    \"dueDate\": \"voluptate exercitation commodo id\",\n    \"earlyWithdrawalPenalty\": 69286249.19396412,\n    \"email\": \"Excepteur proident quis\",\n    \"expDate\": \"velit ipsum\",\n    \"fdType\": \"adipisicing pariatur dolore Lorem\",\n    \"image\": \"eu et ut irure veniam\",\n    \"interestRate\": 15252091.980071023,\n    \"internalTransferFromEnabled\": false,\n    \"internalTransferToEnabled\": false,\n    \"isPrimaryMobile\": true,\n    \"isAlternateMobileNumber\": false,\n    \"isStatement\": false,\n    \"lastDrawDate\": \"deserunt dolor\",\n    \"loanMaturityDate\": \"sed\",\n    \"loanOriginationDate\": \"qui si\",\n    \"location\": \"mollit sed eu esse consectetur\",\n    \"lastUpdated\": \"Duis ut ullamco\",\n    \"maxTransactionLimit\": \"eu velit Lorem incididunt aliquip\",\n    \"maturityDate\": \"veniam in laboris\",\n    \"minimumPaymentDue\": \"ex deserunt\",\n    \"minimumBalance\": \"tempor\",\n    \"monthlyPayment\": 17023284.75844866,\n    \"openingBalance\": 44509334.22949487,\n    \"originalLoanAmount\": -42389223.611879334,\n    \"P2PLimit\": 43355085.77088037,\n    \"p2pEnabled\": 74619786.27265361,\n    \"paybillEnabled\": true,\n    \"payoffAmount\": 44625779.90490794,\n    \"personalBankerName\": \"aliquip\",\n    \"personalBankerContact\": {\n      \"email\": \"nulla tempor\",\n      \"mobileNumber\": \"mollit\"\n    },\n    \"phone\": -21733401.260975122,\n    \"postedBalance\": 10733216.023413032,\n    \"principalBalance\": \"Ut pariatur\",\n    \"productCode\": \"Excepteur Ut id\",\n    \"productName\": \"ad dolor in ea labore\",\n    \"propertyAddress\": \"ut minim non\",\n    \"rewardPoints\": \"incididunt reprehenderit Ut magna\",\n    \"routingNumber\": \"ut\",\n    \"statementDate\": \"eiusmod aliqua ut enim laborum\",\n    \"status\": \"velit in sed do laborum\",\n    \"swiftCode\": \"Lorem et esse\",\n    \"totalBalance\": 77481306.77249944,\n    \"unbilledAmount\": -26547699.123833507,\n    \"valueAtMaturity\": 7631850.334707841,\n    \"holdAmount\": 31111107.190261528,\n    \"unclearFundsAmount\": -86474419.33569482,\n    \"averageMonthlyBalance\": -67657849.77844852,\n    \"netWithdrawableBalance\": -23762786.372724995,\n    \"totalTenure\": \"Ut amet\",\n    \"remainingTenure\": \"dolore aliqua\",\n    \"debitAccountNumber\": \"elit adipisicing laboris deserunt \",\n    \"lateFee\": 84353707.75203276,\n    \"bounceCharge\": -54599175.392369,\n    \"totalCharges\": -11636657.865868345,\n    \"overDueAmount\": -21495512.070373386,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"dolor officia aute nisi\",\n        \"cardNumber\": \"quis\",\n        \"cardStatus\": \"in non elit consequat exercitation\",\n        \"cardImage\": \"non dolore culpa\",\n        \"cardType\": \"cillum aliquip\",\n        \"expDate\": \"aliquip\",\n        \"displayCardStatus\": \"Lorem irur\",\n        \"primaryCard\": \"aliqua ut culpa eu\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"eiusmod Excepteur Ut amet\",\n        \"nameOnCard\": \"tempor minim quis fugiat\",\n        \"cardNetwork\": \"cillum in dolore incididunt\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"exercitation deserunt\",\n          \"paymentType\": \"Ut dolor\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"velit ipsum id\"\n        },\n        \"dueAmount\": -78882649.56050625,\n        \"dueDate\": \"esse aliqua elit deserunt nostrud\",\n        \"minimumPaymentDue\": 37969688.69187537,\n        \"partialPaymentPaid\": 47719465.1082972\n      },\n      {\n        \"cardName\": \"commodo consectetur mollit ut eu\",\n        \"cardNumber\": \"reprehenderit aute\",\n        \"cardStatus\": \"officia do culpa cillum\",\n        \"cardImage\": \"occaecat est proident\",\n        \"cardType\": \"cupidatat deserunt consectetur voluptate proident\",\n        \"expDate\": \"anim nisi\",\n        \"displayCardStatus\": \"in\",\n        \"primaryCard\": \"minim aliquip aute id\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"in ullamco laboris\",\n        \"nameOnCard\": \"reprehenderit labore aliqua sint\",\n        \"cardNetwork\": \"fugiat mollit\",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"consequat\",\n          \"paymentType\": \"et incididunt\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"dolor et amet\"\n        },\n        \"dueAmount\": 60050460.98026082,\n        \"dueDate\": \"sunt fugiat ullamco mollit exercitation\",\n        \"minimumPaymentDue\": 69590909.82621494,\n        \"partialPaymentPaid\": -78914393.77802034\n      }\n    ],\n    \"IsCrossAccount\": true\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountDetails for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountName`)) {\n                    const value = ld.get(jsonResponse, `accountName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNickname` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNickname`)) {\n                    const value = ld.get(jsonResponse, `accountNickname`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNickname:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountType`)) {\n                    const value = ld.get(jsonResponse, `accountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `activatedDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`activatedDate`)) {\n                    const value = ld.get(jsonResponse, `activatedDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field activatedDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableBalance`)) {\n                    const value = ld.get(responseData, `availableBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCash` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCash`)) {\n                    const value = ld.get(responseData, `availableCash`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCash:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCashLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCashLimit`)) {\n                    const value = ld.get(responseData, `availableCashLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCredit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCredit`)) {\n                    const value = ld.get(responseData, `availableCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `bankName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`bankName`)) {\n                    const value = ld.get(jsonResponse, `bankName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field bankName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `branchName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`branchName`)) {\n                    const value = ld.get(jsonResponse, `branchName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field branchName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardName`)) {\n                    const value = ld.get(jsonResponse, `cardName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardStatus` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardStatus`)) {\n                    const value = ld.get(jsonResponse, `cardStatus`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardStatus:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardType`)) {\n                    const value = ld.get(jsonResponse, `cardType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `creditLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`creditLimit`)) {\n                    const value = ld.get(responseData, `creditLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field creditLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currentBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`currentBalance`)) {\n                    const value = ld.get(responseData, `currentBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field currentBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `deactivatedDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`deactivatedDate`)) {\n                    const value = ld.get(jsonResponse, `deactivatedDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field deactivatedDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `dueAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`dueAmount`)) {\n                    const value = ld.get(responseData, `dueAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field dueAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `dueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`dueDate`)) {\n                    const value = ld.get(jsonResponse, `dueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field dueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `earlyWithdrawalPenalty` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`earlyWithdrawalPenalty`)) {\n                    const value = ld.get(responseData, `earlyWithdrawalPenalty`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field earlyWithdrawalPenalty:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `expDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`expDate`)) {\n                    const value = ld.get(jsonResponse, `expDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field expDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `fdType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`fdType`)) {\n                    const value = ld.get(jsonResponse, `fdType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field fdType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `interestRate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`interestRate`)) {\n                    const value = ld.get(responseData, `interestRate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field interestRate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `internalTransferFromEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`internalTransferFromEnabled`)) {\n                    const value = ld.get(jsonResponse, `internalTransferFromEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field internalTransferFromEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `internalTransferToEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`internalTransferToEnabled`)) {\n                    const value = ld.get(jsonResponse, `internalTransferToEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field internalTransferToEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobile` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobile`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobile`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobile:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isStatement` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isStatement`)) {\n                    const value = ld.get(jsonResponse, `isStatement`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isStatement:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastDrawDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastDrawDate`)) {\n                    const value = ld.get(jsonResponse, `lastDrawDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastDrawDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `loanMaturityDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`loanMaturityDate`)) {\n                    const value = ld.get(jsonResponse, `loanMaturityDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field loanMaturityDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `loanOriginationDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`loanOriginationDate`)) {\n                    const value = ld.get(jsonResponse, `loanOriginationDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field loanOriginationDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastUpdated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastUpdated`)) {\n                    const value = ld.get(jsonResponse, `lastUpdated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastUpdated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `maxTransactionLimit` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`maxTransactionLimit`)) {\n                    const value = ld.get(jsonResponse, `maxTransactionLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field maxTransactionLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `maturityDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`maturityDate`)) {\n                    const value = ld.get(jsonResponse, `maturityDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field maturityDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `minimumPaymentDue` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`minimumPaymentDue`)) {\n                    const value = ld.get(jsonResponse, `minimumPaymentDue`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `minimumBalance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`minimumBalance`)) {\n                    const value = ld.get(jsonResponse, `minimumBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field minimumBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `monthlyPayment` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`monthlyPayment`)) {\n                    const value = ld.get(responseData, `monthlyPayment`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field monthlyPayment:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `openingBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`openingBalance`)) {\n                    const value = ld.get(responseData, `openingBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field openingBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `originalLoanAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`originalLoanAmount`)) {\n                    const value = ld.get(responseData, `originalLoanAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field originalLoanAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `P2PLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`P2PLimit`)) {\n                    const value = ld.get(responseData, `P2PLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field P2PLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `p2pEnabled` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`p2pEnabled`)) {\n                    const value = ld.get(responseData, `p2pEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field p2pEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `paybillEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`paybillEnabled`)) {\n                    const value = ld.get(jsonResponse, `paybillEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field paybillEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `payoffAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`payoffAmount`)) {\n                    const value = ld.get(responseData, `payoffAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field payoffAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerName`)) {\n                    const value = ld.get(jsonResponse, `personalBankerName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBankerContact:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact.email`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerContact.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerContact.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `postedBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`postedBalance`)) {\n                    const value = ld.get(responseData, `postedBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field postedBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `principalBalance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`principalBalance`)) {\n                    const value = ld.get(jsonResponse, `principalBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field principalBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `productCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`productCode`)) {\n                    const value = ld.get(jsonResponse, `productCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field productCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `productName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`productName`)) {\n                    const value = ld.get(jsonResponse, `productName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field productName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `propertyAddress` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`propertyAddress`)) {\n                    const value = ld.get(jsonResponse, `propertyAddress`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field propertyAddress:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `rewardPoints` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`rewardPoints`)) {\n                    const value = ld.get(jsonResponse, `rewardPoints`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field rewardPoints:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `routingNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`routingNumber`)) {\n                    const value = ld.get(jsonResponse, `routingNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field routingNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `statementDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`statementDate`)) {\n                    const value = ld.get(jsonResponse, `statementDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field statementDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `swiftCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`swiftCode`)) {\n                    const value = ld.get(jsonResponse, `swiftCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field swiftCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`totalBalance`)) {\n                    const value = ld.get(responseData, `totalBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field totalBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `unbilledAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`unbilledAmount`)) {\n                    const value = ld.get(responseData, `unbilledAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field unbilledAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `valueAtMaturity` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`valueAtMaturity`)) {\n                    const value = ld.get(responseData, `valueAtMaturity`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field valueAtMaturity:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `holdAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`holdAmount`)) {\n                    const value = ld.get(responseData, `holdAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field holdAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `unclearFundsAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`unclearFundsAmount`)) {\n                    const value = ld.get(responseData, `unclearFundsAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field unclearFundsAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `averageMonthlyBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`averageMonthlyBalance`)) {\n                    const value = ld.get(responseData, `averageMonthlyBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field averageMonthlyBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `netWithdrawableBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`netWithdrawableBalance`)) {\n                    const value = ld.get(responseData, `netWithdrawableBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field netWithdrawableBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalTenure` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`totalTenure`)) {\n                    const value = ld.get(jsonResponse, `totalTenure`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field totalTenure:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `remainingTenure` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`remainingTenure`)) {\n                    const value = ld.get(jsonResponse, `remainingTenure`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field remainingTenure:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `debitAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`debitAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `debitAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field debitAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lateFee` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lateFee`)) {\n                    const value = ld.get(responseData, `lateFee`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lateFee:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `bounceCharge` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`bounceCharge`)) {\n                    const value = ld.get(responseData, `bounceCharge`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field bounceCharge:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalCharges` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`totalCharges`)) {\n                    const value = ld.get(responseData, `totalCharges`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field totalCharges:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `overDueAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`overDueAmount`)) {\n                    const value = ld.get(responseData, `overDueAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field overDueAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    const value = ld.get(jsonResponse, `cardDetails`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field cardDetails:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the cardDetails field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    let cardDetailsArray = ld.get(jsonResponse, `cardDetails`, []);\n                    if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                            let iterator = cardDetails_it;\n                            if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardImage' has 'cardImage' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardImage`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardImage:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].displayCardStatus' has 'displayCardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].displayCardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].displayCardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].primaryCard' has 'primaryCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].primaryCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].primaryCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo' has 'cardChannelInfo' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.ATM' has 'ATM' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.ATM`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.offline' has 'offline' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.offline`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.offline:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.international' has 'international' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.international`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.international:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.international.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.international.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.international.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.international.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.international.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.online' has 'online' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.online`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.online:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.online.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.online.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.online.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.online.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.online.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.contactless' has 'contactless' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.contactless`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions' has 'cardRestrictions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardRestrictions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'countries' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.countries`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the cardDetails[${cardDetails_it}].cardRestrictions.countries field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails[${cardDetails_it}].cardRestrictions.countries`)) {\n                    let countriesArray = ld.get(jsonResponse, `cardDetails[${cardDetails_it}].cardRestrictions.countries`, []);\n                    if (Array.isArray(countriesArray)) {\n                        for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                            let iterator = countries_it;\n                            if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode' has 'countrycode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'MCC' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the cardDetails[${cardDetails_it}].cardRestrictions.MCC field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails[${cardDetails_it}].cardRestrictions.MCC`)) {\n                    let MCCArray = ld.get(jsonResponse, `cardDetails[${cardDetails_it}].cardRestrictions.MCC`, []);\n                    if (Array.isArray(MCCArray)) {\n                        for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                            let iterator = MCC_it;\n                            if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].blockReason' has 'blockReason' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].blockReason`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].blockReason:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].nameOnCard' has 'nameOnCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].nameOnCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].nameOnCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardNetwork' has 'cardNetwork' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardNetwork`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardNetwork:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay' has 'autopay' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].autopay:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.enabled' has 'enabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.enabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].autopay.enabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.sourceAccountId' has 'sourceAccountId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.sourceAccountId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.sourceAccountId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.paymentType' has 'paymentType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.paymentType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.paymentType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.onStatementDate' has 'onStatementDate' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.onStatementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].autopay.onStatementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.dayOfMonth' has 'dayOfMonth' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.dayOfMonth`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.dayOfMonth:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'minimumPaymentDue' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'partialPaymentPaid' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].partialPaymentPaid`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].partialPaymentPaid:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `IsCrossAccount` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`IsCrossAccount`)) {\n                    const value = ld.get(jsonResponse, `IsCrossAccount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field IsCrossAccount:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountsLimit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"accountName\": \"ut consectetur officia\",\n    \"accountNickname\": \"velit cillum \",\n    \"accountNumber\": \"anim velit et dolor cillum\",\n    \"accountType\": \"ea fugiat est\",\n    \"balance\": \"non voluptate\",\n    \"cardName\": \"amet nisi proident aute\",\n    \"cardNumber\": \"sed sit veniam incididunt in\",\n    \"currency\": \"\",\n    \"customerId\": 50846389.263878465,\n    \"perTxn\": -91310070.10344115,\n    \"status\": \"dolor occaecat voluptate\",\n    \"availableCashLimit\": -86944392.35111924,\n    \"creditLimit\": 97994791.94485152,\n    \"availableCredit\": 40809814.38383478,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": -83344061.2639126,\n          \"maximum\": -50022940.61095891,\n          \"spent\": -56203546.443973675\n        },\n        \"daily\": {\n          \"available\": -76383896.99532545,\n          \"maximum\": -14521011.171627492,\n          \"spent\": -78431192.31777172\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 75430947.63427201,\n          \"maximum\": -41357406.31844404,\n          \"usedup\": 5550752.1303332\n        },\n        \"daily\": {\n          \"available\": -1893242.8120279163,\n          \"maximum\": 70177766.82332987,\n          \"usedup\": -33016528.28929145\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": -25591953.84161392,\n      \"maximum\": -2566574.7470186204,\n      \"usedup\": -54463251.81492795,\n      \"amountperday\": -41398919.96793232\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": -61958310.40497408,\n          \"maximum\": -86459892.2802375,\n          \"spent\": 13503502.86328581\n        },\n        \"daily\": {\n          \"available\": -7741022.4696017355,\n          \"maximum\": -13883386.725176856,\n          \"spent\": 45120640.64996269\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": -22722412.957552597,\n          \"maximum\": -37284019.4857333,\n          \"usedup\": -87986141.86034657\n        },\n        \"daily\": {\n          \"available\": 60933617.03777203,\n          \"maximum\": 80367414.18344936,\n          \"usedup\": 96190538.64810506\n        }\n      }\n    }\n  },\n  {\n    \"accountName\": \"adipisicing in voluptate\",\n    \"accountNickname\": \"aute sed est dolor\",\n    \"accountNumber\": \"voluptate pariatur aliquip\",\n    \"accountType\": \"anim Ut est\",\n    \"balance\": \"commodo ipsum qui\",\n    \"cardName\": \"incididunt nostrud laborum\",\n    \"cardNumber\": \"Lorem cupidatat irure non\",\n    \"currency\": \"ut\",\n    \"customerId\": -68958083.01594949,\n    \"perTxn\": -41927489.50578524,\n    \"status\": \"sunt commodo nostrud do\",\n    \"availableCashLimit\": -70156706.92746542,\n    \"creditLimit\": 78802440.80358657,\n    \"availableCredit\": -80755067.5921167,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": -6653916.144245639,\n          \"maximum\": -32814833.305597186,\n          \"spent\": -83399377.38463336\n        },\n        \"daily\": {\n          \"available\": -71419467.51588523,\n          \"maximum\": 90214992.78333017,\n          \"spent\": -65328598.82566915\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": -9384384.750955954,\n          \"maximum\": -89043253.7024287,\n          \"usedup\": 87084289.62131256\n        },\n        \"daily\": {\n          \"available\": 20817802.075551257,\n          \"maximum\": -82509664.22124036,\n          \"usedup\": 2199702.306698054\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": -28045576.326997295,\n      \"maximum\": 36338981.51956099,\n      \"usedup\": 65343834.89911848,\n      \"amountperday\": -57461019.642294794\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": -53644212.86381411,\n          \"maximum\": 80374855.34489283,\n          \"spent\": -59580287.86738057\n        },\n        \"daily\": {\n          \"available\": -73872122.73137292,\n          \"maximum\": 70795731.24877611,\n          \"spent\": -28512826.717557132\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": -46704307.271214195,\n          \"maximum\": -11526825.570809945,\n          \"usedup\": 5147994.545909911\n        },\n        \"daily\": {\n          \"available\": 37911783.701860905,\n          \"maximum\": -55999701.36244865,\n          \"usedup\": -90519074.69032155\n        }\n      }\n    }\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountsLimit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `accountName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountName`)) {\n                    const value = ld.get(jsonResponse, `accountName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNickname` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNickname`)) {\n                    const value = ld.get(jsonResponse, `accountNickname`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNickname:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountType`)) {\n                    const value = ld.get(jsonResponse, `accountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `balance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`balance`)) {\n                    const value = ld.get(jsonResponse, `balance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field balance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardName`)) {\n                    const value = ld.get(jsonResponse, `cardName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `perTxn` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`perTxn`)) {\n                    const value = ld.get(responseData, `perTxn`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field perTxn:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCashLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCashLimit`)) {\n                    const value = ld.get(responseData, `availableCashLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `creditLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`creditLimit`)) {\n                    const value = ld.get(responseData, `creditLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field creditLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCredit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCredit`)) {\n                    const value = ld.get(responseData, `availableCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase`)) {\n                    const value = ld.get(jsonResponse, `purchase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`txnsPerDay`)) {\n                    const value = ld.get(jsonResponse, `txnsPerDay`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field txnsPerDay:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.available` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.available`)) {\n                    const value = ld.get(responseData, `txnsPerDay.available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.maximum` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.maximum`)) {\n                    const value = ld.get(responseData, `txnsPerDay.maximum`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.maximum:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.usedup` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.usedup`)) {\n                    const value = ld.get(responseData, `txnsPerDay.usedup`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.usedup:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.amountperday` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.amountperday`)) {\n                    const value = ld.get(responseData, `txnsPerDay.amountperday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.amountperday:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal`)) {\n                    const value = ld.get(jsonResponse, `withdrawal`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.daily:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountSpecificLimitsInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 1045300,\n    \"currency\": \"USD\",\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 5,\n      \"maximum\": 8,\n      \"usedup\": 3,\n      \"amount\": 500\n    },\n    \"perTxn\": 500\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountSpecificLimitsInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `perTxn` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`perTxn`)) {\n                    const value = ld.get(responseData, `perTxn`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field perTxn:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase`)) {\n                    const value = ld.get(jsonResponse, `purchase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`txnsPerDay`)) {\n                    const value = ld.get(jsonResponse, `txnsPerDay`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field txnsPerDay:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.available` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.available`)) {\n                    const value = ld.get(responseData, `txnsPerDay.available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.maximum` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.maximum`)) {\n                    const value = ld.get(responseData, `txnsPerDay.maximum`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.maximum:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.usedup` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.usedup`)) {\n                    const value = ld.get(responseData, `txnsPerDay.usedup`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.usedup:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.amount`)) {\n                    const value = ld.get(responseData, `txnsPerDay.amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal`)) {\n                    const value = ld.get(jsonResponse, `withdrawal`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.daily:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateAccountInfo",
      "request": {
        "name": "UpdateAccountInfo",
        "description": {
          "content": "Update customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateAccountInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCustomerInfo",
      "request": {
        "name": "GetCustomerInfo",
        "description": {
          "content": "fetch customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"alternatePhoneNumber\": 61984432.54156309,\n  \"customerId\": \"irure proident sunt\",\n  \"email\": \"ut nisi dolor\",\n  \"identificationNumber\": 25389669.592501193,\n  \"identificationType\": \"esse minim quis\",\n  \"image\": \"magna sit aliquip quis ex\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": true,\n  \"location\": \"nisi dolor dolor ex\",\n  \"name\": \"ad dolor cupidatat veniam\",\n  \"firstName\": \"esse\",\n  \"lastName\": \"Excepteur mollit incididunt ullamco pariatur\",\n  \"personalBanker\": {\n    \"name\": \"magna ipsum ad dolor\",\n    \"email\": \"qui occaecat\",\n    \"mobileNumber\": \"Excepteur Ut irure incididunt\"\n  },\n  \"phone\": -37675692.857823774,\n  \"securityQuestions\": [\n    \"id proident sunt\",\n    \"aute fugiat\"\n  ],\n  \"segmentId\": -26063592.120869964\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCustomerInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `alternatePhoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`alternatePhoneNumber`)) {\n                    const value = ld.get(responseData, `alternatePhoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(jsonResponse, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`identificationNumber`)) {\n                    const value = ld.get(responseData, `identificationNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field identificationNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationType`)) {\n                    const value = ld.get(jsonResponse, `identificationType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `firstName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`firstName`)) {\n                    const value = ld.get(jsonResponse, `firstName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field firstName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastName`)) {\n                    const value = ld.get(jsonResponse, `lastName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker`)) {\n                    const value = ld.get(jsonResponse, `personalBanker`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBanker:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.name`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.email`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `securityQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`securityQuestions`)) {\n                    const value = ld.get(jsonResponse, `securityQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field securityQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `segmentId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`segmentId`)) {\n                    const value = ld.get(responseData, `segmentId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field segmentId:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateCustomerInfo",
      "request": {
        "name": "UpdateCustomerInfo",
        "description": {
          "content": "Update customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateCustomerInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetTransactions",
      "request": {
        "name": "GetTransactions",
        "description": {
          "content": "Fetch transactions information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetTransactions"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetTransactions"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": -61683026.575464204,\n    \"transactionId\": 45047267.646268934,\n    \"accountNumber\": \"Duis occaecat culpa\",\n    \"timestamp\": -89408706.33685529,\n    \"amount\": 35101296.341115594,\n    \"currency\": \"ut nisi l\",\n    \"debitOrCredit\": \"consequat\",\n    \"description\": \"sed ad aliquip\",\n    \"paymentMode\": \"aliqua exercitation sit velit\",\n    \"DBANames\": \"culpa et veniam fugiat\",\n    \"status\": \"dolor aliqua cupidatat\",\n    \"closingBalance\": 44927570.28189275,\n    \"transacitonType\": \"ipsum dolor Lorem\",\n    \"ACHCode\": \"minim commodo laboris fugiat consectetur\",\n    \"MCCCode\": \"proident ut\",\n    \"SICCode\": \"Excepteur magna enim\",\n    \"name\": \"Excepteur do culpa ea in\",\n    \"address\": \"sed consecte\",\n    \"street\": \"esse do\",\n    \"city\": \"ut esse laboris velit aute\",\n    \"state\": \"minim est\",\n    \"zip\": \"laborum exercitation\",\n    \"country\": \"anim veniam\",\n    \"phoneNumber\": -16929996.825850993,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  },\n  {\n    \"customerId\": 1674350.4456048459,\n    \"transactionId\": -85234978.78197874,\n    \"accountNumber\": \"Duis\",\n    \"timestamp\": -37996000.884215556,\n    \"amount\": -83824796.23009096,\n    \"currency\": \"reprehenderit deserunt\",\n    \"debitOrCredit\": \"magna\",\n    \"description\": \"tempor sint fugiat culpa\",\n    \"paymentMode\": \"in consequat sed irure\",\n    \"DBANames\": \"sunt proident id quis\",\n    \"status\": \"id cupidatat ex sed\",\n    \"closingBalance\": -74052071.63616443,\n    \"transacitonType\": \"elit id nostrud\",\n    \"ACHCode\": \"amet culpa\",\n    \"MCCCode\": \"cupidatat fugiat sed\",\n    \"SICCode\": \"labore qui amet\",\n    \"name\": \"eu anim repre\",\n    \"address\": \"ad ipsum\",\n    \"street\": \"qui non minim\",\n    \"city\": \"veniam\",\n    \"state\": \"nulla qui\",\n    \"zip\": \"nisi adipisicing\",\n    \"country\": \"elit labore esse in\",\n    \"phoneNumber\": 94024758.58318236,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetTransactions for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `transactionId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`transactionId`)) {\n                    const value = ld.get(responseData, `transactionId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field transactionId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `timestamp` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`timestamp`)) {\n                    const value = ld.get(responseData, `timestamp`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field timestamp:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`amount`)) {\n                    const value = ld.get(responseData, `amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `debitOrCredit` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`debitOrCredit`)) {\n                    const value = ld.get(jsonResponse, `debitOrCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field debitOrCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `description` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`description`)) {\n                    const value = ld.get(jsonResponse, `description`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field description:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `paymentMode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`paymentMode`)) {\n                    const value = ld.get(jsonResponse, `paymentMode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field paymentMode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DBANames` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DBANames`)) {\n                    const value = ld.get(jsonResponse, `DBANames`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DBANames:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `closingBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`closingBalance`)) {\n                    const value = ld.get(responseData, `closingBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field closingBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `transacitonType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`transacitonType`)) {\n                    const value = ld.get(jsonResponse, `transacitonType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field transacitonType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ACHCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`ACHCode`)) {\n                    const value = ld.get(jsonResponse, `ACHCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field ACHCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `MCCCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`MCCCode`)) {\n                    const value = ld.get(jsonResponse, `MCCCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field MCCCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SICCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SICCode`)) {\n                    const value = ld.get(jsonResponse, `SICCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SICCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `address` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`address`)) {\n                    const value = ld.get(jsonResponse, `address`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field address:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `street` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`street`)) {\n                    const value = ld.get(jsonResponse, `street`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field street:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `city` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`city`)) {\n                    const value = ld.get(jsonResponse, `city`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field city:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `state` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`state`)) {\n                    const value = ld.get(jsonResponse, `state`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field state:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `zip` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`zip`)) {\n                    const value = ld.get(jsonResponse, `zip`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field zip:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country`)) {\n                    const value = ld.get(jsonResponse, `country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phoneNumber`)) {\n                    const value = ld.get(responseData, `phoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metaInfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metaInfo`)) {\n                    const value = ld.get(jsonResponse, `metaInfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field metaInfo:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the metaInfo field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metaInfo`)) {\n                    let metaInfoArray = ld.get(jsonResponse, `metaInfo`, []);\n                    if (Array.isArray(metaInfoArray)) {\n                        for (let metaInfo_it = 0; metaInfo_it < metaInfoArray.length; metaInfo_it++) {\n                            let iterator = metaInfo_it;\n                            if (metaInfoArray[metaInfo_it] !== null && metaInfoArray[metaInfo_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'metaInfo[${metaInfo_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `metaInfo[${metaInfo_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for metaInfo[${metaInfo_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'metaInfo[${metaInfo_it}].value' has 'value' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `metaInfo[${metaInfo_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for metaInfo[${metaInfo_it}].value:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for metaInfo:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "TransferFunds",
      "request": {
        "name": "TransferFunds",
        "description": {
          "content": "Transfers funds between accounts",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "TransferFunds"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*string}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Transaction success",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for TransferFunds for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Transaction success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetScheduleTransfers",
      "request": {
        "name": "GetScheduleTransfers",
        "description": {
          "content": "Fetches the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"cillum Ut\",\n    \"CustomerId\": -44851873.87624228,\n    \"Amount\": 53349558.79418838,\n    \"SourceAccountNumber\": \"dolor exercitation Ut\",\n    \"TargetAccountNumber\": \"sint dolore\",\n    \"DueDate\": \"ullamco ex\",\n    \"InvoiceNumber\": -95999568.56275144,\n    \"Currency\": \"sit esse adipisicing eiusmod\",\n    \"Status\": \"nostrud\",\n    \"ScheduledDate\": -80796272.6001004,\n    \"NextScheduleDate\": -3464504.561138779,\n    \"id\": \"dolor aute dolor ut esse\"\n  },\n  {\n    \"Type\": \"eu\",\n    \"CustomerId\": -93398091.62273557,\n    \"Amount\": 40723857.10653746,\n    \"SourceAccountNumber\": \"enim eiusmod exercitation ipsum\",\n    \"TargetAccountNumber\": \"sint officia in in laborum\",\n    \"DueDate\": \"ea magna cupidatat ex\",\n    \"InvoiceNumber\": -98254200.30676942,\n    \"Currency\": \"ipsum quis Duis\",\n    \"Status\": \"velit ullamco\",\n    \"ScheduledDate\": 47007263.96233374,\n    \"NextScheduleDate\": 8723647.798850685,\n    \"id\": \"dolore non\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `InvoiceNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`InvoiceNumber`)) {\n                    const value = ld.get(responseData, `InvoiceNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field InvoiceNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ScheduledDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ScheduledDate`)) {\n                    const value = ld.get(responseData, `ScheduledDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ScheduledDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `NextScheduleDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`NextScheduleDate`)) {\n                    const value = ld.get(responseData, `NextScheduleDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field NextScheduleDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateScheduleTransfers",
      "request": {
        "name": "UpdateScheduleTransfers",
        "description": {
          "content": "Update the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateScheduleTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Scheduled transfer updated successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteScheduleTransfers",
      "request": {
        "name": "DeleteScheduleTransfers",
        "description": {
          "content": "Delete the scheduled transfer",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Scheduled transfer deleted successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AddRecurringTransfers",
      "request": {
        "name": "AddRecurringTransfers",
        "description": {
          "content": "Adds the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "AddRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer added successfully",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for AddRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer added successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetRecurringTransfers",
      "request": {
        "name": "GetRecurringTransfers",
        "description": {
          "content": "Fetches all the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"sed nisi sit ut\",\n    \"CustomerId\": -99980881.3783182,\n    \"Amount\": 80063405.22722626,\n    \"SourceAccountNumber\": \"commodo tempor\",\n    \"TargetAccountNumber\": \"consequat consectetur\",\n    \"DueDate\": \"ex ullamco id in\",\n    \"Currency\": \"cillum dolor consectetur aliquip\",\n    \"Status\": \"dolor laboris sit dolore\",\n    \"ScheduledDate\": -41464702.09974797,\n    \"recurringOptions\": {\n      \"amountType\": \"eu laborum nulla mollit\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"sint qui in mollit\",\n          \"untilDate\": \"ut anim\",\n          \"numberOfPayments\": \"in consectetur veniam officia et\"\n        },\n        \"iterate\": \"dolor aliquip anim\"\n      }\n    },\n    \"id\": \"eu Lorem\"\n  },\n  {\n    \"Type\": \"enim minim\",\n    \"CustomerId\": 97690145.28897086,\n    \"Amount\": 82233648.35453841,\n    \"SourceAccountNumber\": \"tempor culpa ipsum\",\n    \"TargetAccountNumber\": \"aliquip ut eiusmod\",\n    \"DueDate\": \"Ut minim nulla\",\n    \"Currency\": \"sit laboris ipsum\",\n    \"Status\": \"fugiat consectetur dolore\",\n    \"ScheduledDate\": -44199826.74480037,\n    \"recurringOptions\": {\n      \"amountType\": \"aliquip elit culpa voluptate\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"esse voluptate Duis minim eiusmod\",\n          \"untilDate\": \"dolor amet anim\",\n          \"numberOfPayments\": \"do Lorem ea aliqua\"\n        },\n        \"iterate\": \"aliquip adipisicing\"\n      }\n    },\n    \"id\": \"aliqua incididunt minim\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ScheduledDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ScheduledDate`)) {\n                    const value = ld.get(responseData, `ScheduledDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ScheduledDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.amountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.amountType`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.amountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field recurringOptions.amountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions.frequency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency.duration` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency.duration`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency.duration`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions.frequency.duration:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency.iterate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency.iterate`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency.iterate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field recurringOptions.frequency.iterate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateRecurringTransfers",
      "request": {
        "name": "UpdateRecurringTransfers",
        "description": {
          "content": "Update the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            },\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\"\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateRecurringTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Recurring transfer updated successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteRecurringTransfers",
      "request": {
        "name": "DeleteRecurringTransfers",
        "description": {
          "content": "Delete the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Recurring transfer deleted successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "resetPassword",
      "request": {
        "name": "resetPassword",
        "description": {
          "content": "It allows to reset the password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "resetPassword"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"password\": \"{{password_*string}}\",\n    \"username\": \"{{username_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "password has been updated successfully.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for resetPassword for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"password has been updated successfully.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "debitcardInfoValidation",
      "request": {
        "name": "debitcardInfoValidation",
        "description": {
          "content": "for validating card info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "debitcardInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*string}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*string}}\",\n    \"expiryDate\": \"{{expiryDate_*string}}\",\n    \"pin\": \"{{pin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for debitcardInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Validated Successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "personalInfoValidation",
      "request": {
        "name": "personalInfoValidation",
        "description": {
          "content": "for validating personal info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "personalInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*string}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*string}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for personalInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Validated Successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "disputeTransaction",
      "request": {
        "name": "disputeTransaction",
        "description": {
          "content": "dispute a transaction",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "disputeTransaction"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Dispute Transactions reported successfully",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for disputeTransaction for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Dispute Transactions reported successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "ccPay",
      "request": {
        "name": "ccPay",
        "description": {
          "content": "to pay cc bill",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "ccPay"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Credit Card payment scheduled successfully",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for ccPay for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Credit Card payment scheduled successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCCSchedule",
      "request": {
        "name": "GetCCSchedule",
        "description": {
          "content": "Fetch cc payment list",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCCSchedule"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"amet cupidatat Lorem in ut\",\n    \"CustomerId\": -62743481.83842342,\n    \"Amount\": 46324664.20763457,\n    \"SourceAccountNumber\": \"proident\",\n    \"TargetAccountNumber\": \"dolore do aliqua\",\n    \"DueDate\": \"labore veniam ea do\",\n    \"Currency\": \"labore aute\",\n    \"Status\": \"ipsum eu ex\",\n    \"id\": \"do exercitation amet velit\"\n  },\n  {\n    \"Type\": \"anim ut Duis laborum\",\n    \"CustomerId\": -15872096.179031119,\n    \"Amount\": 22915069.20134379,\n    \"SourceAccountNumber\": \"veniam sit\",\n    \"TargetAccountNumber\": \"voluptate sed laborum irure\",\n    \"DueDate\": \"laboris\",\n    \"Currency\": \"ipsum consequat exercitation\",\n    \"Status\": \"aliquip quis\",\n    \"id\": \"ullamco et in fugiat\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCCSchedule for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendsecuremessage",
      "request": {
        "name": "sendsecuremessage",
        "description": {
          "content": "send secure message",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendsecuremessage"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendsecuremessage for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "locateProfile",
      "request": {
        "name": "locateProfile",
        "description": {
          "content": "get profile details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "locateProfile"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"accountNumber\": \"id magn\",\n  \"cardDetails\": {\n    \"cardNumber\": \"nulla aute qui\",\n    \"expiryDate\": \"cillum culpa elit aliqua\",\n    \"cvv\": \"deserunt eiusmod\",\n    \"pin\": \"fugiat\"\n  },\n  \"personalQuestions\": {\n    \"DOB\": \"reprehenderit\",\n    \"SSN\": -46804736.614761166,\n    \"SecretPassword\": \"dolor sit\",\n    \"LDAmount\": -96217778.21648511,\n    \"AccNumber\": \"irure\"\n  },\n  \"ssNumber\": 16640425.339875087,\n  \"ssnShort\": 73667762.25185165,\n  \"alternatePhoneNumber\": -1986592.87917687,\n  \"customerId\": \"adipisicing tempor sit ut proident\",\n  \"email\": \"culpa eiusmod\",\n  \"identificationNumber\": \"officia sunt commodo\",\n  \"identificationType\": \"anim qu\",\n  \"image\": \"aute qui\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": false,\n  \"location\": \"laboris esse ut nostrud\",\n  \"name\": \"adipisicing est sint aliquip sed\",\n  \"personalBanker\": {\n    \"name\": \"mollit in fugiat\",\n    \"email\": \"sit Duis\",\n    \"mobileNumber\": \"incididunt ipsum ad amet nisi\"\n  },\n  \"phone\": 78343318.28913376,\n  \"securityQuestions\": [\n    \"ut cillum anim\",\n    \"ex ut proident id sed\"\n  ],\n  \"segmentId\": -52895354.28132313,\n  \"multiAccounts\": [\n    {\n      \"accountNumber\": \"elit officia tempor\",\n      \"cardDetails\": {\n        \"cardNumber\": \"pariatur irure tempor officia\",\n        \"expiryDate\": \"\",\n        \"cvv\": \"in\",\n        \"pin\": \"voluptate nisi\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"enim in\",\n        \"SSN\": 78642321.06354502,\n        \"SecretPassword\": \"deserunt ad\",\n        \"LDAmount\": 60169837.718601465,\n        \"AccNumber\": \"amet ex\"\n      },\n      \"ssNumber\": -51169991.59936761,\n      \"ssnShort\": -65314937.89251583,\n      \"alternatePhoneNumber\": -86745809.03580762,\n      \"customerId\": \"proident amet nostrud et\",\n      \"email\": \"laborum irure dolor\",\n      \"identificationNumber\": \"in esse sunt qui\",\n      \"identificationType\": \"sed Duis anim laboris\",\n      \"location\": \"velit est sint ipsum ad\",\n      \"name\": \"proident nulla eu\",\n      \"phone\": 55809565.93471146\n    },\n    {\n      \"accountNumber\": \"consectetur pariatur\",\n      \"cardDetails\": {\n        \"cardNumber\": \"culpa dolore reprehenderit laboris\",\n        \"expiryDate\": \"adipisicing dolore\",\n        \"cvv\": \"cupidatat nulla exercitation dolor commodo\",\n        \"pin\": \"labore\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"pariatur\",\n        \"SSN\": -27568273.24166,\n        \"SecretPassword\": \"elit\",\n        \"LDAmount\": 75116714.93091047,\n        \"AccNumber\": \"aliquip enim Lorem elit\"\n      },\n      \"ssNumber\": -89095939.83042488,\n      \"ssnShort\": 17426617.10233438,\n      \"alternatePhoneNumber\": 47776748.54866728,\n      \"customerId\": \"minim ea\",\n      \"email\": \"non mollit\",\n      \"identificationNumber\": \"consectetur pariatur nulla\",\n      \"identificationType\": \"minim offic\",\n      \"location\": \"dolor ad minim\",\n      \"name\": \"ea ipsum dolore\",\n      \"phone\": 48712628.595326185\n    }\n  ],\n  \"warningCodes\": [\n    {\n      \"code\": 71423658.92761081,\n      \"level\": \"in ipsum tempor ad cupidatat\",\n      \"description\": \"consectetur occaecat enim commodo cillum\"\n    },\n    {\n      \"code\": 44038806.13911876,\n      \"level\": \"e\",\n      \"description\": \"in in ex ipsum\"\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for locateProfile for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    const value = ld.get(jsonResponse, `cardDetails`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field cardDetails:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.expiryDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.expiryDate`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.expiryDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.expiryDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.cvv` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.cvv`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.cvv`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.cvv:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.pin` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.pin`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.pin`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.pin:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.DOB` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.DOB`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.DOB`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.DOB:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.SSN` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`personalQuestions.SSN`)) {\n                    const value = ld.get(responseData, `personalQuestions.SSN`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field personalQuestions.SSN:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.SecretPassword` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.SecretPassword`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.SecretPassword`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.SecretPassword:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.LDAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`personalQuestions.LDAmount`)) {\n                    const value = ld.get(responseData, `personalQuestions.LDAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field personalQuestions.LDAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.AccNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.AccNumber`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.AccNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.AccNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ssNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ssNumber`)) {\n                    const value = ld.get(responseData, `ssNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ssNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ssnShort` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ssnShort`)) {\n                    const value = ld.get(responseData, `ssnShort`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ssnShort:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `alternatePhoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`alternatePhoneNumber`)) {\n                    const value = ld.get(responseData, `alternatePhoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(jsonResponse, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationNumber`)) {\n                    const value = ld.get(jsonResponse, `identificationNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationType`)) {\n                    const value = ld.get(jsonResponse, `identificationType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker`)) {\n                    const value = ld.get(jsonResponse, `personalBanker`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBanker:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.name`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.email`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `securityQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`securityQuestions`)) {\n                    const value = ld.get(jsonResponse, `securityQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field securityQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `segmentId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`segmentId`)) {\n                    const value = ld.get(responseData, `segmentId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field segmentId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `multiAccounts` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`multiAccounts`)) {\n                    const value = ld.get(jsonResponse, `multiAccounts`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field multiAccounts:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the multiAccounts field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`multiAccounts`)) {\n                    let multiAccountsArray = ld.get(jsonResponse, `multiAccounts`, []);\n                    if (Array.isArray(multiAccountsArray)) {\n                        for (let multiAccounts_it = 0; multiAccounts_it < multiAccountsArray.length; multiAccounts_it++) {\n                            let iterator = multiAccounts_it;\n                            if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].accountNumber' has 'accountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].accountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].accountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails' has 'cardDetails' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for multiAccounts[${multiAccounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.expiryDate' has 'expiryDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.expiryDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.expiryDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.cvv' has 'cvv' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.cvv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.cvv:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.pin' has 'pin' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.pin`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.pin:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions' has 'personalQuestions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for multiAccounts[${multiAccounts_it}].personalQuestions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.DOB' has 'DOB' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.DOB`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.DOB:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'SSN' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].personalQuestions.SSN`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].personalQuestions.SSN:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword' has 'SecretPassword' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'LDAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].personalQuestions.LDAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].personalQuestions.LDAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber' has 'AccNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'ssNumber' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].ssNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].ssNumber:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'ssnShort' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].ssnShort`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].ssnShort:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'alternatePhoneNumber' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].alternatePhoneNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].customerId' has 'customerId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].customerId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].customerId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].identificationNumber' has 'identificationNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].identificationNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].identificationNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].identificationType' has 'identificationType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].identificationType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].identificationType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].location' has 'location' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].location`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].location:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'phone' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].phone`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].phone:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for multiAccounts:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `warningCodes` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`warningCodes`)) {\n                    const value = ld.get(jsonResponse, `warningCodes`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field warningCodes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the warningCodes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`warningCodes`)) {\n                    let warningCodesArray = ld.get(jsonResponse, `warningCodes`, []);\n                    if (Array.isArray(warningCodesArray)) {\n                        for (let warningCodes_it = 0; warningCodes_it < warningCodesArray.length; warningCodes_it++) {\n                            let iterator = warningCodes_it;\n                            if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'warningCodesArray' has 'code' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `warningCodes[${warningCodes_it}].code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for warningCodes[${warningCodes_it}].code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'warningCodes[${warningCodes_it}].level' has 'level' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `warningCodes[${warningCodes_it}].level`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for warningCodes[${warningCodes_it}].level:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'warningCodes[${warningCodes_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `warningCodes[${warningCodes_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for warningCodes[${warningCodes_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for warningCodes:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the exiting user",
      "request": {
        "name": "to validate the exiting user",
        "description": {
          "content": "to validate the in of existing user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validateUser"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validateUser for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PINs matched\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the pins entered by the new user",
      "request": {
        "name": "to validate the pins entered by the new user",
        "description": {
          "content": "to validate the pins entered by the new user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePIN"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePIN for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PINs matched\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate if pin entered by new user follows pin rules",
      "request": {
        "name": "to validate if pin entered by new user follows pin rules",
        "description": {
          "content": "to validate if pin entered by new user follows pin rules",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePINRules"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PIN rules satisfied",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePINRules for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PIN rules satisfied\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the account closure status",
      "request": {
        "name": "to fetch the account closure status",
        "description": {
          "content": "to fetch the account closure status",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "getRequestStatus"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for getRequestStatus for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to place the request",
      "request": {
        "name": "to place the request",
        "description": {
          "content": "to place the request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "request"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for request for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to enable or disable e or paper statements at profile level",
      "request": {
        "name": "to enable or disable e or paper statements at profile level",
        "description": {
          "content": "to enable or disable e or paper statements at profile level",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "enableEStatement"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for enableEStatement for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to update the cheque book details of customer accounts",
      "request": {
        "name": "to update the cheque book details of customer accounts",
        "description": {
          "content": "Update customer cheque book details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "RequestChequeBook"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for RequestChequeBook for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendOTP",
      "request": {
        "name": "sendOTP",
        "description": {
          "content": "sends OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "verification code has been sent to your mobile number",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"verification code has been sent to your mobile number\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "verifyOTP",
      "request": {
        "name": "verifyOTP",
        "description": {
          "content": " to verify OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "verifyOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "OTP verifid successfully",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for verifyOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"OTP verifid successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the deeplink",
      "request": {
        "name": "to fetch the deeplink",
        "description": {
          "content": "to fetch the deeplink",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deeplink"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "tenantId",
            "value": "{{tenantId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "environment",
            "value": "{{environment}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "channel",
            "value": "{{channel}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"usecase\": \"addbeneficiary\",\n    \"link\": \"www.google.com\",\n    \"linkType\": \"deeplink\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"laboris commodo ipsum\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756442188604 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deeplink for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `usecase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`usecase`)) {\n                    const value = ld.get(jsonResponse, `usecase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field usecase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `link` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`link`)) {\n                    const value = ld.get(jsonResponse, `link`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field link:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `linkType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`linkType`)) {\n                    const value = ld.get(jsonResponse, `linkType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field linkType:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://localhost:8080/smt",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{bearerToken}}"
      }
    ]
  },
  "info": {
    "_postman_id": "3777c369-c336-48cc-8088-6883f73ebb2f",
    "name": "BankAssist SMT Core Banking API Specification",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "kore.ai banking bot apis.",
      "type": "text/plain"
    }
  }
}