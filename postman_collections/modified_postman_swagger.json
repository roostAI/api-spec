{
  "item": [
    {
      "name": "Submit Request",
      "request": {
        "name": "Submit Request",
        "description": {
          "content": "Meta API request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "submitRequest"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "<object>",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "<object>",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for submitRequest for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AuthToken",
      "request": {
        "name": "AuthToken",
        "description": {
          "content": "Get authentication token",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "authToken"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null
      },
      "response": [
        {
          "name": "successful login",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"token\": \"token\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for authToken for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful login\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `token` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`token`)) {\n                    const value = ld.get(jsonResponse, `token`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field token:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Deposit",
      "request": {
        "name": "Deposit",
        "description": {
          "content": "Deposit amount to customer's account",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deposit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*string}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Deposit success",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deposit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Deposit success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetAccountInfo",
      "request": {
        "name": "GetAccountInfo",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"customerId\": -13123461.259777531,\n  \"accounts\": [\n    {\n      \"customerId\": -92830013.12592392,\n      \"accountName\": \"nisi magna minim cillum\",\n      \"accountNickname\": \"aliqua officia dolore\",\n      \"accountNumber\": \"ullamco\",\n      \"accountType\": \"culpa dolore offi\",\n      \"activatedDate\": \"quis sint\",\n      \"availableBalance\": 90979357.83532986,\n      \"availableCash\": 98049037.83674338,\n      \"availableCashLimit\": 14868794.354926825,\n      \"availableCredit\": 10995144.040394545,\n      \"bankName\": \"enim officia est aliqua\",\n      \"branchName\": \"dolor amet irure Duis\",\n      \"cardName\": \"sed culpa eu nisi\",\n      \"cardNumber\": \"Ut aute pariatur ad\",\n      \"cardStatus\": \"labore sed non proident q\",\n      \"cardType\": \"ullamco fugiat aliquip\",\n      \"creditLimit\": -80124919.67188038,\n      \"currency\": \"pariatur officia\",\n      \"currentBalance\": 12707646.466239586,\n      \"deactivatedDate\": \"esse Ut\",\n      \"dueAmount\": 7590299.008159906,\n      \"dueDate\": \"ut dolore do ex in\",\n      \"earlyWithdrawalPenalty\": 94902882.38662931,\n      \"email\": \"consectetur ex Duis eiusmod\",\n      \"expDate\": \"aute\",\n      \"fdType\": \"Lo\",\n      \"image\": \"in reprehenderit\",\n      \"interestRate\": -96728519.66440068,\n      \"internalTransferFromEnabled\": true,\n      \"internalTransferToEnabled\": false,\n      \"isPrimaryMobile\": true,\n      \"isAlternateMobileNumber\": false,\n      \"isStatement\": true,\n      \"lastDrawDate\": \"commodo aliqua\",\n      \"loanMaturityDate\": \"sed eiusmod volupta\",\n      \"loanOriginationDate\": \"laborum officia\",\n      \"location\": \"magna anim nisi velit\",\n      \"lastUpdated\": \"dolor deserunt quis\",\n      \"maxTransactionLimit\": \"elit\",\n      \"maturityDate\": \"ipsum\",\n      \"minimumPaymentDue\": \"esse adipisicing aute Ut\",\n      \"minimumBalance\": \"minim proident ea cupidatat\",\n      \"monthlyPayment\": 40920616.92374265,\n      \"openingBalance\": -86467227.86653003,\n      \"originalLoanAmount\": -10643612.55778499,\n      \"P2PLimit\": -97096304.46849133,\n      \"p2pEnabled\": 31173218.95937936,\n      \"paybillEnabled\": false,\n      \"payoffAmount\": 91799671.0382227,\n      \"personalBankerName\": \"aliqua\",\n      \"personalBankerContact\": {\n        \"email\": \"reprehenderit\",\n        \"mobileNumber\": \"reprehenderit Lorem magna dolore nulla\"\n      },\n      \"phone\": -58476574.290583104,\n      \"postedBalance\": 88522502.69591498,\n      \"principalBalance\": \"reprehenderit commodo occaecat\",\n      \"productCode\": \"exercitatio\",\n      \"productName\": \"sint occaecat et\",\n      \"propertyAddress\": \"consequat officia ea\",\n      \"rewardPoints\": \"fugiat pariatur oc\",\n      \"routingNumber\": \"elit sin\",\n      \"statementDate\": \"anim in ut\",\n      \"status\": \"commodo\",\n      \"swiftCode\": \"est aliquip\",\n      \"totalBalance\": -93490277.15037726,\n      \"unbilledAmount\": -41075559.21072677,\n      \"valueAtMaturity\": -24986607.145703226,\n      \"holdAmount\": -27658841.11030656,\n      \"unclearFundsAmount\": -10769369.784936294,\n      \"averageMonthlyBalance\": -65232968.82134959,\n      \"netWithdrawableBalance\": 36313469.913733244,\n      \"totalTenure\": \"velit nulla\",\n      \"remainingTenure\": \"magna u\",\n      \"debitAccountNumber\": \"anim\",\n      \"lateFee\": 11104983.36848718,\n      \"bounceCharge\": 88632721.91824022,\n      \"totalCharges\": -10258403.591697186,\n      \"overDueAmount\": 58092635.95029929,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"Lorem\",\n          \"cardNumber\": \"eiusmod\",\n          \"cardStatus\": \"Lorem dolor commodo qui\",\n          \"cardImage\": \"et deserunt\",\n          \"cardType\": \"consectetur Ut ex\",\n          \"expDate\": \"occaecat fugiat\",\n          \"displayCardStatus\": \"magna e\",\n          \"primaryCard\": \"ip\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"sint Duis\",\n          \"nameOnCard\": \"mollit et in\",\n          \"cardNetwork\": \"aliqua Ut ullamco ut dolor\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"proide\",\n            \"paymentType\": \"nisi ex\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"cillu\"\n          },\n          \"dueAmount\": -58914343.70697053,\n          \"dueDate\": \"non\",\n          \"minimumPaymentDue\": 91826576.04259542,\n          \"partialPaymentPaid\": -15280232.875797942\n        },\n        {\n          \"cardName\": \"nisi ut cillu\",\n          \"cardNumber\": \"dolore eu Excepteur\",\n          \"cardStatus\": \"sed eiusmod\",\n          \"cardImage\": \"minim dolore dolor fugiat occaecat\",\n          \"cardType\": \"occaecat consequat\",\n          \"expDate\": \"cupidatat irure\",\n          \"displayCardStatus\": \"qui pariatur mollit consectetur\",\n          \"primaryCard\": \"dolor\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"labore amet aliquip\",\n          \"nameOnCard\": \"comm\",\n          \"cardNetwork\": \"minim occaecat veniam\",\n          \"autopay\": {\n            \"enabled\": false,\n            \"sourceAccountId\": \"quis aute pariatur mi\",\n            \"paymentType\": \"amet elit\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"et esse nostrud ad\"\n          },\n          \"dueAmount\": -64121937.15835337,\n          \"dueDate\": \"cupidatat est\",\n          \"minimumPaymentDue\": -47235359.82472886,\n          \"partialPaymentPaid\": -73845001.06082381\n        }\n      ],\n      \"IsCrossAccount\": false\n    },\n    {\n      \"customerId\": -62199211.16677787,\n      \"accountName\": \"sunt ea Ut\",\n      \"accountNickname\": \"in nostrud in occaecat ad\",\n      \"accountNumber\": \"tempor labore ullamco qui\",\n      \"accountType\": \"pariatur eu\",\n      \"activatedDate\": \"Ut et aute qui qui\",\n      \"availableBalance\": 29602152.76743865,\n      \"availableCash\": -5320122.7100431025,\n      \"availableCashLimit\": -59832325.856318526,\n      \"availableCredit\": 97356153.76698026,\n      \"bankName\": \"ut\",\n      \"branchName\": \"deserunt eiusmod elit dolore cupidatat\",\n      \"cardName\": \"aute \",\n      \"cardNumber\": \"ipsum pariatur consectetur\",\n      \"cardStatus\": \"consectetur dolor dolore\",\n      \"cardType\": \"reprehenderit exercitation aliquip in\",\n      \"creditLimit\": -69117907.94626947,\n      \"currency\": \"qui cillum\",\n      \"currentBalance\": 39556224.120708585,\n      \"deactivatedDate\": \"Lorem et dolore\",\n      \"dueAmount\": 47559435.940203875,\n      \"dueDate\": \"veniam consectetur deserunt irure nulla\",\n      \"earlyWithdrawalPenalty\": -85657731.08325297,\n      \"email\": \"pariatur magna nisi reprehenderit\",\n      \"expDate\": \"in sint aliquip deserunt\",\n      \"fdType\": \"sed eiusmod velit veniam dolore\",\n      \"image\": \"ipsum reprehenderit ad\",\n      \"interestRate\": 66622499.76963875,\n      \"internalTransferFromEnabled\": false,\n      \"internalTransferToEnabled\": true,\n      \"isPrimaryMobile\": false,\n      \"isAlternateMobileNumber\": false,\n      \"isStatement\": true,\n      \"lastDrawDate\": \"laboris \",\n      \"loanMaturityDate\": \"nisi sunt et\",\n      \"loanOriginationDate\": \"quis\",\n      \"location\": \"ut exercitation do\",\n      \"lastUpdated\": \"dolore\",\n      \"maxTransactionLimit\": \"magna id tempor ipsum\",\n      \"maturityDate\": \"voluptate nostrud commodo laboris consectetur\",\n      \"minimumPaymentDue\": \"laboris ex offic\",\n      \"minimumBalance\": \"sed anim Lorem in occaecat\",\n      \"monthlyPayment\": 8174516.853110522,\n      \"openingBalance\": 48301703.56064913,\n      \"originalLoanAmount\": -39761336.22639115,\n      \"P2PLimit\": -894381.3477928042,\n      \"p2pEnabled\": -6802652.884104177,\n      \"paybillEnabled\": true,\n      \"payoffAmount\": -4587222.712582588,\n      \"personalBankerName\": \"id reprehenderit\",\n      \"personalBankerContact\": {\n        \"email\": \"Excepteur ad mollit ipsum\",\n        \"mobileNumber\": \"tempor irure\"\n      },\n      \"phone\": -54967883.1634278,\n      \"postedBalance\": -30456011.204308853,\n      \"principalBalance\": \"\",\n      \"productCode\": \"mollit laborum\",\n      \"productName\": \"ea est quis Ut cupidatat\",\n      \"propertyAddress\": \"aliquip in ex\",\n      \"rewardPoints\": \"tempor eiusmod\",\n      \"routingNumber\": \"est occaecat\",\n      \"statementDate\": \"quis et cil\",\n      \"status\": \"in\",\n      \"swiftCode\": \"Excepteur eiusmod non\",\n      \"totalBalance\": 7582479.182786852,\n      \"unbilledAmount\": 78541427.68819788,\n      \"valueAtMaturity\": -64778179.116975166,\n      \"holdAmount\": 24845866.426472798,\n      \"unclearFundsAmount\": 7979749.131602347,\n      \"averageMonthlyBalance\": -82469580.74643001,\n      \"netWithdrawableBalance\": -52119311.588732444,\n      \"totalTenure\": \"qui cupidatat dolor\",\n      \"remainingTenure\": \"Duis magna\",\n      \"debitAccountNumber\": \"incididunt laboris qui culpa\",\n      \"lateFee\": -23095668.90779169,\n      \"bounceCharge\": 67894298.03098255,\n      \"totalCharges\": 15047841.84468843,\n      \"overDueAmount\": -20185012.536020294,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"occaecat ea nulla aliquip magna\",\n          \"cardNumber\": \"veniam\",\n          \"cardStatus\": \"tempor ut\",\n          \"cardImage\": \"ea eiusmod quis\",\n          \"cardType\": \"ad anim cupidatat in\",\n          \"expDate\": \"esse dolore ipsum commodo velit\",\n          \"displayCardStatus\": \"laboris\",\n          \"primaryCard\": \"in dolor proident eu Excepteur\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"Ut\",\n          \"nameOnCard\": \"eiusmod\",\n          \"cardNetwork\": \"occaecat amet nulla Ut incididunt\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"non officia\",\n            \"paymentType\": \"tempor commodo ea anim\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"Ut consequat labore\"\n          },\n          \"dueAmount\": -48930114.07607291,\n          \"dueDate\": \"incididunt paria\",\n          \"minimumPaymentDue\": 76138712.53701627,\n          \"partialPaymentPaid\": -46971124.51168555\n        },\n        {\n          \"cardName\": \"ad do\",\n          \"cardNumber\": \"nisi qui velit\",\n          \"cardStatus\": \"et in nisi pariatur\",\n          \"cardImage\": \"fugiat Ut in incidid\",\n          \"cardType\": \"consectetur et deserunt sint\",\n          \"expDate\": \"ad\",\n          \"displayCardStatus\": \"Lorem dolor\",\n          \"primaryCard\": \"fugiat incididunt culpa\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"culpa non in\",\n          \"nameOnCard\": \"qui incididunt\",\n          \"cardNetwork\": \"cillum non Duis deserunt dolore\",\n          \"autopay\": {\n            \"enabled\": false,\n            \"sourceAccountId\": \"pariatur magna eiusmod\",\n            \"paymentType\": \"veniam laboris\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"cillum dolore aliqua eu irure\"\n          },\n          \"dueAmount\": 90828816.29557437,\n          \"dueDate\": \"tempor ad nisi mollit\",\n          \"minimumPaymentDue\": 88771200.6536364,\n          \"partialPaymentPaid\": 49524293.295514494\n        }\n      ],\n      \"IsCrossAccount\": false\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accounts` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts`)) {\n                    const value = ld.get(jsonResponse, `accounts`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field accounts:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the accounts field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts`)) {\n                    let accountsArray = ld.get(jsonResponse, `accounts`, []);\n                    if (Array.isArray(accountsArray)) {\n                        for (let accounts_it = 0; accounts_it < accountsArray.length; accounts_it++) {\n                            let iterator = accounts_it;\n                            if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accountsArray' has 'customerId' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].customerId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].customerId:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountName' has 'accountName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountNickname' has 'accountNickname' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountNickname`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountNickname:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountNumber' has 'accountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].accountType' has 'accountType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].accountType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].accountType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].activatedDate' has 'activatedDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].activatedDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].activatedDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCash' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCash`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCash:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCashLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCashLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'availableCredit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].availableCredit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].availableCredit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].bankName' has 'bankName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].bankName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].bankName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].branchName' has 'branchName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].branchName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].branchName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'creditLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].creditLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].creditLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].currency' has 'currency' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].currency`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].currency:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'currentBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].currentBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].currentBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].deactivatedDate' has 'deactivatedDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].deactivatedDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].deactivatedDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'earlyWithdrawalPenalty' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].earlyWithdrawalPenalty`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].earlyWithdrawalPenalty:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].fdType' has 'fdType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].fdType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].fdType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].image' has 'image' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].image`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].image:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'interestRate' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].interestRate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].interestRate:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].internalTransferFromEnabled' has 'internalTransferFromEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].internalTransferFromEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].internalTransferFromEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].internalTransferToEnabled' has 'internalTransferToEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].internalTransferToEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].internalTransferToEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isPrimaryMobile' has 'isPrimaryMobile' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isPrimaryMobile`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isPrimaryMobile:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isAlternateMobileNumber' has 'isAlternateMobileNumber' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isAlternateMobileNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].isStatement' has 'isStatement' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].isStatement`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].isStatement:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].lastDrawDate' has 'lastDrawDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].lastDrawDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].lastDrawDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].loanMaturityDate' has 'loanMaturityDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].loanMaturityDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].loanMaturityDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].loanOriginationDate' has 'loanOriginationDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].loanOriginationDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].loanOriginationDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].location' has 'location' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].location`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].location:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].lastUpdated' has 'lastUpdated' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].lastUpdated`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].lastUpdated:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].maxTransactionLimit' has 'maxTransactionLimit' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].maxTransactionLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].maxTransactionLimit:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].maturityDate' has 'maturityDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].maturityDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].maturityDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].minimumPaymentDue' has 'minimumPaymentDue' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].minimumBalance' has 'minimumBalance' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].minimumBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].minimumBalance:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'monthlyPayment' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].monthlyPayment`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].monthlyPayment:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'openingBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].openingBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].openingBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'originalLoanAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].originalLoanAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].originalLoanAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'P2PLimit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].P2PLimit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].P2PLimit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'p2pEnabled' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].p2pEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].p2pEnabled:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].paybillEnabled' has 'paybillEnabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].paybillEnabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].paybillEnabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'payoffAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].payoffAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].payoffAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerName' has 'personalBankerName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact' has 'personalBankerContact' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].personalBankerContact:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact.email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact.email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerContact.email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].personalBankerContact.mobileNumber' has 'mobileNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].personalBankerContact.mobileNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].personalBankerContact.mobileNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'phone' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].phone`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].phone:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'postedBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].postedBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].postedBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].principalBalance' has 'principalBalance' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].principalBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].principalBalance:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].productCode' has 'productCode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].productCode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].productCode:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].productName' has 'productName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].productName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].productName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].propertyAddress' has 'propertyAddress' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].propertyAddress`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].propertyAddress:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].rewardPoints' has 'rewardPoints' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].rewardPoints`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].rewardPoints:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].routingNumber' has 'routingNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].routingNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].routingNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].statementDate' has 'statementDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].statementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].statementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].status' has 'status' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].status`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].status:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].swiftCode' has 'swiftCode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].swiftCode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].swiftCode:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'totalBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].totalBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].totalBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'unbilledAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].unbilledAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].unbilledAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'valueAtMaturity' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].valueAtMaturity`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].valueAtMaturity:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'holdAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].holdAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].holdAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'unclearFundsAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].unclearFundsAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].unclearFundsAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'averageMonthlyBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].averageMonthlyBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].averageMonthlyBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'netWithdrawableBalance' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].netWithdrawableBalance`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].netWithdrawableBalance:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].totalTenure' has 'totalTenure' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].totalTenure`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].totalTenure:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].remainingTenure' has 'remainingTenure' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].remainingTenure`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].remainingTenure:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].debitAccountNumber' has 'debitAccountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].debitAccountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].debitAccountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'lateFee' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].lateFee`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].lateFee:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'bounceCharge' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].bounceCharge`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].bounceCharge:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'totalCharges' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].totalCharges`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].totalCharges:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'overDueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].overDueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].overDueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accountsArray' has 'cardDetails' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails`)) {\n                    let cardDetailsArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails`, []);\n                    if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                            let iterator = cardDetails_it;\n                            if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage' has 'cardImage' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardImage:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus' has 'displayCardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].displayCardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard' has 'primaryCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].primaryCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo' has 'cardChannelInfo' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM' has 'ATM' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline' has 'offline' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international' has 'international' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.international.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online' has 'online' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.online.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless' has 'contactless' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions' has 'cardRestrictions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'countries' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`)) {\n                    let countriesArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries`, []);\n                    if (Array.isArray(countriesArray)) {\n                        for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                            let iterator = countries_it;\n                            if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode' has 'countrycode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'MCC' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`)) {\n                    let MCCArray = ld.get(jsonResponse, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC`, []);\n                    if (Array.isArray(MCCArray)) {\n                        for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                            let iterator = MCC_it;\n                            if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason' has 'blockReason' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].blockReason:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard' has 'nameOnCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].nameOnCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork' has 'cardNetwork' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].cardNetwork:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay' has 'autopay' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled' has 'enabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.enabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId' has 'sourceAccountId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.sourceAccountId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType' has 'paymentType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.paymentType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate' has 'onStatementDate' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.onStatementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth' has 'dayOfMonth' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].autopay.dayOfMonth:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'minimumPaymentDue' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'partialPaymentPaid' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `accounts[${accounts_it}].cardDetails[${cardDetails_it}].partialPaymentPaid`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for accounts[${accounts_it}].cardDetails[${cardDetails_it}].partialPaymentPaid:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts[${accounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'accounts[${accounts_it}].IsCrossAccount' has 'IsCrossAccount' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `accounts[${accounts_it}].IsCrossAccount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for accounts[${accounts_it}].IsCrossAccount:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for accounts:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the details of the mentioned customer account",
      "request": {
        "name": "to get the details of the mentioned customer account",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountDetails"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*string}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*string}}\"\n        }\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": -22463228.24743183,\n    \"accountName\": \"Lorem laboris consequat\",\n    \"accountNickname\": \"ut amet\",\n    \"accountNumber\": \"magna sunt ut exercitation\",\n    \"accountType\": \"proident\",\n    \"activatedDate\": \"nulla in\",\n    \"availableBalance\": 79190942.94399941,\n    \"availableCash\": -44297870.89184351,\n    \"availableCashLimit\": 39167002.939923465,\n    \"availableCredit\": -37753836.807046734,\n    \"bankName\": \"in Excepte\",\n    \"branchName\": \"culpa sint\",\n    \"cardName\": \"veniam in qui\",\n    \"cardNumber\": \"sint Duis deserunt\",\n    \"cardStatus\": \"tempor ea\",\n    \"cardType\": \"id culpa\",\n    \"creditLimit\": -84654085.39163879,\n    \"currency\": \"qui fugiat eiusmod voluptate\",\n    \"currentBalance\": -10660696.732717142,\n    \"deactivatedDate\": \"nulla ex laborum mollit\",\n    \"dueAmount\": 50231958.25687185,\n    \"dueDate\": \"non occaecat in deserunt\",\n    \"earlyWithdrawalPenalty\": 77419205.27235848,\n    \"email\": \"ut dolore nisi dolore\",\n    \"expDate\": \"\",\n    \"fdType\": \"officia in reprehenderit mollit\",\n    \"image\": \"consequat elit fugiat\",\n    \"interestRate\": 2212985.939811945,\n    \"internalTransferFromEnabled\": false,\n    \"internalTransferToEnabled\": true,\n    \"isPrimaryMobile\": true,\n    \"isAlternateMobileNumber\": true,\n    \"isStatement\": false,\n    \"lastDrawDate\": \"dolor ex\",\n    \"loanMaturityDate\": \"voluptate quis sint\",\n    \"loanOriginationDate\": \"labore n\",\n    \"location\": \"veniam\",\n    \"lastUpdated\": \"in et Duis dolor\",\n    \"maxTransactionLimit\": \"aute eu ad ut\",\n    \"maturityDate\": \"irure labore dolore tempor aliqua\",\n    \"minimumPaymentDue\": \"et\",\n    \"minimumBalance\": \"dolore aliquip Lorem exercitation\",\n    \"monthlyPayment\": 79677368.27329504,\n    \"openingBalance\": -48271311.74292138,\n    \"originalLoanAmount\": -35762241.994152784,\n    \"P2PLimit\": 39994873.71967167,\n    \"p2pEnabled\": -13727981.478307694,\n    \"paybillEnabled\": false,\n    \"payoffAmount\": 1866599.122015655,\n    \"personalBankerName\": \"aliqua nisi esse consequat\",\n    \"personalBankerContact\": {\n      \"email\": \"ad ut in velit\",\n      \"mobileNumber\": \"pariatur in proident\"\n    },\n    \"phone\": 68315.24664656818,\n    \"postedBalance\": -82509520.6969725,\n    \"principalBalance\": \"culpa pariatur\",\n    \"productCode\": \"dolor aliquip incididunt\",\n    \"productName\": \"et anim dolor cupidatat Lorem\",\n    \"propertyAddress\": \"sed amet\",\n    \"rewardPoints\": \"exercitation magna\",\n    \"routingNumber\": \"in nostrud labore ut\",\n    \"statementDate\": \"laboris ipsum\",\n    \"status\": \"non do in sit lab\",\n    \"swiftCode\": \"ea est aliqua mollit\",\n    \"totalBalance\": 61187505.93084529,\n    \"unbilledAmount\": -82415233.77159159,\n    \"valueAtMaturity\": -41165827.69164285,\n    \"holdAmount\": 57825573.13376877,\n    \"unclearFundsAmount\": -62835136.78972854,\n    \"averageMonthlyBalance\": -53011253.98298892,\n    \"netWithdrawableBalance\": -54607072.22881349,\n    \"totalTenure\": \"quis\",\n    \"remainingTenure\": \"dolor cillum\",\n    \"debitAccountNumber\": \"sed sunt enim\",\n    \"lateFee\": -19211162.48529309,\n    \"bounceCharge\": -92649083.80221133,\n    \"totalCharges\": -65144708.67918036,\n    \"overDueAmount\": 92609632.80383235,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"labore pariatur\",\n        \"cardNumber\": \"commodo\",\n        \"cardStatus\": \"quis deserunt\",\n        \"cardImage\": \"amet nisi\",\n        \"cardType\": \"eiusmod sint\",\n        \"expDate\": \"officia elit amet\",\n        \"displayCardStatus\": \"officia cupidatat\",\n        \"primaryCard\": \"Duis\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"nisi dolor\",\n        \"nameOnCard\": \"do\",\n        \"cardNetwork\": \"amet\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"officia\",\n          \"paymentType\": \"sunt cil\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"eu\"\n        },\n        \"dueAmount\": -545462.9905565828,\n        \"dueDate\": \"dolore eiusmod ipsum laboris\",\n        \"minimumPaymentDue\": 57287367.18882471,\n        \"partialPaymentPaid\": -81904040.0537848\n      },\n      {\n        \"cardName\": \"occaecat\",\n        \"cardNumber\": \"reprehenderit cupidatat\",\n        \"cardStatus\": \"labore ex \",\n        \"cardImage\": \"sit nostrud\",\n        \"cardType\": \"dolore adipisicing Ut\",\n        \"expDate\": \"incididunt in fugiat ad\",\n        \"displayCardStatus\": \"et Lorem quis\",\n        \"primaryCard\": \"do aliquip ipsum elit in\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"culpa veniam\",\n        \"nameOnCard\": \"ut do aute\",\n        \"cardNetwork\": \"cillum nulla fugiat\",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"veniam labore\",\n          \"paymentType\": \"minim ad aliqua\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"cillum consequat cupidatat\"\n        },\n        \"dueAmount\": 34744518.47992629,\n        \"dueDate\": \"ullamco e\",\n        \"minimumPaymentDue\": -94643246.16827895,\n        \"partialPaymentPaid\": -63705277.33745357\n      }\n    ],\n    \"IsCrossAccount\": true\n  },\n  {\n    \"customerId\": -44904962.595368624,\n    \"accountName\": \"nisi sed reprehenderit\",\n    \"accountNickname\": \"mollit \",\n    \"accountNumber\": \"pariatur nostrud\",\n    \"accountType\": \"proident nulla magna fugiat \",\n    \"activatedDate\": \"nisi\",\n    \"availableBalance\": 21641194.384162337,\n    \"availableCash\": -31936181.919538558,\n    \"availableCashLimit\": 21116564.89852245,\n    \"availableCredit\": -47879569.23364391,\n    \"bankName\": \"Ut eu Lorem\",\n    \"branchName\": \"cupidatat ipsum\",\n    \"cardName\": \"minim commodo laboris\",\n    \"cardNumber\": \"amet culpa\",\n    \"cardStatus\": \"proident sunt magna incididunt\",\n    \"cardType\": \"in labore\",\n    \"creditLimit\": -5124823.956891507,\n    \"currency\": \"non irure incididunt\",\n    \"currentBalance\": 56242227.583034545,\n    \"deactivatedDate\": \"ullamco in\",\n    \"dueAmount\": -4376147.441727161,\n    \"dueDate\": \"adipisicing aute laboris incididunt sunt\",\n    \"earlyWithdrawalPenalty\": -47136983.42745243,\n    \"email\": \"sit velit ex\",\n    \"expDate\": \"non eu\",\n    \"fdType\": \"sunt sint est ut et\",\n    \"image\": \"eu reprehenderit\",\n    \"interestRate\": 77267251.52721748,\n    \"internalTransferFromEnabled\": true,\n    \"internalTransferToEnabled\": true,\n    \"isPrimaryMobile\": false,\n    \"isAlternateMobileNumber\": true,\n    \"isStatement\": true,\n    \"lastDrawDate\": \"elit officia\",\n    \"loanMaturityDate\": \"aute ea ipsum cillum\",\n    \"loanOriginationDate\": \"Duis minim\",\n    \"location\": \"consectetur ut laboris\",\n    \"lastUpdated\": \"aute nisi\",\n    \"maxTransactionLimit\": \"laborum irure in\",\n    \"maturityDate\": \"dolore minim anim\",\n    \"minimumPaymentDue\": \"sunt\",\n    \"minimumBalance\": \"aute in ex reprehenderit\",\n    \"monthlyPayment\": -81292715.1835651,\n    \"openingBalance\": 91322970.91121683,\n    \"originalLoanAmount\": -51039333.34725461,\n    \"P2PLimit\": 42523786.79890287,\n    \"p2pEnabled\": -32433329.82156217,\n    \"paybillEnabled\": true,\n    \"payoffAmount\": 29246278.497212067,\n    \"personalBankerName\": \"amet culpa ad ex\",\n    \"personalBankerContact\": {\n      \"email\": \"Duis mollit\",\n      \"mobileNumber\": \"in\"\n    },\n    \"phone\": 88711630.75413027,\n    \"postedBalance\": 71324805.68041158,\n    \"principalBalance\": \"minim reprehende\",\n    \"productCode\": \"laborum quis\",\n    \"productName\": \"labore exercitation\",\n    \"propertyAddress\": \"occaecat ut deserunt eu\",\n    \"rewardPoints\": \"cupidatat adipisicing\",\n    \"routingNumber\": \"sunt sint irure ut\",\n    \"statementDate\": \"in laboris qui\",\n    \"status\": \"magna velit\",\n    \"swiftCode\": \"nostrud aute\",\n    \"totalBalance\": 42856806.431034744,\n    \"unbilledAmount\": 38763965.429689705,\n    \"valueAtMaturity\": 5844247.141948596,\n    \"holdAmount\": -8262662.102898404,\n    \"unclearFundsAmount\": 2586447.5319012105,\n    \"averageMonthlyBalance\": -32841416.390235484,\n    \"netWithdrawableBalance\": 36998836.99418479,\n    \"totalTenure\": \"tempor in\",\n    \"remainingTenure\": \"adipisicing deserunt Lorem voluptate ut\",\n    \"debitAccountNumber\": \"ea do esse ullamco\",\n    \"lateFee\": 73736839.99834967,\n    \"bounceCharge\": -34274685.135513216,\n    \"totalCharges\": -48423046.242560595,\n    \"overDueAmount\": -44314594.34139495,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"laborum ut\",\n        \"cardNumber\": \"anim tempor\",\n        \"cardStatus\": \"nisi in minim cupidatat dolore\",\n        \"cardImage\": \"sed dolore exercitation eu\",\n        \"cardType\": \"quis ut non\",\n        \"expDate\": \"exercitation irure ex\",\n        \"displayCardStatus\": \"eiusmod adipisicing reprehenderit tempor veniam\",\n        \"primaryCard\": \"eiusmod in qui\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"eiusmod ut consectetur\",\n        \"nameOnCard\": \"et sit sed\",\n        \"cardNetwork\": \"ex et officia\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"consequat esse\",\n          \"paymentType\": \"Lorem velit dolor\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"labore\"\n        },\n        \"dueAmount\": -38738156.64920781,\n        \"dueDate\": \"sed Ut nisi eiusmod\",\n        \"minimumPaymentDue\": -26720427.44335994,\n        \"partialPaymentPaid\": -64506479.91804175\n      },\n      {\n        \"cardName\": \"quis incididunt anim Excepteur\",\n        \"cardNumber\": \"pariatur cupidatat laboris Lorem\",\n        \"cardStatus\": \"commodo quis dolor occaecat\",\n        \"cardImage\": \"ad culpa eiusmod aute sunt\",\n        \"cardType\": \"dolor\",\n        \"expDate\": \"nulla dolore in veniam\",\n        \"displayCardStatus\": \"non laboris ea\",\n        \"primaryCard\": \"et sunt\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"dolore in cupidatat tempor\",\n        \"nameOnCard\": \"fugiat elit adipisicing\",\n        \"cardNetwork\": \"do\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"ut Duis et ex in\",\n          \"paymentType\": \"fugiat adipisicing deserunt magna\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"minim ipsum Lorem\"\n        },\n        \"dueAmount\": -10494075.640847236,\n        \"dueDate\": \"cupidatat voluptate Duis\",\n        \"minimumPaymentDue\": -24251313.132340387,\n        \"partialPaymentPaid\": -53903131.50257882\n      }\n    ],\n    \"IsCrossAccount\": false\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountDetails for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountName`)) {\n                    const value = ld.get(jsonResponse, `accountName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNickname` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNickname`)) {\n                    const value = ld.get(jsonResponse, `accountNickname`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNickname:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountType`)) {\n                    const value = ld.get(jsonResponse, `accountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `activatedDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`activatedDate`)) {\n                    const value = ld.get(jsonResponse, `activatedDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field activatedDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableBalance`)) {\n                    const value = ld.get(responseData, `availableBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCash` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCash`)) {\n                    const value = ld.get(responseData, `availableCash`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCash:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCashLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCashLimit`)) {\n                    const value = ld.get(responseData, `availableCashLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCredit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCredit`)) {\n                    const value = ld.get(responseData, `availableCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `bankName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`bankName`)) {\n                    const value = ld.get(jsonResponse, `bankName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field bankName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `branchName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`branchName`)) {\n                    const value = ld.get(jsonResponse, `branchName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field branchName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardName`)) {\n                    const value = ld.get(jsonResponse, `cardName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardStatus` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardStatus`)) {\n                    const value = ld.get(jsonResponse, `cardStatus`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardStatus:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardType`)) {\n                    const value = ld.get(jsonResponse, `cardType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `creditLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`creditLimit`)) {\n                    const value = ld.get(responseData, `creditLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field creditLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currentBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`currentBalance`)) {\n                    const value = ld.get(responseData, `currentBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field currentBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `deactivatedDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`deactivatedDate`)) {\n                    const value = ld.get(jsonResponse, `deactivatedDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field deactivatedDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `dueAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`dueAmount`)) {\n                    const value = ld.get(responseData, `dueAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field dueAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `dueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`dueDate`)) {\n                    const value = ld.get(jsonResponse, `dueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field dueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `earlyWithdrawalPenalty` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`earlyWithdrawalPenalty`)) {\n                    const value = ld.get(responseData, `earlyWithdrawalPenalty`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field earlyWithdrawalPenalty:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `expDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`expDate`)) {\n                    const value = ld.get(jsonResponse, `expDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field expDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `fdType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`fdType`)) {\n                    const value = ld.get(jsonResponse, `fdType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field fdType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `interestRate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`interestRate`)) {\n                    const value = ld.get(responseData, `interestRate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field interestRate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `internalTransferFromEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`internalTransferFromEnabled`)) {\n                    const value = ld.get(jsonResponse, `internalTransferFromEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field internalTransferFromEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `internalTransferToEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`internalTransferToEnabled`)) {\n                    const value = ld.get(jsonResponse, `internalTransferToEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field internalTransferToEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobile` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobile`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobile`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobile:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isStatement` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isStatement`)) {\n                    const value = ld.get(jsonResponse, `isStatement`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isStatement:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastDrawDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastDrawDate`)) {\n                    const value = ld.get(jsonResponse, `lastDrawDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastDrawDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `loanMaturityDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`loanMaturityDate`)) {\n                    const value = ld.get(jsonResponse, `loanMaturityDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field loanMaturityDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `loanOriginationDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`loanOriginationDate`)) {\n                    const value = ld.get(jsonResponse, `loanOriginationDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field loanOriginationDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastUpdated` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastUpdated`)) {\n                    const value = ld.get(jsonResponse, `lastUpdated`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastUpdated:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `maxTransactionLimit` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`maxTransactionLimit`)) {\n                    const value = ld.get(jsonResponse, `maxTransactionLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field maxTransactionLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `maturityDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`maturityDate`)) {\n                    const value = ld.get(jsonResponse, `maturityDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field maturityDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `minimumPaymentDue` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`minimumPaymentDue`)) {\n                    const value = ld.get(jsonResponse, `minimumPaymentDue`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `minimumBalance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`minimumBalance`)) {\n                    const value = ld.get(jsonResponse, `minimumBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field minimumBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `monthlyPayment` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`monthlyPayment`)) {\n                    const value = ld.get(responseData, `monthlyPayment`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field monthlyPayment:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `openingBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`openingBalance`)) {\n                    const value = ld.get(responseData, `openingBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field openingBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `originalLoanAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`originalLoanAmount`)) {\n                    const value = ld.get(responseData, `originalLoanAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field originalLoanAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `P2PLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`P2PLimit`)) {\n                    const value = ld.get(responseData, `P2PLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field P2PLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `p2pEnabled` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`p2pEnabled`)) {\n                    const value = ld.get(responseData, `p2pEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field p2pEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `paybillEnabled` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`paybillEnabled`)) {\n                    const value = ld.get(jsonResponse, `paybillEnabled`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field paybillEnabled:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `payoffAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`payoffAmount`)) {\n                    const value = ld.get(responseData, `payoffAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field payoffAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerName`)) {\n                    const value = ld.get(jsonResponse, `personalBankerName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBankerContact:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact.email`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerContact.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBankerContact.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBankerContact.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBankerContact.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBankerContact.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `postedBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`postedBalance`)) {\n                    const value = ld.get(responseData, `postedBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field postedBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `principalBalance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`principalBalance`)) {\n                    const value = ld.get(jsonResponse, `principalBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field principalBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `productCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`productCode`)) {\n                    const value = ld.get(jsonResponse, `productCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field productCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `productName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`productName`)) {\n                    const value = ld.get(jsonResponse, `productName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field productName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `propertyAddress` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`propertyAddress`)) {\n                    const value = ld.get(jsonResponse, `propertyAddress`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field propertyAddress:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `rewardPoints` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`rewardPoints`)) {\n                    const value = ld.get(jsonResponse, `rewardPoints`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field rewardPoints:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `routingNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`routingNumber`)) {\n                    const value = ld.get(jsonResponse, `routingNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field routingNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `statementDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`statementDate`)) {\n                    const value = ld.get(jsonResponse, `statementDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field statementDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `swiftCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`swiftCode`)) {\n                    const value = ld.get(jsonResponse, `swiftCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field swiftCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`totalBalance`)) {\n                    const value = ld.get(responseData, `totalBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field totalBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `unbilledAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`unbilledAmount`)) {\n                    const value = ld.get(responseData, `unbilledAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field unbilledAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `valueAtMaturity` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`valueAtMaturity`)) {\n                    const value = ld.get(responseData, `valueAtMaturity`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field valueAtMaturity:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `holdAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`holdAmount`)) {\n                    const value = ld.get(responseData, `holdAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field holdAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `unclearFundsAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`unclearFundsAmount`)) {\n                    const value = ld.get(responseData, `unclearFundsAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field unclearFundsAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `averageMonthlyBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`averageMonthlyBalance`)) {\n                    const value = ld.get(responseData, `averageMonthlyBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field averageMonthlyBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `netWithdrawableBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`netWithdrawableBalance`)) {\n                    const value = ld.get(responseData, `netWithdrawableBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field netWithdrawableBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalTenure` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`totalTenure`)) {\n                    const value = ld.get(jsonResponse, `totalTenure`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field totalTenure:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `remainingTenure` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`remainingTenure`)) {\n                    const value = ld.get(jsonResponse, `remainingTenure`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field remainingTenure:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `debitAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`debitAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `debitAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field debitAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lateFee` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`lateFee`)) {\n                    const value = ld.get(responseData, `lateFee`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field lateFee:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `bounceCharge` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`bounceCharge`)) {\n                    const value = ld.get(responseData, `bounceCharge`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field bounceCharge:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `totalCharges` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`totalCharges`)) {\n                    const value = ld.get(responseData, `totalCharges`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field totalCharges:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `overDueAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`overDueAmount`)) {\n                    const value = ld.get(responseData, `overDueAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field overDueAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    const value = ld.get(jsonResponse, `cardDetails`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field cardDetails:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the cardDetails field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    let cardDetailsArray = ld.get(jsonResponse, `cardDetails`, []);\n                    if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                            let iterator = cardDetails_it;\n                            if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardName' has 'cardName' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardName`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardName:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardStatus' has 'cardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardImage' has 'cardImage' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardImage`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardImage:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardType' has 'cardType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].expDate' has 'expDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].expDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].expDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].displayCardStatus' has 'displayCardStatus' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].displayCardStatus`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].displayCardStatus:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].primaryCard' has 'primaryCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].primaryCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].primaryCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo' has 'cardChannelInfo' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.ATM' has 'ATM' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.ATM`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.ATM.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.offline' has 'offline' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.offline`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.offline:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.offline.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.offline.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.international' has 'international' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.international`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.international:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.international.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.international.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.international.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.international.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.international.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.online' has 'online' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.online`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.online:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.online.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.online.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.online.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.online.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.online.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.contactless' has 'contactless' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.contactless`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable' has 'enable' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless.enable:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'limit' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].cardChannelInfo.contactless.limit:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions' has 'cardRestrictions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].cardRestrictions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'countries' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.countries`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the cardDetails[${cardDetails_it}].cardRestrictions.countries field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails[${cardDetails_it}].cardRestrictions.countries`)) {\n                    let countriesArray = ld.get(jsonResponse, `cardDetails[${cardDetails_it}].cardRestrictions.countries`, []);\n                    if (Array.isArray(countriesArray)) {\n                        for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                            let iterator = countries_it;\n                            if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode' has 'countrycode' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.countries[${countries_it}].countrycode:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails[${cardDetails_it}].cardRestrictions.countries:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'MCC' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n\n        pm.test(`Each object in the cardDetails[${cardDetails_it}].cardRestrictions.MCC field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails[${cardDetails_it}].cardRestrictions.MCC`)) {\n                    let MCCArray = ld.get(jsonResponse, `cardDetails[${cardDetails_it}].cardRestrictions.MCC`, []);\n                    if (Array.isArray(MCCArray)) {\n                        for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                            let iterator = MCC_it;\n                            if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardRestrictions.MCC[${MCC_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails[${cardDetails_it}].cardRestrictions.MCC:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].blockReason' has 'blockReason' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].blockReason`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].blockReason:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].nameOnCard' has 'nameOnCard' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].nameOnCard`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].nameOnCard:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].cardNetwork' has 'cardNetwork' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].cardNetwork`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].cardNetwork:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay' has 'autopay' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for cardDetails[${cardDetails_it}].autopay:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.enabled' has 'enabled' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.enabled`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].autopay.enabled:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.sourceAccountId' has 'sourceAccountId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.sourceAccountId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.sourceAccountId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.paymentType' has 'paymentType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.paymentType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.paymentType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.onStatementDate' has 'onStatementDate' as 'boolean'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.onStatementDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean type for cardDetails[${cardDetails_it}].autopay.onStatementDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].autopay.dayOfMonth' has 'dayOfMonth' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].autopay.dayOfMonth`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].autopay.dayOfMonth:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'dueAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].dueAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].dueAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetails[${cardDetails_it}].dueDate' has 'dueDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `cardDetails[${cardDetails_it}].dueDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for cardDetails[${cardDetails_it}].dueDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'minimumPaymentDue' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].minimumPaymentDue`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].minimumPaymentDue:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'cardDetailsArray' has 'partialPaymentPaid' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `cardDetails[${cardDetails_it}].partialPaymentPaid`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for cardDetails[${cardDetails_it}].partialPaymentPaid:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for cardDetails:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `IsCrossAccount` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`IsCrossAccount`)) {\n                    const value = ld.get(jsonResponse, `IsCrossAccount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field IsCrossAccount:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountsLimit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"accountName\": \"id eiusmod sint amet\",\n    \"accountNickname\": \"tempor est minim\",\n    \"accountNumber\": \"exercitation commodo veniam\",\n    \"accountType\": \"reprehenderit ullamco non elit\",\n    \"balance\": \"ex occaecat\",\n    \"cardName\": \"sunt exercitation dolore\",\n    \"cardNumber\": \"ut anim pariat\",\n    \"currency\": \"reprehenderit incididunt Ut\",\n    \"customerId\": -84962225.34939948,\n    \"perTxn\": -53172833.78092203,\n    \"status\": \"Excepteur quis Lorem\",\n    \"availableCashLimit\": 31758570.647516042,\n    \"creditLimit\": 39626902.21457824,\n    \"availableCredit\": -17308135.04930824,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 25660452.681962863,\n          \"maximum\": -90952402.3857344,\n          \"spent\": -17463821.69466126\n        },\n        \"daily\": {\n          \"available\": -2366941.486885071,\n          \"maximum\": 61710654.97554916,\n          \"spent\": -23728860.559622467\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": -39993518.49067132,\n          \"maximum\": -65467099.40961262,\n          \"usedup\": 65805096.63576925\n        },\n        \"daily\": {\n          \"available\": -81981174.82224822,\n          \"maximum\": -13852924.237383574,\n          \"usedup\": 44176547.38733035\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 9862566.507023424,\n      \"maximum\": -65274079.7188665,\n      \"usedup\": -10655988.028356418,\n      \"amountperday\": -40324287.97678036\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": -55213797.24204376,\n          \"maximum\": 69277334.68374914,\n          \"spent\": -52097320.977195725\n        },\n        \"daily\": {\n          \"available\": -94865105.88515809,\n          \"maximum\": 21926033.23292248,\n          \"spent\": 49804793.63940504\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 17775050.730106205,\n          \"maximum\": 12848952.154922381,\n          \"usedup\": 56103198.326631576\n        },\n        \"daily\": {\n          \"available\": 38858912.68991196,\n          \"maximum\": -96843944.07292451,\n          \"usedup\": 23494606.95961882\n        }\n      }\n    }\n  },\n  {\n    \"accountName\": \"consectetur labore ex cillum\",\n    \"accountNickname\": \"ipsum qui aliqua\",\n    \"accountNumber\": \"aliqua anim nulla enim Lorem\",\n    \"accountType\": \"nisi do laborum\",\n    \"balance\": \"ipsum sed dolor\",\n    \"cardName\": \"enim sint adipisicing\",\n    \"cardNumber\": \"quis Ut\",\n    \"currency\": \"elit dolore sit reprehenderit\",\n    \"customerId\": -35060790.5747768,\n    \"perTxn\": -98368835.84867655,\n    \"status\": \"do\",\n    \"availableCashLimit\": 68907335.19138107,\n    \"creditLimit\": -24039956.78965889,\n    \"availableCredit\": 23464450.670327783,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": -13166619.204245448,\n          \"maximum\": 27640105.390542,\n          \"spent\": 37028624.130939215\n        },\n        \"daily\": {\n          \"available\": -88594553.42598745,\n          \"maximum\": 35611097.84478927,\n          \"spent\": 3642371.8727676123\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": -18172617.706372485,\n          \"maximum\": -8423700.46617274,\n          \"usedup\": 23868976.92526087\n        },\n        \"daily\": {\n          \"available\": 63560500.1670157,\n          \"maximum\": 46658103.75990361,\n          \"usedup\": 62028208.88844377\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": -65115826.5372191,\n      \"maximum\": 97097567.38897538,\n      \"usedup\": 88822867.01711538,\n      \"amountperday\": -14745666.467812106\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": -85853499.73479298,\n          \"maximum\": 86453898.05189061,\n          \"spent\": 70953462.09972605\n        },\n        \"daily\": {\n          \"available\": 18976511.580248356,\n          \"maximum\": 13858765.397519872,\n          \"spent\": -61369892.68919209\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": -36049124.880806275,\n          \"maximum\": 23989695.805768102,\n          \"usedup\": -15536913.787590742\n        },\n        \"daily\": {\n          \"available\": 83053778.8701474,\n          \"maximum\": 53558491.119295806,\n          \"usedup\": -95222602.73296435\n        }\n      }\n    }\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountsLimit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `accountName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountName`)) {\n                    const value = ld.get(jsonResponse, `accountName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNickname` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNickname`)) {\n                    const value = ld.get(jsonResponse, `accountNickname`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNickname:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountType`)) {\n                    const value = ld.get(jsonResponse, `accountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `balance` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`balance`)) {\n                    const value = ld.get(jsonResponse, `balance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field balance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardName`)) {\n                    const value = ld.get(jsonResponse, `cardName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `perTxn` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`perTxn`)) {\n                    const value = ld.get(responseData, `perTxn`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field perTxn:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCashLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCashLimit`)) {\n                    const value = ld.get(responseData, `availableCashLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCashLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `creditLimit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`creditLimit`)) {\n                    const value = ld.get(responseData, `creditLimit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field creditLimit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `availableCredit` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`availableCredit`)) {\n                    const value = ld.get(responseData, `availableCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field availableCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase`)) {\n                    const value = ld.get(jsonResponse, `purchase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`txnsPerDay`)) {\n                    const value = ld.get(jsonResponse, `txnsPerDay`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field txnsPerDay:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.available` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.available`)) {\n                    const value = ld.get(responseData, `txnsPerDay.available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.maximum` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.maximum`)) {\n                    const value = ld.get(responseData, `txnsPerDay.maximum`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.maximum:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.usedup` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.usedup`)) {\n                    const value = ld.get(responseData, `txnsPerDay.usedup`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.usedup:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.amountperday` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.amountperday`)) {\n                    const value = ld.get(responseData, `txnsPerDay.amountperday`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.amountperday:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal`)) {\n                    const value = ld.get(jsonResponse, `withdrawal`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.daily:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountSpecificLimitsInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 1045300,\n    \"currency\": \"USD\",\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 5,\n      \"maximum\": 8,\n      \"usedup\": 3,\n      \"amount\": 500\n    },\n    \"perTxn\": 500\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountSpecificLimitsInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `perTxn` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`perTxn`)) {\n                    const value = ld.get(responseData, `perTxn`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field perTxn:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase`)) {\n                    const value = ld.get(jsonResponse, `purchase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `purchase.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`purchase.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `purchase.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field purchase.transactions.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`txnsPerDay`)) {\n                    const value = ld.get(jsonResponse, `txnsPerDay`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field txnsPerDay:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.available` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.available`)) {\n                    const value = ld.get(responseData, `txnsPerDay.available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.maximum` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.maximum`)) {\n                    const value = ld.get(responseData, `txnsPerDay.maximum`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.maximum:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.usedup` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.usedup`)) {\n                    const value = ld.get(responseData, `txnsPerDay.usedup`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.usedup:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `txnsPerDay.amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`txnsPerDay.amount`)) {\n                    const value = ld.get(responseData, `txnsPerDay.amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field txnsPerDay.amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal`)) {\n                    const value = ld.get(jsonResponse, `withdrawal`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.limits.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.limits.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.limits.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.limits.daily:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.monthly` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.monthly`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.monthly`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.monthly:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `withdrawal.transactions.daily` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`withdrawal.transactions.daily`)) {\n                    const value = ld.get(jsonResponse, `withdrawal.transactions.daily`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field withdrawal.transactions.daily:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateAccountInfo",
      "request": {
        "name": "UpdateAccountInfo",
        "description": {
          "content": "Update customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateAccountInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCustomerInfo",
      "request": {
        "name": "GetCustomerInfo",
        "description": {
          "content": "fetch customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"alternatePhoneNumber\": 18625195.760021463,\n  \"customerId\": \"sunt\",\n  \"email\": \"aute aliqua nulla\",\n  \"identificationNumber\": -29327557.47623959,\n  \"identificationType\": \"nostrud cupidatat culpa\",\n  \"image\": \"amet elit\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": false,\n  \"location\": \"et anim deserunt aliquip ut\",\n  \"name\": \"qui la\",\n  \"firstName\": \"est tem\",\n  \"lastName\": \"enim laboris exercitation dolore cillum\",\n  \"personalBanker\": {\n    \"name\": \"laboris id est\",\n    \"email\": \"ad cillum dolore exercitation et\",\n    \"mobileNumber\": \"enim incididunt eu\"\n  },\n  \"phone\": 30911324.92988722,\n  \"securityQuestions\": [\n    \"irure nulla amet nisi\",\n    \"id fugiat deserunt\"\n  ],\n  \"segmentId\": -17136957.480634958\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCustomerInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `alternatePhoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`alternatePhoneNumber`)) {\n                    const value = ld.get(responseData, `alternatePhoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(jsonResponse, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`identificationNumber`)) {\n                    const value = ld.get(responseData, `identificationNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field identificationNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationType`)) {\n                    const value = ld.get(jsonResponse, `identificationType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `firstName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`firstName`)) {\n                    const value = ld.get(jsonResponse, `firstName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field firstName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `lastName` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`lastName`)) {\n                    const value = ld.get(jsonResponse, `lastName`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field lastName:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker`)) {\n                    const value = ld.get(jsonResponse, `personalBanker`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBanker:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.name`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.email`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `securityQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`securityQuestions`)) {\n                    const value = ld.get(jsonResponse, `securityQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field securityQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `segmentId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`segmentId`)) {\n                    const value = ld.get(responseData, `segmentId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field segmentId:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateCustomerInfo",
      "request": {
        "name": "UpdateCustomerInfo",
        "description": {
          "content": "Update customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateCustomerInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetTransactions",
      "request": {
        "name": "GetTransactions",
        "description": {
          "content": "Fetch transactions information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetTransactions"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetTransactions"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": -8284097.772023901,\n    \"transactionId\": 46286263.60074213,\n    \"accountNumber\": \"in enim\",\n    \"timestamp\": -64205236.33844919,\n    \"amount\": -11459738.4955661,\n    \"currency\": \"laboris non laborum mollit sunt\",\n    \"debitOrCredit\": \"ex dolore\",\n    \"description\": \"mollit ex id\",\n    \"paymentMode\": \"qui est\",\n    \"DBANames\": \"cillum\",\n    \"status\": \"cillum\",\n    \"closingBalance\": 58237375.670393944,\n    \"transacitonType\": \"sunt laboris eiusmod\",\n    \"ACHCode\": \"id aute est consequat\",\n    \"MCCCode\": \"consectetur pariatur\",\n    \"SICCode\": \"commodo minim\",\n    \"name\": \"magna elit esse dolore sint\",\n    \"address\": \"ullamco nostrud\",\n    \"street\": \"cupidatat Lorem eiusmod qui\",\n    \"city\": \"occaecat minim sed\",\n    \"state\": \"nostrud exercitation anim pariatur\",\n    \"zip\": \"sit magna\",\n    \"country\": \"consectetur culpa\",\n    \"phoneNumber\": -36464486.50903334,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  },\n  {\n    \"customerId\": -22917659.621163726,\n    \"transactionId\": 95844548.67314142,\n    \"accountNumber\": \"laborum eiusmod deserunt consectetur adipisicing\",\n    \"timestamp\": 52101858.492340416,\n    \"amount\": 81129807.41432604,\n    \"currency\": \"Lorem nulla\",\n    \"debitOrCredit\": \"incididunt nostrud dolor voluptate\",\n    \"description\": \"incididunt\",\n    \"paymentMode\": \"ullamco i\",\n    \"DBANames\": \"cillum id fugiat cons\",\n    \"status\": \"in eu\",\n    \"closingBalance\": 74370397.6781449,\n    \"transacitonType\": \"culpa nostrud\",\n    \"ACHCode\": \"est aute\",\n    \"MCCCode\": \"reprehenderit pariatur labore amet laborum\",\n    \"SICCode\": \"est amet labore dolore\",\n    \"name\": \"elit sed reprehenderit Ut\",\n    \"address\": \"et consequat eu\",\n    \"street\": \"ea in\",\n    \"city\": \"aliqua magna\",\n    \"state\": \"aute proident adipisicing\",\n    \"zip\": \"nulla\",\n    \"country\": \"est reprehenderit dolor sed\",\n    \"phoneNumber\": -63101527.17572417,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetTransactions for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(responseData, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `transactionId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`transactionId`)) {\n                    const value = ld.get(responseData, `transactionId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field transactionId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `timestamp` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`timestamp`)) {\n                    const value = ld.get(responseData, `timestamp`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field timestamp:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`amount`)) {\n                    const value = ld.get(responseData, `amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`currency`)) {\n                    const value = ld.get(jsonResponse, `currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `debitOrCredit` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`debitOrCredit`)) {\n                    const value = ld.get(jsonResponse, `debitOrCredit`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field debitOrCredit:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `description` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`description`)) {\n                    const value = ld.get(jsonResponse, `description`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field description:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `paymentMode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`paymentMode`)) {\n                    const value = ld.get(jsonResponse, `paymentMode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field paymentMode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DBANames` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DBANames`)) {\n                    const value = ld.get(jsonResponse, `DBANames`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DBANames:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`status`)) {\n                    const value = ld.get(jsonResponse, `status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `closingBalance` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`closingBalance`)) {\n                    const value = ld.get(responseData, `closingBalance`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field closingBalance:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `transacitonType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`transacitonType`)) {\n                    const value = ld.get(jsonResponse, `transacitonType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field transacitonType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ACHCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`ACHCode`)) {\n                    const value = ld.get(jsonResponse, `ACHCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field ACHCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `MCCCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`MCCCode`)) {\n                    const value = ld.get(jsonResponse, `MCCCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field MCCCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SICCode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SICCode`)) {\n                    const value = ld.get(jsonResponse, `SICCode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SICCode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `address` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`address`)) {\n                    const value = ld.get(jsonResponse, `address`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field address:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `street` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`street`)) {\n                    const value = ld.get(jsonResponse, `street`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field street:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `city` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`city`)) {\n                    const value = ld.get(jsonResponse, `city`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field city:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `state` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`state`)) {\n                    const value = ld.get(jsonResponse, `state`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field state:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `zip` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`zip`)) {\n                    const value = ld.get(jsonResponse, `zip`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field zip:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`country`)) {\n                    const value = ld.get(jsonResponse, `country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phoneNumber`)) {\n                    const value = ld.get(responseData, `phoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metaInfo` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metaInfo`)) {\n                    const value = ld.get(jsonResponse, `metaInfo`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field metaInfo:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the metaInfo field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metaInfo`)) {\n                    let metaInfoArray = ld.get(jsonResponse, `metaInfo`, []);\n                    if (Array.isArray(metaInfoArray)) {\n                        for (let metaInfo_it = 0; metaInfo_it < metaInfoArray.length; metaInfo_it++) {\n                            let iterator = metaInfo_it;\n                            if (metaInfoArray[metaInfo_it] !== null && metaInfoArray[metaInfo_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'metaInfo[${metaInfo_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `metaInfo[${metaInfo_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for metaInfo[${metaInfo_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'metaInfo[${metaInfo_it}].value' has 'value' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `metaInfo[${metaInfo_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for metaInfo[${metaInfo_it}].value:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for metaInfo:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "TransferFunds",
      "request": {
        "name": "TransferFunds",
        "description": {
          "content": "Transfers funds between accounts",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "TransferFunds"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*string}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Transaction success",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for TransferFunds for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Transaction success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetScheduleTransfers",
      "request": {
        "name": "GetScheduleTransfers",
        "description": {
          "content": "Fetches the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"adipisicing\",\n    \"CustomerId\": -41903605.82695116,\n    \"Amount\": 12499074.086952612,\n    \"SourceAccountNumber\": \"aliqua incididunt adipisicing eiusmod\",\n    \"TargetAccountNumber\": \"ullamco\",\n    \"DueDate\": \"adipisicing ali\",\n    \"InvoiceNumber\": 91858440.1687907,\n    \"Currency\": \"amet ipsum ex\",\n    \"Status\": \"quis\",\n    \"ScheduledDate\": -389506.1968367249,\n    \"NextScheduleDate\": -43855157.62123129,\n    \"id\": \"sint in U\"\n  },\n  {\n    \"Type\": \"non\",\n    \"CustomerId\": 12123337.32868971,\n    \"Amount\": -33422567.989239216,\n    \"SourceAccountNumber\": \"dolore voluptate deserunt eiusmod\",\n    \"TargetAccountNumber\": \"proident sed\",\n    \"DueDate\": \"labore\",\n    \"InvoiceNumber\": 30168318.077296257,\n    \"Currency\": \"mollit ex veniam velit\",\n    \"Status\": \"irure ut elit culpa\",\n    \"ScheduledDate\": -68050007.61275624,\n    \"NextScheduleDate\": 53427406.61100432,\n    \"id\": \"Duis nisi laborum\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `InvoiceNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`InvoiceNumber`)) {\n                    const value = ld.get(responseData, `InvoiceNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field InvoiceNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ScheduledDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ScheduledDate`)) {\n                    const value = ld.get(responseData, `ScheduledDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ScheduledDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `NextScheduleDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`NextScheduleDate`)) {\n                    const value = ld.get(responseData, `NextScheduleDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field NextScheduleDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateScheduleTransfers",
      "request": {
        "name": "UpdateScheduleTransfers",
        "description": {
          "content": "Update the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateScheduleTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Scheduled transfer updated successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteScheduleTransfers",
      "request": {
        "name": "DeleteScheduleTransfers",
        "description": {
          "content": "Delete the scheduled transfer",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Scheduled transfer deleted successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AddRecurringTransfers",
      "request": {
        "name": "AddRecurringTransfers",
        "description": {
          "content": "Adds the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "AddRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer added successfully",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for AddRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer added successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetRecurringTransfers",
      "request": {
        "name": "GetRecurringTransfers",
        "description": {
          "content": "Fetches all the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"nulla ut Lorem adipisicing culpa\",\n    \"CustomerId\": 3765298.513593018,\n    \"Amount\": 32816310.38428609,\n    \"SourceAccountNumber\": \"ut\",\n    \"TargetAccountNumber\": \"eu qui\",\n    \"DueDate\": \"dolore incididunt ve\",\n    \"Currency\": \"aliqua ullamco\",\n    \"Status\": \"reprehenderit magna elit adipisicing est\",\n    \"ScheduledDate\": 96223112.801018,\n    \"recurringOptions\": {\n      \"amountType\": \"Lorem\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"Ut non nulla ullamco\",\n          \"untilDate\": \"eu Lor\",\n          \"numberOfPayments\": \"consequat aute dolore amet\"\n        },\n        \"iterate\": \"nostrud eiusmod do nulla Lorem\"\n      }\n    },\n    \"id\": \"aliqua\"\n  },\n  {\n    \"Type\": \"Lorem anim eu sint Excepteur\",\n    \"CustomerId\": -49474101.00232848,\n    \"Amount\": 10746155.73114355,\n    \"SourceAccountNumber\": \"aliqua ut cupidatat\",\n    \"TargetAccountNumber\": \"laboris velit\",\n    \"DueDate\": \"non culpa veniam dolore\",\n    \"Currency\": \"eu non\",\n    \"Status\": \"enim in est laboris\",\n    \"ScheduledDate\": 95796351.50904089,\n    \"recurringOptions\": {\n      \"amountType\": \"dolore aute\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"non Lorem exercitation veniam\",\n          \"untilDate\": \"laboris\",\n          \"numberOfPayments\": \"non labore ea in\"\n        },\n        \"iterate\": \"dolore ut non\"\n      }\n    },\n    \"id\": \"nulla nisi\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ScheduledDate` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ScheduledDate`)) {\n                    const value = ld.get(responseData, `ScheduledDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ScheduledDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.amountType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.amountType`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.amountType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field recurringOptions.amountType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions.frequency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency.duration` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency.duration`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency.duration`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field recurringOptions.frequency.duration:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `recurringOptions.frequency.iterate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`recurringOptions.frequency.iterate`)) {\n                    const value = ld.get(jsonResponse, `recurringOptions.frequency.iterate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field recurringOptions.frequency.iterate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateRecurringTransfers",
      "request": {
        "name": "UpdateRecurringTransfers",
        "description": {
          "content": "Update the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            },\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\"\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateRecurringTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Recurring transfer updated successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteRecurringTransfers",
      "request": {
        "name": "DeleteRecurringTransfers",
        "description": {
          "content": "Delete the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Recurring transfer deleted successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "resetPassword",
      "request": {
        "name": "resetPassword",
        "description": {
          "content": "It allows to reset the password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "resetPassword"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"password\": \"{{password_*string}}\",\n    \"username\": \"{{username_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "password has been updated successfully.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for resetPassword for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"password has been updated successfully.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "debitcardInfoValidation",
      "request": {
        "name": "debitcardInfoValidation",
        "description": {
          "content": "for validating card info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "debitcardInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*string}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*string}}\",\n    \"expiryDate\": \"{{expiryDate_*string}}\",\n    \"pin\": \"{{pin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for debitcardInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Validated Successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "personalInfoValidation",
      "request": {
        "name": "personalInfoValidation",
        "description": {
          "content": "for validating personal info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "personalInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*string}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*string}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for personalInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Validated Successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "disputeTransaction",
      "request": {
        "name": "disputeTransaction",
        "description": {
          "content": "dispute a transaction",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "disputeTransaction"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Dispute Transactions reported successfully",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for disputeTransaction for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Dispute Transactions reported successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "ccPay",
      "request": {
        "name": "ccPay",
        "description": {
          "content": "to pay cc bill",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "ccPay"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Credit Card payment scheduled successfully",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for ccPay for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Credit Card payment scheduled successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCCSchedule",
      "request": {
        "name": "GetCCSchedule",
        "description": {
          "content": "Fetch cc payment list",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCCSchedule"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"eiusmod Duis\",\n    \"CustomerId\": -79332625.20191354,\n    \"Amount\": -76098663.97967617,\n    \"SourceAccountNumber\": \"ea amet nulla\",\n    \"TargetAccountNumber\": \"ad magna Ut dolore\",\n    \"DueDate\": \"anim ut\",\n    \"Currency\": \"velit nostrud\",\n    \"Status\": \"no\",\n    \"id\": \"adipisicing do ess\"\n  },\n  {\n    \"Type\": \"sint tempor ullamco exerci\",\n    \"CustomerId\": -76147611.88871121,\n    \"Amount\": -98924732.1233333,\n    \"SourceAccountNumber\": \"amet nisi\",\n    \"TargetAccountNumber\": \"dolore consectetur cillum laborum deserunt\",\n    \"DueDate\": \"aliqua \",\n    \"Currency\": \"incididunt in\",\n    \"Status\": \"aliqua ipsum occaecat\",\n    \"id\": \"do incididunt consequat\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCCSchedule for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"schedule transfer list response\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `Type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Type`)) {\n                    const value = ld.get(jsonResponse, `Type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Type:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `CustomerId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`CustomerId`)) {\n                    const value = ld.get(responseData, `CustomerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field CustomerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Amount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`Amount`)) {\n                    const value = ld.get(responseData, `Amount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field Amount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `SourceAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`SourceAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `SourceAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field SourceAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `TargetAccountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`TargetAccountNumber`)) {\n                    const value = ld.get(jsonResponse, `TargetAccountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field TargetAccountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `DueDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`DueDate`)) {\n                    const value = ld.get(jsonResponse, `DueDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field DueDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Currency` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Currency`)) {\n                    const value = ld.get(jsonResponse, `Currency`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Currency:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `Status` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`Status`)) {\n                    const value = ld.get(jsonResponse, `Status`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field Status:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `id` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`id`)) {\n                    const value = ld.get(jsonResponse, `id`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field id:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendsecuremessage",
      "request": {
        "name": "sendsecuremessage",
        "description": {
          "content": "send secure message",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendsecuremessage"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendsecuremessage for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "locateProfile",
      "request": {
        "name": "locateProfile",
        "description": {
          "content": "get profile details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "locateProfile"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"accountNumber\": \"veniam amet consequat mollit\",\n  \"cardDetails\": {\n    \"cardNumber\": \"voluptate exercitation eu proident\",\n    \"expiryDate\": \"Excepteur sed reprehenderit deserunt\",\n    \"cvv\": \"enim occaecat dolor\",\n    \"pin\": \"eu cupidatat voluptate consequat\"\n  },\n  \"personalQuestions\": {\n    \"DOB\": \"eiusmod in\",\n    \"SSN\": -69503614.98585482,\n    \"SecretPassword\": \"proident in et nisi\",\n    \"LDAmount\": 96061910.05229428,\n    \"AccNumber\": \"nostrud id ut dolor\"\n  },\n  \"ssNumber\": 89835627.48020759,\n  \"ssnShort\": -50666995.241049804,\n  \"alternatePhoneNumber\": -70506195.47534281,\n  \"customerId\": \"deserun\",\n  \"email\": \"in voluptate in mollit\",\n  \"identificationNumber\": \"anim\",\n  \"identificationType\": \"deserunt fugiat magna ipsum\",\n  \"image\": \"in pariatur anim\",\n  \"isAlternateMobileNumber\": true,\n  \"isPrimaryMobileNumber\": false,\n  \"location\": \"deserunt in magna mollit\",\n  \"name\": \"enim sed dolore Excepteur\",\n  \"personalBanker\": {\n    \"name\": \"\",\n    \"email\": \"ad aute id Excepteur\",\n    \"mobileNumber\": \"anim\"\n  },\n  \"phone\": 69661072.34302425,\n  \"securityQuestions\": [\n    \"veniam tempor exercitation sed\",\n    \"sed tempor nisi non enim\"\n  ],\n  \"segmentId\": -7538809.206858456,\n  \"multiAccounts\": [\n    {\n      \"accountNumber\": \"nulla voluptate sint\",\n      \"cardDetails\": {\n        \"cardNumber\": \"qui fugiat aliquip\",\n        \"expiryDate\": \"est occaecat\",\n        \"cvv\": \"sunt enim irure\",\n        \"pin\": \"ex elit adipisicing et\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"dolore laborum labore\",\n        \"SSN\": 33329680.91732216,\n        \"SecretPassword\": \"magna\",\n        \"LDAmount\": -34458797.77869765,\n        \"AccNumber\": \"quis in sed\"\n      },\n      \"ssNumber\": 18756858.122349307,\n      \"ssnShort\": -15269667.29766506,\n      \"alternatePhoneNumber\": -73786591.32654479,\n      \"customerId\": \"ullamco amet sunt\",\n      \"email\": \"ad aute sunt Duis\",\n      \"identificationNumber\": \"proident Ut\",\n      \"identificationType\": \"in ut reprehenderit cupidatat\",\n      \"location\": \"aliqua dolor nostrud ut\",\n      \"name\": \"in qui\",\n      \"phone\": 60948902.988108546\n    },\n    {\n      \"accountNumber\": \"dolor qui\",\n      \"cardDetails\": {\n        \"cardNumber\": \"elit nulla Duis Lorem\",\n        \"expiryDate\": \"esse irure\",\n        \"cvv\": \"ullamco ex\",\n        \"pin\": \"\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"do amet magna fugiat\",\n        \"SSN\": -62811105.45604425,\n        \"SecretPassword\": \"consectetur exercitation s\",\n        \"LDAmount\": 49290061.59460312,\n        \"AccNumber\": \"proident sunt\"\n      },\n      \"ssNumber\": -11502252.931111917,\n      \"ssnShort\": -3774608.012183517,\n      \"alternatePhoneNumber\": 86946107.31430572,\n      \"customerId\": \"elit incididunt\",\n      \"email\": \"labore in pariatur voluptate\",\n      \"identificationNumber\": \"sunt fugiat nulla ea\",\n      \"identificationType\": \"laboris sunt\",\n      \"location\": \"exercitation\",\n      \"name\": \"ut et laboris eu\",\n      \"phone\": -78040348.726286\n    }\n  ],\n  \"warningCodes\": [\n    {\n      \"code\": -8917359.307201073,\n      \"level\": \"exercitation in Lorem l\",\n      \"description\": \"mollit\"\n    },\n    {\n      \"code\": 89469089.02536303,\n      \"level\": \"nulla sit dolore esse\",\n      \"description\": \"et magna l\"\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for locateProfile for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `accountNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`accountNumber`)) {\n                    const value = ld.get(jsonResponse, `accountNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field accountNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails`)) {\n                    const value = ld.get(jsonResponse, `cardDetails`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field cardDetails:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.cardNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.cardNumber`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.cardNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.cardNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.expiryDate` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.expiryDate`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.expiryDate`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.expiryDate:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.cvv` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.cvv`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.cvv`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.cvv:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `cardDetails.pin` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`cardDetails.pin`)) {\n                    const value = ld.get(jsonResponse, `cardDetails.pin`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field cardDetails.pin:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.DOB` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.DOB`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.DOB`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.DOB:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.SSN` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`personalQuestions.SSN`)) {\n                    const value = ld.get(responseData, `personalQuestions.SSN`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field personalQuestions.SSN:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.SecretPassword` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.SecretPassword`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.SecretPassword`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.SecretPassword:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.LDAmount` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`personalQuestions.LDAmount`)) {\n                    const value = ld.get(responseData, `personalQuestions.LDAmount`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field personalQuestions.LDAmount:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalQuestions.AccNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalQuestions.AccNumber`)) {\n                    const value = ld.get(jsonResponse, `personalQuestions.AccNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalQuestions.AccNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ssNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ssNumber`)) {\n                    const value = ld.get(responseData, `ssNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ssNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `ssnShort` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`ssnShort`)) {\n                    const value = ld.get(responseData, `ssnShort`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field ssnShort:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `alternatePhoneNumber` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`alternatePhoneNumber`)) {\n                    const value = ld.get(responseData, `alternatePhoneNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `customerId` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`customerId`)) {\n                    const value = ld.get(jsonResponse, `customerId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field customerId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`email`)) {\n                    const value = ld.get(jsonResponse, `email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationNumber`)) {\n                    const value = ld.get(jsonResponse, `identificationNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `identificationType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`identificationType`)) {\n                    const value = ld.get(jsonResponse, `identificationType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field identificationType:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `image` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`image`)) {\n                    const value = ld.get(jsonResponse, `image`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field image:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isAlternateMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isAlternateMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isAlternateMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isAlternateMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `isPrimaryMobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`isPrimaryMobileNumber`)) {\n                    const value = ld.get(jsonResponse, `isPrimaryMobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field isPrimaryMobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `location` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`location`)) {\n                    const value = ld.get(jsonResponse, `location`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field location:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`name`)) {\n                    const value = ld.get(jsonResponse, `name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker`)) {\n                    const value = ld.get(jsonResponse, `personalBanker`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field personalBanker:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.name`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.email` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.email`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.email`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.email:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `personalBanker.mobileNumber` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`personalBanker.mobileNumber`)) {\n                    const value = ld.get(jsonResponse, `personalBanker.mobileNumber`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field personalBanker.mobileNumber:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `phone` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`phone`)) {\n                    const value = ld.get(responseData, `phone`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field phone:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `securityQuestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`securityQuestions`)) {\n                    const value = ld.get(jsonResponse, `securityQuestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field securityQuestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `segmentId` field',function(){\n            try {\n                if (responseData && pm.expect(responseData).to.have.nested.property(`segmentId`)) {\n                    const value = ld.get(responseData, `segmentId`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking number field segmentId:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `multiAccounts` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`multiAccounts`)) {\n                    const value = ld.get(jsonResponse, `multiAccounts`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field multiAccounts:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the multiAccounts field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`multiAccounts`)) {\n                    let multiAccountsArray = ld.get(jsonResponse, `multiAccounts`, []);\n                    if (Array.isArray(multiAccountsArray)) {\n                        for (let multiAccounts_it = 0; multiAccounts_it < multiAccountsArray.length; multiAccounts_it++) {\n                            let iterator = multiAccounts_it;\n                            if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].accountNumber' has 'accountNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].accountNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].accountNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails' has 'cardDetails' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for multiAccounts[${multiAccounts_it}].cardDetails:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.cardNumber' has 'cardNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.cardNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.cardNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.expiryDate' has 'expiryDate' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.expiryDate`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.expiryDate:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.cvv' has 'cvv' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.cvv`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.cvv:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].cardDetails.pin' has 'pin' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].cardDetails.pin`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].cardDetails.pin:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions' has 'personalQuestions' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for multiAccounts[${multiAccounts_it}].personalQuestions:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.DOB' has 'DOB' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.DOB`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.DOB:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'SSN' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].personalQuestions.SSN`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].personalQuestions.SSN:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword' has 'SecretPassword' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.SecretPassword:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'LDAmount' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].personalQuestions.LDAmount`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].personalQuestions.LDAmount:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber' has 'AccNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].personalQuestions.AccNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'ssNumber' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].ssNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].ssNumber:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'ssnShort' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].ssnShort`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].ssnShort:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'alternatePhoneNumber' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].alternatePhoneNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].alternatePhoneNumber:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].customerId' has 'customerId' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].customerId`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].customerId:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].email' has 'email' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].email`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].email:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].identificationNumber' has 'identificationNumber' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].identificationNumber`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].identificationNumber:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].identificationType' has 'identificationType' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].identificationType`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].identificationType:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].location' has 'location' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].location`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].location:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccounts[${multiAccounts_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `multiAccounts[${multiAccounts_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for multiAccounts[${multiAccounts_it}].name:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'multiAccountsArray' has 'phone' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `multiAccounts[${multiAccounts_it}].phone`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for multiAccounts[${multiAccounts_it}].phone:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for multiAccounts:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `warningCodes` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`warningCodes`)) {\n                    const value = ld.get(jsonResponse, `warningCodes`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field warningCodes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the warningCodes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`warningCodes`)) {\n                    let warningCodesArray = ld.get(jsonResponse, `warningCodes`, []);\n                    if (Array.isArray(warningCodesArray)) {\n                        for (let warningCodes_it = 0; warningCodes_it < warningCodesArray.length; warningCodes_it++) {\n                            let iterator = warningCodes_it;\n                            if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'warningCodesArray' has 'code' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `warningCodes[${warningCodes_it}].code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for warningCodes[${warningCodes_it}].code:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'warningCodes[${warningCodes_it}].level' has 'level' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `warningCodes[${warningCodes_it}].level`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for warningCodes[${warningCodes_it}].level:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'warningCodes[${warningCodes_it}].description' has 'description' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `warningCodes[${warningCodes_it}].description`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for warningCodes[${warningCodes_it}].description:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for warningCodes:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the exiting user",
      "request": {
        "name": "to validate the exiting user",
        "description": {
          "content": "to validate the in of existing user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validateUser"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validateUser for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PINs matched\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the pins entered by the new user",
      "request": {
        "name": "to validate the pins entered by the new user",
        "description": {
          "content": "to validate the pins entered by the new user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePIN"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePIN for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PINs matched\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate if pin entered by new user follows pin rules",
      "request": {
        "name": "to validate if pin entered by new user follows pin rules",
        "description": {
          "content": "to validate if pin entered by new user follows pin rules",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePINRules"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PIN rules satisfied",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePINRules for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"PIN rules satisfied\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the account closure status",
      "request": {
        "name": "to fetch the account closure status",
        "description": {
          "content": "to fetch the account closure status",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "getRequestStatus"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for getRequestStatus for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to place the request",
      "request": {
        "name": "to place the request",
        "description": {
          "content": "to place the request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "request"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for request for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to enable or disable e or paper statements at profile level",
      "request": {
        "name": "to enable or disable e or paper statements at profile level",
        "description": {
          "content": "to enable or disable e or paper statements at profile level",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "enableEStatement"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for enableEStatement for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to update the cheque book details of customer accounts",
      "request": {
        "name": "to update the cheque book details of customer accounts",
        "description": {
          "content": "Update customer cheque book details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "RequestChequeBook"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required) ",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required) ",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for RequestChequeBook for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"successful operation\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendOTP",
      "request": {
        "name": "sendOTP",
        "description": {
          "content": "sends OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "verification code has been sent to your mobile number",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"verification code has been sent to your mobile number\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "verifyOTP",
      "request": {
        "name": "verifyOTP",
        "description": {
          "content": " to verify OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "verifyOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "OTP verifid successfully",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for verifyOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"OTP verifid successfully\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the deeplink",
      "request": {
        "name": "to fetch the deeplink",
        "description": {
          "content": "to fetch the deeplink",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deeplink"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "tenantId",
            "value": "{{tenantId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "environment",
            "value": "{{environment}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "channel",
            "value": "{{channel}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"usecase\": \"addbeneficiary\",\n    \"link\": \"www.google.com\",\n    \"linkType\": \"deeplink\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"eu pariatur Lorem\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1756354257310 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deeplink for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n                if (Array.isArray(responseData)) {\n                    responseData.forEach((item, index) => {\n                        if (item !== null && item !== undefined) {\n        pm.test('Response has the `usecase` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`usecase`)) {\n                    const value = ld.get(jsonResponse, `usecase`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field usecase:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `link` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`link`)) {\n                    const value = ld.get(jsonResponse, `link`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field link:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `linkType` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`linkType`)) {\n                    const value = ld.get(jsonResponse, `linkType`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field linkType:\", error.message);\n            }\n        })\n\n                        }\n                    });\n                }\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"Error: Authorisation failed.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n\nif (pm.response.code == 404){\n    pm.test(\"Error: Not Found\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n        try {\n            if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `err` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err`)) {\n                    const value = ld.get(jsonResponse, `err`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field err:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `err.message` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`err.message`)) {\n                    const value = ld.get(jsonResponse, `err.message`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field err.message:\", error.message);\n            }\n        })\n\n            }\n        } catch (error) {\n            console.error('Error during response validation:', error.message);\n        }\n    });\n\n}\n"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://localhost:8080/smt",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{bearerToken}}"
      }
    ]
  },
  "info": {
    "_postman_id": "313c9a80-a8a0-49a2-bda8-fdd328f80698",
    "name": "BankAssist SMT Core Banking API Specification",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "kore.ai banking bot apis.",
      "type": "text/plain"
    }
  }
}