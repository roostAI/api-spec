{
  "item": [
    {
      "name": "Realtime API",
      "request": {
        "name": "Realtime API",
        "description": {
          "content": "Current weather or realtime weather API method allows a user to get up to date current weather information in json and xml. The data is returned as a Current Object.<br /><br />Current object contains current or realtime weather information for a given city.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "current.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "current.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"current\": {\n    \"last_updated_epoch\": 1658522700,\n    \"last_updated\": \"2022-07-22 16:45\",\n    \"temp_c\": 34.4,\n    \"temp_f\": 93.9,\n    \"is_day\": 1,\n    \"condition\": {\n      \"text\": \"Partly cloudy\",\n      \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/116.png\",\n      \"code\": 1003\n    },\n    \"wind_mph\": 16.1,\n    \"wind_kph\": 25.9,\n    \"wind_degree\": 180,\n    \"wind_dir\": \"S\",\n    \"pressure_mb\": 1011,\n    \"pressure_in\": 29.85,\n    \"precip_mm\": 0,\n    \"precip_in\": 0,\n    \"humidity\": 31,\n    \"cloud\": 75,\n    \"feelslike_c\": 37,\n    \"feelslike_f\": 98.6,\n    \"vis_km\": 16,\n    \"vis_miles\": 9,\n    \"uv\": 8,\n    \"gust_mph\": 11.6,\n    \"gust_kph\": 18.7,\n    \"air_quality\": {\n      \"co\": 293.70001220703125,\n      \"no2\": 18.5,\n      \"o3\": 234.60000610351562,\n      \"so2\": 12,\n      \"pm2_5\": 13.600000381469727,\n      \"pm10\": 15,\n      \"us-epa-index\": 1,\n      \"gb-defra-index\": 2\n    }\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "current.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "current.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "current.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for current.json?q={{q}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: current\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'current')) {\n            pm.test(`'responseData field has current that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`current`)) {\n                const value = responseData?.current;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'last_updated_epoch')) {\n            pm.test(`'responseData.current field has last_updated_epoch that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated_epoch`)) {\n                const value = responseData.current?.last_updated_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'last_updated')) {\n            pm.test(`'responseData.current field has last_updated that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated`)) {\n                const value = responseData.current?.last_updated;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_c\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'temp_c')) {\n            pm.test(`'responseData.current field has temp_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_c`)) {\n                const value = responseData.current?.temp_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_f\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'temp_f')) {\n            pm.test(`'responseData.current field has temp_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_f`)) {\n                const value = responseData.current?.temp_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: is_day\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'is_day')) {\n            pm.test(`'responseData.current field has is_day that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`is_day`)) {\n                const value = responseData.current?.is_day;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: condition\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'condition')) {\n            pm.test(`'responseData.current field has condition that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                const value = responseData.current?.condition;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: text\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'text')) {\n            pm.test(`'responseData.current.condition field has text that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                const value = responseData.current.condition?.text;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: icon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'icon')) {\n            pm.test(`'responseData.current.condition field has icon that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                const value = responseData.current.condition?.icon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'code')) {\n            pm.test(`'responseData.current.condition field has code that is of type number'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData.current.condition?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_mph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_mph')) {\n            pm.test(`'responseData.current field has wind_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_mph`)) {\n                const value = responseData.current?.wind_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_kph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_kph')) {\n            pm.test(`'responseData.current field has wind_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_kph`)) {\n                const value = responseData.current?.wind_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_degree\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_degree')) {\n            pm.test(`'responseData.current field has wind_degree that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_degree`)) {\n                const value = responseData.current?.wind_degree;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_dir\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_dir')) {\n            pm.test(`'responseData.current field has wind_dir that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_dir`)) {\n                const value = responseData.current?.wind_dir;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_mb\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'pressure_mb')) {\n            pm.test(`'responseData.current field has pressure_mb that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_mb`)) {\n                const value = responseData.current?.pressure_mb;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_in\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'pressure_in')) {\n            pm.test(`'responseData.current field has pressure_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_in`)) {\n                const value = responseData.current?.pressure_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_mm\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'precip_mm')) {\n            pm.test(`'responseData.current field has precip_mm that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_mm`)) {\n                const value = responseData.current?.precip_mm;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_in\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'precip_in')) {\n            pm.test(`'responseData.current field has precip_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_in`)) {\n                const value = responseData.current?.precip_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: humidity\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'humidity')) {\n            pm.test(`'responseData.current field has humidity that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`humidity`)) {\n                const value = responseData.current?.humidity;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: cloud\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'cloud')) {\n            pm.test(`'responseData.current field has cloud that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`cloud`)) {\n                const value = responseData.current?.cloud;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_c\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'feelslike_c')) {\n            pm.test(`'responseData.current field has feelslike_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_c`)) {\n                const value = responseData.current?.feelslike_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_f\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'feelslike_f')) {\n            pm.test(`'responseData.current field has feelslike_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_f`)) {\n                const value = responseData.current?.feelslike_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_km\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'vis_km')) {\n            pm.test(`'responseData.current field has vis_km that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_km`)) {\n                const value = responseData.current?.vis_km;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_miles\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'vis_miles')) {\n            pm.test(`'responseData.current field has vis_miles that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_miles`)) {\n                const value = responseData.current?.vis_miles;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: uv\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'uv')) {\n            pm.test(`'responseData.current field has uv that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                const value = responseData.current?.uv;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_mph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'gust_mph')) {\n            pm.test(`'responseData.current field has gust_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_mph`)) {\n                const value = responseData.current?.gust_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_kph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'gust_kph')) {\n            pm.test(`'responseData.current field has gust_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_kph`)) {\n                const value = responseData.current?.gust_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: air_quality\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'air_quality')) {\n            pm.test(`'responseData.current field has air_quality that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`air_quality`)) {\n                const value = responseData.current?.air_quality;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: co\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'co')) {\n            pm.test(`'responseData.current.air_quality field has co that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`co`)) {\n                const value = responseData.current.air_quality?.co;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: no2\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'no2')) {\n            pm.test(`'responseData.current.air_quality field has no2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`no2`)) {\n                const value = responseData.current.air_quality?.no2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: o3\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'o3')) {\n            pm.test(`'responseData.current.air_quality field has o3 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`o3`)) {\n                const value = responseData.current.air_quality?.o3;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: so2\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'so2')) {\n            pm.test(`'responseData.current.air_quality field has so2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`so2`)) {\n                const value = responseData.current.air_quality?.so2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm2_5\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'pm2_5')) {\n            pm.test(`'responseData.current.air_quality field has pm2_5 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm2_5`)) {\n                const value = responseData.current.air_quality?.pm2_5;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm10\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'pm10')) {\n            pm.test(`'responseData.current.air_quality field has pm10 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm10`)) {\n                const value = responseData.current.air_quality?.pm10;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: us-epa-index\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'us-epa-index')) {\n            pm.test(`'responseData.current.air_quality field has us-epa-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`us-epa-index`)) {\n                const value = responseData.current.air_quality?.us - epa - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: gb-defra-index\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'gb-defra-index')) {\n            pm.test(`'responseData.current.air_quality field has gb-defra-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`gb-defra-index`)) {\n                const value = responseData.current.air_quality?.gb - defra - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Forecast API",
      "request": {
        "name": "Forecast API",
        "description": {
          "content": "Forecast weather API method returns, depending upon your price plan level, upto next 14 day weather forecast and weather alert as json or xml. The data is returned as a Forecast Object.<br /><br />Forecast object contains astronomy data, day weather forecast and hourly interval weather information for a given city.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "forecast.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "days",
              "value": "{{days}}",
              "description": "(Required) Number of days of weather forecast. Value ranges from 1 to 14"
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "Date should be between today and next 14 day in yyyy-MM-dd format. e.g. '2015-01-01'"
            },
            {
              "disabled": false,
              "key": "unixdt",
              "value": "{{unixdt}}",
              "description": "Please either pass 'dt' or 'unixdt' and not both in same request. unixdt should be between today and next 14 day in Unix format. e.g. 1490227200"
            },
            {
              "disabled": false,
              "key": "hour",
              "value": "{{hour}}",
              "description": "Must be in 24 hour. For example 5 pm should be hour=17, 6 am as hour=6"
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            },
            {
              "disabled": false,
              "key": "alerts",
              "value": "{{alerts}}",
              "description": "Enable/Disable alerts in forecast API output. Example, alerts=yes or alerts=no."
            },
            {
              "disabled": false,
              "key": "aqi",
              "value": "{{aqi}}",
              "description": "Enable/Disable Air Quality data in forecast API output. Example, aqi=yes or aqi=no."
            },
            {
              "disabled": false,
              "key": "tp",
              "value": "{{tp}}",
              "description": "Get 15 min interval or 24 hour average data for Forecast and History API. Available for Enterprise clients only. E.g:- tp=15"
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "forecast.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "alerts",
                  "value": "{{alerts}}"
                },
                {
                  "key": "aqi",
                  "value": "{{aqi}}"
                },
                {
                  "key": "tp",
                  "value": "{{tp}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"current\": {\n    \"last_updated_epoch\": 1658522700,\n    \"last_updated\": \"2022-07-22 16:45\",\n    \"temp_c\": 34.4,\n    \"temp_f\": 93.9,\n    \"is_day\": 1,\n    \"condition\": {\n      \"text\": \"Partly cloudy\",\n      \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/116.png\",\n      \"code\": 1003\n    },\n    \"wind_mph\": 16.1,\n    \"wind_kph\": 25.9,\n    \"wind_degree\": 180,\n    \"wind_dir\": \"S\",\n    \"pressure_mb\": 1011,\n    \"pressure_in\": 29.85,\n    \"precip_mm\": 0,\n    \"precip_in\": 0,\n    \"humidity\": 31,\n    \"cloud\": 75,\n    \"feelslike_c\": 37,\n    \"feelslike_f\": 98.6,\n    \"vis_km\": 16,\n    \"vis_miles\": 9,\n    \"uv\": 8,\n    \"gust_mph\": 11.6,\n    \"gust_kph\": 18.7,\n    \"air_quality\": {\n      \"co\": 293.70001220703125,\n      \"no2\": 18.5,\n      \"o3\": 234.60000610351562,\n      \"so2\": 12,\n      \"pm2_5\": 13.600000381469727,\n      \"pm10\": 15,\n      \"us-epa-index\": 1,\n      \"gb-defra-index\": 2\n    }\n  },\n  \"forecast\": {\n    \"forecastday\": [\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"string\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      },\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"string\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      }\n    ]\n  },\n  \"alerts\": {\n    \"alert\": [\n      {\n        \"headline\": \"NWS New York City - Upton (Long Island and New York City)\",\n        \"msgtype\": \"string\",\n        \"severity\": \"string\",\n        \"urgency\": \"string\",\n        \"areas\": \"string\",\n        \"category\": \"Extreme temperature value\",\n        \"certainty\": \"string\",\n        \"event\": \"Heat Advisory\",\n        \"note\": \"string\",\n        \"effective\": \"2022-07-21T19:38:00+00:00\",\n        \"expires\": \"2022-07-25T00:00:00+00:00\",\n        \"desc\": \"...HEAT ADVISORY REMAINS IN EFFECT UNTIL 8 PM EDT SUNDAY... * WHAT...Heat index values up to 105. * WHERE...Eastern Passaic Hudson Western Bergen Western Essex Eastern Bergen and Eastern Essex Counties. * WHEN...Until 8 PM EDT Sunday. * IMPACTS...High temperatures and high humidity may cause heat illnesses to occur.\",\n        \"instruction\": \"\"\n      },\n      {\n        \"headline\": \"NWS New York City - Upton (Long Island and New York City)\",\n        \"msgtype\": \"string\",\n        \"severity\": \"string\",\n        \"urgency\": \"string\",\n        \"areas\": \"string\",\n        \"category\": \"Extreme temperature value\",\n        \"certainty\": \"string\",\n        \"event\": \"Heat Advisory\",\n        \"note\": \"string\",\n        \"effective\": \"2022-07-21T19:38:00+00:00\",\n        \"expires\": \"2022-07-25T00:00:00+00:00\",\n        \"desc\": \"...HEAT ADVISORY REMAINS IN EFFECT UNTIL 8 PM EDT SUNDAY... * WHAT...Heat index values up to 105. * WHERE...Eastern Passaic Hudson Western Bergen Western Essex Eastern Bergen and Eastern Essex Counties. * WHEN...Until 8 PM EDT Sunday. * IMPACTS...High temperatures and high humidity may cause heat illnesses to occur.\",\n        \"instruction\": \"\"\n      }\n    ]\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "forecast.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "alerts",
                  "value": "{{alerts}}"
                },
                {
                  "key": "aqi",
                  "value": "{{aqi}}"
                },
                {
                  "key": "tp",
                  "value": "{{tp}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "forecast.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "alerts",
                  "value": "{{alerts}}"
                },
                {
                  "key": "aqi",
                  "value": "{{aqi}}"
                },
                {
                  "key": "tp",
                  "value": "{{tp}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "forecast.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "alerts",
                  "value": "{{alerts}}"
                },
                {
                  "key": "aqi",
                  "value": "{{aqi}}"
                },
                {
                  "key": "tp",
                  "value": "{{tp}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for forecast.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}}&alerts={{alerts}}&aqi={{aqi}}&tp={{tp}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: current\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'current')) {\n            pm.test(`'responseData field has current that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`current`)) {\n                const value = responseData?.current;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'last_updated_epoch')) {\n            pm.test(`'responseData.current field has last_updated_epoch that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated_epoch`)) {\n                const value = responseData.current?.last_updated_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: last_updated\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'last_updated')) {\n            pm.test(`'responseData.current field has last_updated that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`last_updated`)) {\n                const value = responseData.current?.last_updated;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_c\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'temp_c')) {\n            pm.test(`'responseData.current field has temp_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_c`)) {\n                const value = responseData.current?.temp_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: temp_f\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'temp_f')) {\n            pm.test(`'responseData.current field has temp_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`temp_f`)) {\n                const value = responseData.current?.temp_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: is_day\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'is_day')) {\n            pm.test(`'responseData.current field has is_day that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`is_day`)) {\n                const value = responseData.current?.is_day;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: condition\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'condition')) {\n            pm.test(`'responseData.current field has condition that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                const value = responseData.current?.condition;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: text\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'text')) {\n            pm.test(`'responseData.current.condition field has text that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                const value = responseData.current.condition?.text;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: icon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'icon')) {\n            pm.test(`'responseData.current.condition field has icon that is of type string'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                const value = responseData.current.condition?.icon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.condition\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.condition, 'code')) {\n            pm.test(`'responseData.current.condition field has code that is of type number'`, function() {\n              let parent = responseData.current.condition;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData.current.condition?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_mph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_mph')) {\n            pm.test(`'responseData.current field has wind_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_mph`)) {\n                const value = responseData.current?.wind_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_kph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_kph')) {\n            pm.test(`'responseData.current field has wind_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_kph`)) {\n                const value = responseData.current?.wind_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_degree\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_degree')) {\n            pm.test(`'responseData.current field has wind_degree that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_degree`)) {\n                const value = responseData.current?.wind_degree;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: wind_dir\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'wind_dir')) {\n            pm.test(`'responseData.current field has wind_dir that is of type string'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`wind_dir`)) {\n                const value = responseData.current?.wind_dir;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_mb\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'pressure_mb')) {\n            pm.test(`'responseData.current field has pressure_mb that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_mb`)) {\n                const value = responseData.current?.pressure_mb;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: pressure_in\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'pressure_in')) {\n            pm.test(`'responseData.current field has pressure_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`pressure_in`)) {\n                const value = responseData.current?.pressure_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_mm\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'precip_mm')) {\n            pm.test(`'responseData.current field has precip_mm that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_mm`)) {\n                const value = responseData.current?.precip_mm;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: precip_in\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'precip_in')) {\n            pm.test(`'responseData.current field has precip_in that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`precip_in`)) {\n                const value = responseData.current?.precip_in;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: humidity\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'humidity')) {\n            pm.test(`'responseData.current field has humidity that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`humidity`)) {\n                const value = responseData.current?.humidity;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: cloud\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'cloud')) {\n            pm.test(`'responseData.current field has cloud that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`cloud`)) {\n                const value = responseData.current?.cloud;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_c\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'feelslike_c')) {\n            pm.test(`'responseData.current field has feelslike_c that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_c`)) {\n                const value = responseData.current?.feelslike_c;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: feelslike_f\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'feelslike_f')) {\n            pm.test(`'responseData.current field has feelslike_f that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`feelslike_f`)) {\n                const value = responseData.current?.feelslike_f;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_km\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'vis_km')) {\n            pm.test(`'responseData.current field has vis_km that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_km`)) {\n                const value = responseData.current?.vis_km;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: vis_miles\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'vis_miles')) {\n            pm.test(`'responseData.current field has vis_miles that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`vis_miles`)) {\n                const value = responseData.current?.vis_miles;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: uv\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'uv')) {\n            pm.test(`'responseData.current field has uv that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                const value = responseData.current?.uv;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_mph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'gust_mph')) {\n            pm.test(`'responseData.current field has gust_mph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_mph`)) {\n                const value = responseData.current?.gust_mph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: gust_kph\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'gust_kph')) {\n            pm.test(`'responseData.current field has gust_kph that is of type number'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`gust_kph`)) {\n                const value = responseData.current?.gust_kph;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current\n          // subKey: air_quality\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current, 'air_quality')) {\n            pm.test(`'responseData.current field has air_quality that is of type object'`, function() {\n              let parent = responseData.current;\n              if (pm.expect(parent).to.have.nested.property(`air_quality`)) {\n                const value = responseData.current?.air_quality;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: co\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'co')) {\n            pm.test(`'responseData.current.air_quality field has co that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`co`)) {\n                const value = responseData.current.air_quality?.co;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: no2\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'no2')) {\n            pm.test(`'responseData.current.air_quality field has no2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`no2`)) {\n                const value = responseData.current.air_quality?.no2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: o3\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'o3')) {\n            pm.test(`'responseData.current.air_quality field has o3 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`o3`)) {\n                const value = responseData.current.air_quality?.o3;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: so2\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'so2')) {\n            pm.test(`'responseData.current.air_quality field has so2 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`so2`)) {\n                const value = responseData.current.air_quality?.so2;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm2_5\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'pm2_5')) {\n            pm.test(`'responseData.current.air_quality field has pm2_5 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm2_5`)) {\n                const value = responseData.current.air_quality?.pm2_5;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: pm10\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'pm10')) {\n            pm.test(`'responseData.current.air_quality field has pm10 that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`pm10`)) {\n                const value = responseData.current.air_quality?.pm10;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: us-epa-index\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'us-epa-index')) {\n            pm.test(`'responseData.current.air_quality field has us-epa-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`us-epa-index`)) {\n                const value = responseData.current.air_quality?.us - epa - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.current.air_quality\n          // subKey: gb-defra-index\n          let requiredField = false\n          if (requiredField || ld.get(responseData.current.air_quality, 'gb-defra-index')) {\n            pm.test(`'responseData.current.air_quality field has gb-defra-index that is of type number'`, function() {\n              let parent = responseData.current.air_quality;\n              if (pm.expect(parent).to.have.nested.property(`gb-defra-index`)) {\n                const value = responseData.current.air_quality?.gb - defra - index;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'forecast')) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test('Response has the forecastday field of type array', function() {\n          if (pm.expect(responseData).to.have.nested.property('forecastday')) {\n            const value = responseData?.forecastday;\n\n            if (value !== null && value !== undefined) {\n              pm.expect(Array.isArray(value)).to.equal(true);\n            }\n\n          }\n        })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: alerts\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'alerts')) {\n            pm.test(`'responseData field has alerts that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`alerts`)) {\n                const value = responseData?.alerts;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test('Response has the alert field of type array', function() {\n          if (pm.expect(responseData).to.have.nested.property('alert')) {\n            const value = responseData?.alert;\n\n            if (value !== null && value !== undefined) {\n              pm.expect(Array.isArray(value)).to.equal(true);\n            }\n\n          }\n        })\n\n        pm.test(`Each object in the responseData.alerts.alert field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.alerts).to.have.nested.property(`alert`)) {\n            let alertArray = ld.get(responseData.alerts, `alert`, []);\n            if (Array.isArray(alertArray)) {\n              for (let alert_it = 0; alert_it < alertArray.length; alert_it++) {\n                let iterator = alert_it;\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'headline' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.headline;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'msgtype' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.msgtype;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'severity' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.severity;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'urgency' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.urgency;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'areas' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.areas;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'category' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.category;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'certainty' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.certainty;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'event' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.event;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'note' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.note;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'effective' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.effective;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('alertArray[${iterator}] format to be date-time', function() {\n                    const value = ld.get(responseData, `alertArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                    }\n                  })\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'expires' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.expires;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('alertArray[${iterator}] format to be date-time', function() {\n                    const value = ld.get(responseData, `alertArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}T([01]d|2[0-3]):([0-5]d):([0-5]d)$/);\n                    }\n                  })\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'desc' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.desc;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (alertArray[alert_it] !== null && alertArray[alert_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at alertArray[${iterator}]' has 'instruction' as type 'string'`, function() {\n                    const value = alertArray[iterator]?.instruction;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Future API",
      "request": {
        "name": "Future API",
        "description": {
          "content": "Future weather API method returns weather in a 3 hourly interval in future for a date between 14 days and 365 days from today in the future.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "future.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "Date should be between 14 days and 300 days from today in the future in yyyy-MM-dd format (i.e. dt=2023-01-01)"
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "future.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"forecast\": {\n    \"forecastday\": [\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"string\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      },\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"string\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      }\n    ]\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "future.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "future.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "future.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for future.json?q={{q}}&dt={{dt}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'forecast')) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test('Response has the forecastday field of type array', function() {\n          if (pm.expect(responseData).to.have.nested.property('forecastday')) {\n            const value = responseData?.forecastday;\n\n            if (value !== null && value !== undefined) {\n              pm.expect(Array.isArray(value)).to.equal(true);\n            }\n\n          }\n        })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "History API",
      "request": {
        "name": "History API",
        "description": {
          "content": "History weather API method returns historical weather for a date on or after 1st Jan, 2010 as json. The data is returned as a Forecast Object.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "history.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "(Required) Date on or after 1st Jan, 2015 in yyyy-MM-dd format"
            },
            {
              "disabled": false,
              "key": "unixdt",
              "value": "{{unixdt}}",
              "description": "Please either pass 'dt' or 'unixdt' and not both in same request.<br />unixdt should be on or after 1st Jan, 2015 in Unix format"
            },
            {
              "disabled": false,
              "key": "end_dt",
              "value": "{{end_dt}}",
              "description": "Date on or after 1st Jan, 2015 in yyyy-MM-dd format<br />'end_dt' should be greater than 'dt' parameter and difference should not be more than 30 days between the two dates."
            },
            {
              "disabled": false,
              "key": "unixend_dt",
              "value": "{{unixend_dt}}",
              "description": "Date on or after 1st Jan, 2015 in Unix Timestamp format<br />unixend_dt has same restriction as 'end_dt' parameter. Please either pass 'end_dt' or 'unixend_dt' and not both in same request. e.g. unixend_dt=1490227200"
            },
            {
              "disabled": false,
              "key": "hour",
              "value": "{{hour}}",
              "description": "Must be in 24 hour. For example 5 pm should be hour=17, 6 am as hour=6"
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "history.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "end_dt",
                  "value": "{{end_dt}}"
                },
                {
                  "key": "unixend_dt",
                  "value": "{{unixend_dt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"forecast\": {\n    \"forecastday\": [\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"string\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      },\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"string\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      }\n    ]\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "history.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "end_dt",
                  "value": "{{end_dt}}"
                },
                {
                  "key": "unixend_dt",
                  "value": "{{unixend_dt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "history.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "end_dt",
                  "value": "{{end_dt}}"
                },
                {
                  "key": "unixend_dt",
                  "value": "{{unixend_dt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "history.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "end_dt",
                  "value": "{{end_dt}}"
                },
                {
                  "key": "unixend_dt",
                  "value": "{{unixend_dt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for history.json?q={{q}}&dt={{dt}}&unixdt={{unixdt}}&end_dt={{end_dt}}&unixend_dt={{unixend_dt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'forecast')) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test('Response has the forecastday field of type array', function() {\n          if (pm.expect(responseData).to.have.nested.property('forecastday')) {\n            const value = responseData?.forecastday;\n\n            if (value !== null && value !== undefined) {\n              pm.expect(Array.isArray(value)).to.equal(true);\n            }\n\n          }\n        })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Marine Weather API",
      "request": {
        "name": "Marine Weather API",
        "description": {
          "content": "Marine weather API method returns upto next 7 day (depending upon your price plan level) marine and sailing weather forecast and tide data (depending upon your price plan level) as json or xml. The data is returned as a Marine Object.<br /><br />Marine object, depending upon your price plan level, contains astronomy data, day weather forecast and hourly interval weather information and tide data for a given sea/ocean point.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "marine.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass Latitude/Longitude (decimal degree) which is on a sea/ocean. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "days",
              "value": "{{days}}",
              "description": "(Required) Number of days of weather forecast. Value ranges from 1 to 7"
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "Date should be between today and next 7 day in yyyy-MM-dd format. e.g. '2023-05-20'"
            },
            {
              "disabled": false,
              "key": "unixdt",
              "value": "{{unixdt}}",
              "description": "Please either pass 'dt' or 'unixdt' and not both in same request. unixdt should be between today and next 7 day in Unix format. e.g. 1490227200"
            },
            {
              "disabled": false,
              "key": "hour",
              "value": "{{hour}}",
              "description": "Must be in 24 hour. For example 5 pm should be hour=17, 6 am as hour=6"
            },
            {
              "disabled": false,
              "key": "lang",
              "value": "{{lang}}",
              "description": "Returns 'condition:text' field in API in the desired language.<br /> Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to check 'lang-code'."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "marine.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"forecast\": {\n    \"forecastday\": [\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"string\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"sig_ht_mt\": 24.1,\n            \"swell_ht_mt\": 24.1,\n            \"swell_ht_ft\": 24.1,\n            \"swell_dir\": 24.1,\n            \"swell_dir_16_point\": 24.1,\n            \"swell_period_secs\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"sig_ht_mt\": 24.1,\n            \"swell_ht_mt\": 24.1,\n            \"swell_ht_ft\": 24.1,\n            \"swell_dir\": 24.1,\n            \"swell_dir_16_point\": 24.1,\n            \"swell_period_secs\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      },\n      {\n        \"date\": \"2022-07-22\",\n        \"date_epoch\": 1658448000,\n        \"day\": {\n          \"maxtemp_c\": 35.9,\n          \"maxtemp_f\": 96.6,\n          \"mintemp_c\": 26.3,\n          \"mintemp_f\": 79.3,\n          \"avgtemp_c\": 30.7,\n          \"avgtemp_f\": 87.3,\n          \"maxwind_mph\": 12.8,\n          \"maxwind_kph\": 20.5,\n          \"totalprecip_mm\": 0,\n          \"totalprecip_in\": 0,\n          \"avgvis_km\": 10,\n          \"avgvis_miles\": 6,\n          \"avghumidity\": 53,\n          \"daily_will_it_rain\": 0,\n          \"daily_chance_of_rain\": 0,\n          \"daily_will_it_snow\": 0,\n          \"daily_chance_of_snow\": 0,\n          \"condition\": {\n            \"text\": \"Sunny\",\n            \"icon\": \"//cdn.weatherapi.com/weather/64x64/day/113.png\",\n            \"code\": 1000\n          },\n          \"uv\": 8\n        },\n        \"astro\": {\n          \"sunrise\": \"05:44 AM\",\n          \"sunset\": \"08:20 PM\",\n          \"moonrise\": \"12:58 AM\",\n          \"moonset\": \"03:35 PM\",\n          \"moon_phase\": \"Last Quarter\",\n          \"moon_illumination\": \"string\"\n        },\n        \"hour\": [\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"sig_ht_mt\": 24.1,\n            \"swell_ht_mt\": 24.1,\n            \"swell_ht_ft\": 24.1,\n            \"swell_dir\": 24.1,\n            \"swell_dir_16_point\": 24.1,\n            \"swell_period_secs\": 24.1,\n            \"uv\": 1\n          },\n          {\n            \"time_epoch\": 1658462400,\n            \"time\": \"2022-07-22 00:00\",\n            \"temp_c\": 28.7,\n            \"temp_f\": 83.7,\n            \"is_day\": 0,\n            \"condition\": {\n              \"text\": \"Clear\",\n              \"icon\": \"//cdn.weatherapi.com/weather/64x64/night/113.png\",\n              \"code\": 1000\n            },\n            \"wind_mph\": 9.4,\n            \"wind_kph\": 15.1,\n            \"wind_degree\": 265,\n            \"wind_dir\": \"W\",\n            \"pressure_mb\": 1007,\n            \"pressure_in\": 29.73,\n            \"precip_mm\": 0,\n            \"precip_in\": 0,\n            \"humidity\": 58,\n            \"cloud\": 19,\n            \"feelslike_c\": 30.5,\n            \"feelslike_f\": 86.9,\n            \"windchill_c\": 28.7,\n            \"windchill_f\": 83.7,\n            \"heatindex_c\": 30.5,\n            \"heatindex_f\": 86.9,\n            \"dewpoint_c\": 19.6,\n            \"dewpoint_f\": 67.3,\n            \"will_it_rain\": 0,\n            \"chance_of_rain\": 0,\n            \"will_it_snow\": 0,\n            \"chance_of_snow\": 0,\n            \"vis_km\": 10,\n            \"vis_miles\": 6,\n            \"gust_mph\": 15,\n            \"gust_kph\": 24.1,\n            \"sig_ht_mt\": 24.1,\n            \"swell_ht_mt\": 24.1,\n            \"swell_ht_ft\": 24.1,\n            \"swell_dir\": 24.1,\n            \"swell_dir_16_point\": 24.1,\n            \"swell_period_secs\": 24.1,\n            \"uv\": 1\n          }\n        ]\n      }\n    ]\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "marine.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "marine.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "marine.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "days",
                  "value": "{{days}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "unixdt",
                  "value": "{{unixdt}}"
                },
                {
                  "key": "hour",
                  "value": "{{hour}}"
                },
                {
                  "key": "lang",
                  "value": "{{lang}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for marine.json?q={{q}}&days={{days}}&dt={{dt}}&unixdt={{unixdt}}&hour={{hour}}&lang={{lang}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: forecast\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'forecast')) {\n            pm.test(`'responseData field has forecast that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`forecast`)) {\n                const value = responseData?.forecast;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        }\n        // array condition and parent property is not an array\n        pm.test('Response has the forecastday field of type array', function() {\n          if (pm.expect(responseData).to.have.nested.property('forecastday')) {\n            const value = responseData?.forecastday;\n\n            if (value !== null && value !== undefined) {\n              pm.expect(Array.isArray(value)).to.equal(true);\n            }\n\n          }\n        })\n\n        pm.test(`Each object in the responseData.forecast.forecastday field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData.forecast).to.have.nested.property(`forecastday`)) {\n            let forecastdayArray = ld.get(responseData.forecast, `forecastday`, []);\n            if (Array.isArray(forecastdayArray)) {\n              for (let forecastday_it = 0; forecastday_it < forecastdayArray.length; forecastday_it++) {\n                let iterator = forecastday_it;\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date' as type 'string'`, function() {\n                    const value = forecastdayArray[iterator]?.date;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                  pm.test('forecastdayArray[${iterator}] format to be date', function() {\n                    const value = ld.get(responseData, `forecastdayArray[iterator]`, null);\n                    if (value !== null && value !== undefined && typeof value === 'string') {\n                      pm.expect(value).to.match(/^d{4}-d{2}-d{2}$/);\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'date_epoch' as type 'number'`, function() {\n                    const value = forecastdayArray[iterator]?.date_epoch;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'day' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.day;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.maxtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: mintemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has mintemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`mintemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.mintemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_c\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_c that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_c`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_c;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgtemp_f\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgtemp_f that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgtemp_f`)) {\n                      const value = forecastdayArray[iterator].day?.avgtemp_f;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_mph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_mph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_mph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_mph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: maxwind_kph\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has maxwind_kph that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`maxwind_kph`)) {\n                      const value = forecastdayArray[iterator].day?.maxwind_kph;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_mm\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_mm that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_mm`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_mm;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: totalprecip_in\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has totalprecip_in that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`totalprecip_in`)) {\n                      const value = forecastdayArray[iterator].day?.totalprecip_in;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_km\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_km that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_km`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_km;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avgvis_miles\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avgvis_miles that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avgvis_miles`)) {\n                      const value = forecastdayArray[iterator].day?.avgvis_miles;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: avghumidity\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has avghumidity that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`avghumidity`)) {\n                      const value = forecastdayArray[iterator].day?.avghumidity;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_rain\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_rain that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_rain`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_rain;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_will_it_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_will_it_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_will_it_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_will_it_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: daily_chance_of_snow\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has daily_chance_of_snow that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`daily_chance_of_snow`)) {\n                      const value = forecastdayArray[iterator].day?.daily_chance_of_snow;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: condition\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has condition that is of type object'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`condition`)) {\n                      const value = forecastdayArray[iterator].day?.condition;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: text\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has text that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`text`)) {\n                      const value = forecastdayArray[iterator].day.condition?.text;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: icon\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has icon that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                      const value = forecastdayArray[iterator].day.condition?.icon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day.condition\n                  // subKey: code\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day.condition field has code that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day.condition;\n                    if (pm.expect(parent).to.have.nested.property(`code`)) {\n                      const value = forecastdayArray[iterator].day.condition?.code;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].day\n                  // subKey: uv\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].day field has uv that is of type number'`, function() {\n                    let parent = forecastdayArray[iterator].day;\n                    if (pm.expect(parent).to.have.nested.property(`uv`)) {\n                      const value = forecastdayArray[iterator].day?.uv;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'astro' as type 'object'`, function() {\n                    const value = forecastdayArray[iterator]?.astro;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                      const value = forecastdayArray[iterator].astro?.sunrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: sunset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has sunset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                      const value = forecastdayArray[iterator].astro?.sunset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonrise\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonrise that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                      const value = forecastdayArray[iterator].astro?.moonrise;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moonset\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moonset that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                      const value = forecastdayArray[iterator].astro?.moonset;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_phase\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_phase that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_phase;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: forecastdayArray[${iterator}].astro\n                  // subKey: moon_illumination\n                  // array: forecastdayArray\n\n                  pm.test(`'forecastdayArray[${iterator}].astro field has moon_illumination that is of type string'`, function() {\n                    let parent = forecastdayArray[iterator].astro;\n                    if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                      const value = forecastdayArray[iterator].astro?.moon_illumination;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (forecastdayArray[forecastday_it] !== null && forecastdayArray[forecastday_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at forecastdayArray[${iterator}]' has 'hour' as type array'`, function() {\n                    const value = forecastdayArray[iterator]?.hour;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the forecastdayArray[${iterator}].hour field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(forecastdayArray[iterator]).to.have.nested.property(`hour`)) {\n                      let hourArray = ld.get(forecastdayArray[iterator], `hour`, []);\n                      if (Array.isArray(hourArray)) {\n                        for (let hour_it = 0; hour_it < hourArray.length; hour_it++) {\n                          let iterator = hour_it;\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time_epoch' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.time_epoch;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'time' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.time;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'temp_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.temp_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'is_day' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.is_day;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'condition' as type 'object'`, function() {\n                              const value = hourArray[iterator]?.condition;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: text\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has text that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`text`)) {\n                                const value = hourArray[iterator].condition?.text;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: icon\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has icon that is of type string'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`icon`)) {\n                                const value = hourArray[iterator].condition?.icon;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: hourArray[${iterator}].condition\n                            // subKey: code\n                            // array: hourArray\n\n                            pm.test(`'hourArray[${iterator}].condition field has code that is of type number'`, function() {\n                              let parent = hourArray[iterator].condition;\n                              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                                const value = hourArray[iterator].condition?.code;\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_degree' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.wind_degree;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'wind_dir' as type 'string'`, function() {\n                              const value = hourArray[iterator]?.wind_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_mb' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_mb;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'pressure_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.pressure_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_mm' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_mm;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'precip_in' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.precip_in;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'humidity' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.humidity;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'cloud' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.cloud;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'feelslike_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.feelslike_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'windchill_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.windchill_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'heatindex_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.heatindex_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_c' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_c;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'dewpoint_f' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.dewpoint_f;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_rain' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_rain;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'will_it_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.will_it_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'chance_of_snow' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.chance_of_snow;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_km' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_km;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'vis_miles' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.vis_miles;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_mph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_mph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'gust_kph' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.gust_kph;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'sig_ht_mt' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.sig_ht_mt;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_ht_mt' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_ht_mt;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_ht_ft' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_ht_ft;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_dir' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_dir;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_dir_16_point' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_dir_16_point;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'swell_period_secs' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.swell_period_secs;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (hourArray[hour_it] !== null && hourArray[hour_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at hourArray[${iterator}]' has 'uv' as type 'number'`, function() {\n                              const value = hourArray[iterator]?.uv;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Search/Autocomplete API",
      "request": {
        "name": "Search/Autocomplete API",
        "description": {
          "content": "WeatherAPI.com Search or Autocomplete API returns matching cities and towns as an array of Location object.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "search.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "search.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"id\": 2796590,\n    \"name\": \"Holborn\",\n    \"region\": \"Camden Greater London\",\n    \"country\": \"United Kingdom\",\n    \"lat\": 51.52,\n    \"lon\": -0.12,\n    \"url\": \"holborn-camden-greater-london-united-kingdom\"\n  },\n  {\n    \"id\": 2796590,\n    \"name\": \"Holborn\",\n    \"region\": \"Camden Greater London\",\n    \"country\": \"United Kingdom\",\n    \"lat\": 51.52,\n    \"lon\": -0.12,\n    \"url\": \"holborn-camden-greater-london-united-kingdom\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "search.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "search.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "search.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for search.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: id\n                let requiredField = false\n                if (requiredField || ld.get(item, 'id')) {\n                  pm.test(`'item field has id that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`id`)) {\n                      const value = item?.id;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: name\n                let requiredField = false\n                if (requiredField || ld.get(item, 'name')) {\n                  pm.test(`'item field has name that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`name`)) {\n                      const value = item?.name;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: region\n                let requiredField = false\n                if (requiredField || ld.get(item, 'region')) {\n                  pm.test(`'item field has region that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`region`)) {\n                      const value = item?.region;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: country\n                let requiredField = false\n                if (requiredField || ld.get(item, 'country')) {\n                  pm.test(`'item field has country that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`country`)) {\n                      const value = item?.country;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: lat\n                let requiredField = false\n                if (requiredField || ld.get(item, 'lat')) {\n                  pm.test(`'item field has lat that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                      const value = item?.lat;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: lon\n                let requiredField = false\n                if (requiredField || ld.get(item, 'lon')) {\n                  pm.test(`'item field has lon that is of type number'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                      const value = item?.lon;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                }\n              } {\n                // Condition: Raw data type and parent property is not an array\n                // pathStr: item\n                // subKey: url\n                let requiredField = false\n                if (requiredField || ld.get(item, 'url')) {\n                  pm.test(`'item field has url that is of type string'`, function() {\n                    let parent = item;\n                    if (pm.expect(parent).to.have.nested.property(`url`)) {\n                      const value = item?.url;\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n              }\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "IP Lookup API",
      "request": {
        "name": "IP Lookup API",
        "description": {
          "content": "IP Lookup API method allows a user to get up to date information for an IP address.",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "ip.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass IP address."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "ip.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"ip\": \"185.249.71.82\",\n  \"type\": \"ipv4\",\n  \"continent_code\": \"EU\",\n  \"continent_name\": \"Europe\",\n  \"country_code\": \"GB\",\n  \"country_name\": \"United Kingdom\",\n  \"is_eu\": \"string\",\n  \"geoname_id\": 2643743,\n  \"city\": \"London\",\n  \"region\": \"string\",\n  \"lat\": 51.5264,\n  \"lon\": -0.0841,\n  \"tz_id\": \"Europe/London\",\n  \"localtime_epoch\": 1658520645,\n  \"localtime\": \"2022-07-22 21:10\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "ip.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "ip.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "ip.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for ip.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: ip\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'ip')) {\n            pm.test(`'responseData field has ip that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`ip`)) {\n                const value = responseData?.ip;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: type\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'type')) {\n            pm.test(`'responseData field has type that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`type`)) {\n                const value = responseData?.type;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: continent_code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'continent_code')) {\n            pm.test(`'responseData field has continent_code that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`continent_code`)) {\n                const value = responseData?.continent_code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: continent_name\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'continent_name')) {\n            pm.test(`'responseData field has continent_name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`continent_name`)) {\n                const value = responseData?.continent_name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country_code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'country_code')) {\n            pm.test(`'responseData field has country_code that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country_code`)) {\n                const value = responseData?.country_code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country_name\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'country_name')) {\n            pm.test(`'responseData field has country_name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country_name`)) {\n                const value = responseData?.country_name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: is_eu\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'is_eu')) {\n            pm.test(`'responseData field has is_eu that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`is_eu`)) {\n                const value = responseData?.is_eu;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: geoname_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'geoname_id')) {\n            pm.test(`'responseData field has geoname_id that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`geoname_id`)) {\n                const value = responseData?.geoname_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: city\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'city')) {\n            pm.test(`'responseData field has city that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`city`)) {\n                const value = responseData?.city;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'region')) {\n            pm.test(`'responseData field has region that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'lat')) {\n            pm.test(`'responseData field has lat that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'lon')) {\n            pm.test(`'responseData field has lon that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'tz_id')) {\n            pm.test(`'responseData field has tz_id that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'localtime_epoch')) {\n            pm.test(`'responseData field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'localtime')) {\n            pm.test(`'responseData field has localtime that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Time Zone API",
      "request": {
        "name": "Time Zone API",
        "description": {
          "content": "Return Location Object",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "timezone.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "timezone.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"name\": \"New York\",\n  \"region\": \"New York\",\n  \"country\": \"United States of America\",\n  \"lat\": 40.71,\n  \"lon\": -74.01,\n  \"tz_id\": \"America/New_York\",\n  \"localtime_epoch\": 1658522976,\n  \"localtime\": \"2022-07-22 16:49\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "timezone.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "timezone.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "timezone.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for timezone.json?q={{q}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'name')) {\n            pm.test(`'responseData field has name that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'region')) {\n            pm.test(`'responseData field has region that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'country')) {\n            pm.test(`'responseData field has country that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'lat')) {\n            pm.test(`'responseData field has lat that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'lon')) {\n            pm.test(`'responseData field has lon that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'tz_id')) {\n            pm.test(`'responseData field has tz_id that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'localtime_epoch')) {\n            pm.test(`'responseData field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'localtime')) {\n            pm.test(`'responseData field has localtime that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Astronomy API",
      "request": {
        "name": "Astronomy API",
        "description": {
          "content": "Return Location and Astronomy Object",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "astronomy.json"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [
            {
              "disabled": false,
              "key": "q",
              "value": "{{q}}",
              "description": "(Required) Pass US Zipcode, UK Postcode, Canada Postalcode, IP address, Latitude/Longitude (decimal degree) or city name. Visit [request parameter section](https://www.weatherapi.com/docs/#intro-request) to learn more."
            },
            {
              "disabled": false,
              "key": "dt",
              "value": "{{dt}}",
              "description": "(Required) Date on or after 1st Jan, 2015 in yyyy-MM-dd format"
            }
          ],
          "variable": []
        },
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "GET",
        "auth": {
          "type": "apikey",
          "apikey": [
            {
              "key": "key",
              "value": "key"
            },
            {
              "key": "value",
              "value": "{{apiKey}}"
            },
            {
              "key": "in",
              "value": "query"
            }
          ]
        }
      },
      "response": [
        {
          "name": "Ok",
          "originalRequest": {
            "url": {
              "path": [
                "astronomy.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"location\": {\n    \"name\": \"New York\",\n    \"region\": \"New York\",\n    \"country\": \"United States of America\",\n    \"lat\": 40.71,\n    \"lon\": -74.01,\n    \"tz_id\": \"America/New_York\",\n    \"localtime_epoch\": 1658522976,\n    \"localtime\": \"2022-07-22 16:49\"\n  },\n  \"astronomy\": {\n    \"astro\": {\n      \"sunrise\": \"05:10 AM\",\n      \"sunset\": \"09:03 PM\",\n      \"moonrise\": \"12:29 AM\",\n      \"moonset\": \"04:01 PM\",\n      \"moon_phase\": \"Third Quarter\",\n      \"moon_illumination\": \"string\"\n    }\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.",
          "originalRequest": {
            "url": {
              "path": [
                "astronomy.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Bad Request",
          "code": 400,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1003,\n  \"message\": \"Parameter 'q' not provided.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid",
          "originalRequest": {
            "url": {
              "path": [
                "astronomy.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 1002,\n  \"message\": \"API key not provided\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.",
          "originalRequest": {
            "url": {
              "path": [
                "astronomy.json"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "{{q}}"
                },
                {
                  "key": "dt",
                  "value": "{{dt}}"
                },
                {
                  "key": "key",
                  "value": "{{key}}"
                }
              ],
              "variable": []
            },
            "header": [
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "GET",
            "body": {}
          },
          "status": "Forbidden",
          "code": 403,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"code\": 2007,\n  \"message\": \"API key has exceeded calls per month quota.\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test weather_api_test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for astronomy.json?q={{q}}&dt={{dt}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Ok\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: location\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'location')) {\n            pm.test(`'responseData field has location that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`location`)) {\n                const value = responseData?.location;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: name\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'name')) {\n            pm.test(`'responseData.location field has name that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`name`)) {\n                const value = responseData.location?.name;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: region\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'region')) {\n            pm.test(`'responseData.location field has region that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`region`)) {\n                const value = responseData.location?.region;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: country\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'country')) {\n            pm.test(`'responseData.location field has country that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`country`)) {\n                const value = responseData.location?.country;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lat\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lat')) {\n            pm.test(`'responseData.location field has lat that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lat`)) {\n                const value = responseData.location?.lat;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: lon\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'lon')) {\n            pm.test(`'responseData.location field has lon that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`lon`)) {\n                const value = responseData.location?.lon;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: tz_id\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'tz_id')) {\n            pm.test(`'responseData.location field has tz_id that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`tz_id`)) {\n                const value = responseData.location?.tz_id;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime_epoch\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime_epoch')) {\n            pm.test(`'responseData.location field has localtime_epoch that is of type number'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime_epoch`)) {\n                const value = responseData.location?.localtime_epoch;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.location\n          // subKey: localtime\n          let requiredField = false\n          if (requiredField || ld.get(responseData.location, 'localtime')) {\n            pm.test(`'responseData.location field has localtime that is of type string'`, function() {\n              let parent = responseData.location;\n              if (pm.expect(parent).to.have.nested.property(`localtime`)) {\n                const value = responseData.location?.localtime;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: astronomy\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'astronomy')) {\n            pm.test(`'responseData field has astronomy that is of type object'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`astronomy`)) {\n                const value = responseData?.astronomy;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy\n          // subKey: astro\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy, 'astro')) {\n            pm.test(`'responseData.astronomy field has astro that is of type object'`, function() {\n              let parent = responseData.astronomy;\n              if (pm.expect(parent).to.have.nested.property(`astro`)) {\n                const value = responseData.astronomy?.astro;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"object\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: sunrise\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'sunrise')) {\n            pm.test(`'responseData.astronomy.astro field has sunrise that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`sunrise`)) {\n                const value = responseData.astronomy.astro?.sunrise;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: sunset\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'sunset')) {\n            pm.test(`'responseData.astronomy.astro field has sunset that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`sunset`)) {\n                const value = responseData.astronomy.astro?.sunset;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moonrise\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'moonrise')) {\n            pm.test(`'responseData.astronomy.astro field has moonrise that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moonrise`)) {\n                const value = responseData.astronomy.astro?.moonrise;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moonset\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'moonset')) {\n            pm.test(`'responseData.astronomy.astro field has moonset that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moonset`)) {\n                const value = responseData.astronomy.astro?.moonset;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moon_phase\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'moon_phase')) {\n            pm.test(`'responseData.astronomy.astro field has moon_phase that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moon_phase`)) {\n                const value = responseData.astronomy.astro?.moon_phase;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData.astronomy.astro\n          // subKey: moon_illumination\n          let requiredField = false\n          if (requiredField || ld.get(responseData.astronomy.astro, 'moon_illumination')) {\n            pm.test(`'responseData.astronomy.astro field has moon_illumination that is of type string'`, function() {\n              let parent = responseData.astronomy.astro;\n              if (pm.expect(parent).to.have.nested.property(`moon_illumination`)) {\n                const value = responseData.astronomy.astro?.moon_illumination;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 400 && statusMatches) {\n  pm.test(\"Error code 1003: Parameter 'q' not provided.<br />Error code 1005: API request url is invalid.<br />Error code 1006: No location found matching parameter 'q'<br />Error code 9000: Json body passed in bulk request is invalid. Please make sure it is valid json with utf-8 encoding.<br />Error code 9001: Json body contains too many locations for bulk request. Please keep it below 50 in a single request.<br />Error code 9999: Internal application error.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error code 1002: API key not provided.<br />Error code 2006: API key provided is invalid\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 403 && statusMatches) {\n  pm.test(\"Error code 2007: API key has exceeded calls per month quota.<br />Error code 2008: API key has been disabled.<br />Error code 2009: API key does not have access to the resource. Please check pricing page for what is allowed in your API subscription plan.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: code\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'code')) {\n            pm.test(`'responseData field has code that is of type number'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`code`)) {\n                const value = responseData?.code;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"number\");\n                }\n              }\n            })\n\n          }\n        } {\n          // Condition: Raw data type and parent property is not an array\n          // pathStr: responseData\n          // subKey: message\n          let requiredField = false\n          if (requiredField || ld.get(responseData, 'message')) {\n            pm.test(`'responseData field has message that is of type string'`, function() {\n              let parent = responseData;\n              if (pm.expect(parent).to.have.nested.property(`message`)) {\n                const value = responseData?.message;\n\n                if (!ld.isEmpty(value)) {\n                  pm.expect(typeof value).to.equal(\"string\");\n                }\n              }\n            })\n\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://api.weatherapi.com/v1",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "info": {
    "_postman_id": "b0d2e8c0-10d1-42d3-9142-736ac52e52a1",
    "name": "Weather API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "# Introduction\nWeatherAPI.com provides access to weather and geo data via a JSON/XML restful API. It allows developers to create desktop, web and mobile applications using this data very easy. We provide following data through our API:    \n- Real-time weather\n- 14 day weather forecast\n- Historical Weather\n- Marine Weather and Tide Data\n- Future Weather (Upto 365 days ahead)\n- Daily and hourly intervals\n- 15 min interval (Enterprise only)\n- Astronomy\n- Time zone\n- Location data\n- Sports\n- Search or Autocomplete API\n- Weather Alerts\n- Air Quality Data\n- Bulk Request\n\n# Getting Started  \n\nYou need to [signup](https://www.weatherapi.com/signup.aspx) and then you can find your API key under [your account](https://www.weatherapi.com/login.aspx), and start using API right away!\n\nTry our weather API by using interactive [API Explorer](https://www.weatherapi.com/api-explorer.aspx).\n\nWe also have SDK for popular framework/languages available on [Github](https://github.com/weatherapicom/) for quick integrations.\n\nIf you find any features missing or have any suggestions, please [contact us](https://www.weatherapi.com/contact.aspx).  \n\n# Authentication  \n\nAPI access to the data is protected by an API key. If at anytime, you find the API key has become vulnerable, please regenerate the key using Regenerate button next to the API key.  \n\nAuthentication to the WeatherAPI.com API is provided by passing your API key as request parameter through an API .    \n\n##  key parameter \nkey=YOUR API KEY",
      "type": "text/plain"
    }
  }
}