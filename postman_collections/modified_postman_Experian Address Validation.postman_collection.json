{
  "info": {
    "_postman_id": "2c81dbd3-a7eb-4274-baaf-676998e98c36",
    "name": "Experian Address Validation",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "_exporter_id": "9786005"
  },
  "item": [
    {
      "name": "address",
      "item": [
        {
          "name": "format/v1/:global_address_key",
          "item": [
            {
              "name": "Format the address with the supplied key.",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  },
                  {
                    "description": "Specifies if the response should contain the address broken down into its components.",
                    "key": "Add-Components",
                    "value": "{{Add-Components}}"
                  },
                  {
                    "description": "Specify whether the response should return all fields and values, in addition to the main core information.",
                    "key": "Add-Metadata",
                    "value": "{{Add-Metadata}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/address/format/v1/:global_address_key",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "format",
                    "v1",
                    ":global_address_key"
                  ],
                  "variable": [
                    {
                      "key": "global_address_key",
                      "value": "{{global_address_key}}",
                      "description": "(Required) Global address key."
                    }
                  ]
                }
              },
              "response": [
                {
                  "name": "Success",
                  "originalRequest": {
                    "method": "GET",
                    "header": [
                      {
                        "description": "Your unique key, called a token, that is required to submit an API request.",
                        "key": "Auth-Token",
                        "value": ""
                      },
                      {
                        "description": "Alternative Auth Token header.",
                        "key": "x-app-key",
                        "value": ""
                      },
                      {
                        "description": "Optional identifier that will be returned in the response to help you track the request.",
                        "key": "Reference-Id",
                        "value": ""
                      },
                      {
                        "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                        "key": "Timeout-Seconds",
                        "value": ""
                      },
                      {
                        "description": "Specifies if the response should contain the address broken down into its components.",
                        "key": "Add-Components",
                        "value": "{{Add-Components}}"
                      },
                      {
                        "description": "Specify whether the response should return all fields and values, in addition to the main core information.",
                        "key": "Add-Metadata",
                        "value": "{{Add-Metadata}}"
                      }
                    ],
                    "url": {
                      "raw": "{{baseUrl}}/address/format/v1/:global_address_key",
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "path": [
                        "address",
                        "format",
                        "v1",
                        ":global_address_key"
                      ],
                      "variable": [
                        {
                          "key": "global_address_key",
                          "value": "{{global_address_key}}",
                          "description": "(Required) Global address key."
                        }
                      ]
                    }
                  },
                  "status": "OK",
                  "code": 200,
                  "_postman_previewlanguage": "json",
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "cookie": [],
                  "body": "{\n  \"result\": {\n    \"global_address_key\": \"QVVTfjcuNzMwak9BVVNIQXpsQndBQUFBQUJBd0VBQUFBQk9uQ09FWUFoQUFJUUNDQUFBQUFBQVFBMk5UUTVBRFlBQVAuLlFnQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBVENBMk5UUTVJRk4wSUV0cGJHUmhJRkprSURVME9RQUFBQUFBfjIy\",\n    \"confidence\": \"Verified match\",\n    \"address\": {\n      \"address_line_1\": \"L 6  549 St Kilda Rd\",\n      \"address_line_2\": \"\",\n      \"address_line_3\": \"\",\n      \"locality\": \"MELBOURNE\",\n      \"region\": \"VIC\",\n      \"postal_code\": \"3004\",\n      \"country\": \"AUSTRALIA\"\n    },\n    \"components\": {\n      \"country_name\": \"AUSTRALIA\",\n      \"country_iso_3\": \"AUS\",\n      \"country_iso_2\": \"AU\",\n      \"postal_code\": {\n        \"full_name\": \"3004\",\n        \"primary\": \"3004\"\n      },\n      \"sub_building\": {\n        \"floor\": {\n          \"full_name\": \"L 6\",\n          \"type\": \"L\",\n          \"value\": \"6\"\n        }\n      },\n      \"building\": {\n        \"building_number\": \"549\"\n      },\n      \"street\": {\n        \"full_name\": \"St Kilda Rd\",\n        \"name\": \"St Kilda\",\n        \"type\": \"Rd\"\n      },\n      \"locality\": {\n        \"town\": {\n          \"name\": \"MELBOURNE\"\n        }\n      }\n    }\n  },\n  \"metadata\": {\n    \"address_info\": {\n      \"identifier\": {\n        \"dpid\": \"62147712\",\n        \"hin\": \"203060068\"\n      }\n    },\n    \"barcode\": {\n      \"delivery_point_barcode\": \"1301012002011121210102312002130231113\",\n      \"sort_plan_number\": \"022\"\n    },\n    \"address_classification\": {\n      \"delivery_type\": \"Business\"\n    }\n  }\n}"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/format/v1/{global_address_key} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.global_address_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.global_address_key`)) {\n                    const value = ld.get(jsonResponse, `result.global_address_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.global_address_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address`)) {\n                    const value = ld.get(jsonResponse, `result.address`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.address:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_1` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_1`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_1`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.address_line_1:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_2`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_3` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_3`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.locality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.locality`)) {\n                    const value = ld.get(jsonResponse, `result.address.locality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.locality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.region`)) {\n                    const value = ld.get(jsonResponse, `result.address.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.postal_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.postal_code`)) {\n                    const value = ld.get(jsonResponse, `result.address.postal_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.postal_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.country`)) {\n                    const value = ld.get(jsonResponse, `result.address.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components`)) {\n                    const value = ld.get(jsonResponse, `result.components`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_name`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_iso_3` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_iso_3`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_iso_3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_3 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_3 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_iso_3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_iso_2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_iso_2`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_iso_2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_iso_2:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_2 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_2`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_iso_2:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_2 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_2`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_iso_2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.postal_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.postal_code`)) {\n                    const value = ld.get(jsonResponse, `result.components.postal_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.postal_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.sub_building` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.sub_building`)) {\n                    const value = ld.get(jsonResponse, `result.components.sub_building`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.sub_building:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.building` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.building`)) {\n                    const value = ld.get(jsonResponse, `result.components.building`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.building:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.street` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.street`)) {\n                    const value = ld.get(jsonResponse, `result.components.street`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.street:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.locality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.locality`)) {\n                    const value = ld.get(jsonResponse, `result.components.locality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.locality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata`)) {\n                    const value = ld.get(jsonResponse, `metadata`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_info` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_info`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_info`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_info:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_info.identifier` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_info.identifier`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_info.identifier`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_info.identifier:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.barcode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode.delivery_point_barcode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode.delivery_point_barcode`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode.delivery_point_barcode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.delivery_point_barcode length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.delivery_point_barcode`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.delivery_point_barcode length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.delivery_point_barcode`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode.sort_plan_number` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode.sort_plan_number`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode.sort_plan_number`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.sort_plan_number length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.sort_plan_number`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.sort_plan_number length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.sort_plan_number`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_classification` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_classification`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_classification`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_classification:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_classification.delivery_type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_classification.delivery_type`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_classification.delivery_type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.address_classification.delivery_type length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.address_classification.delivery_type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.address_classification.delivery_type length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.address_classification.delivery_type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ]
            },
            {
              "name": "Format the address with the supplied key using a custom layout.",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  },
                  {
                    "description": "Specifies if the response should contain the address broken down into its components.",
                    "key": "Add-Components",
                    "value": "{{Add-Components}}"
                  },
                  {
                    "description": "Specify whether the response should return all fields and values, in addition to the main core information.",
                    "key": "Add-Metadata",
                    "value": "{{Add-Metadata}}"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"layouts\": [\n        \"{{layouts_0_*string}}\"\n    ],\n    \"layout_format\": \"{{layout_format_*string}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/format/v1/:global_address_key",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "format",
                    "v1",
                    ":global_address_key"
                  ],
                  "variable": [
                    {
                      "key": "global_address_key",
                      "value": "{{global_address_key}}",
                      "description": "(Required) Global address key."
                    }
                  ]
                }
              },
              "response": [
                {
                  "name": "Success",
                  "originalRequest": {
                    "method": "POST",
                    "header": [
                      {
                        "description": "Your unique key, called a token, that is required to submit an API request.",
                        "key": "Auth-Token",
                        "value": ""
                      },
                      {
                        "description": "Alternative Auth Token header.",
                        "key": "x-app-key",
                        "value": ""
                      },
                      {
                        "description": "Optional identifier that will be returned in the response to help you track the request.",
                        "key": "Reference-Id",
                        "value": ""
                      },
                      {
                        "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                        "key": "Timeout-Seconds",
                        "value": ""
                      },
                      {
                        "description": "Specifies if the response should contain the address broken down into its components.",
                        "key": "Add-Components",
                        "value": "{{Add-Components}}"
                      },
                      {
                        "description": "Specify whether the response should return all fields and values, in addition to the main core information.",
                        "key": "Add-Metadata",
                        "value": "{{Add-Metadata}}"
                      }
                    ],
                    "body": {
                      "mode": "raw",
                      "raw": "{\n    \"layouts\": [\n        \"{{layouts_0_*string}}\"\n    ],\n    \"layout_format\": \"{{layout_format_*string}}\"\n}",
                      "options": {
                        "raw": {
                          "language": "json"
                        }
                      }
                    },
                    "url": {
                      "raw": "{{baseUrl}}/address/format/v1/:global_address_key",
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "path": [
                        "address",
                        "format",
                        "v1",
                        ":global_address_key"
                      ],
                      "variable": [
                        {
                          "key": "global_address_key",
                          "value": "{{global_address_key}}",
                          "description": "(Required) Global address key."
                        }
                      ]
                    }
                  },
                  "status": "OK",
                  "code": 200,
                  "_postman_previewlanguage": "json",
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "cookie": [],
                  "body": "{\n  \"result\": {\n    \"global_address_key\": \"QVVTfjcuNzMwak9BVVNIQXpsQndBQUFBQUJBd0VBQUFBQk9uQ09FWUFoQUFJUUNDQUFBQUFBQVFBMk5UUTVBRFlBQVAuLlFnQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBVENBMk5UUTVJRk4wSUV0cGJHUmhJRkprSURVME9RQUFBQUFBfjIy\",\n    \"confidence\": \"Verified match\",\n    \"address\": {\n      \"address_line_1\": \"L 6  549 St Kilda Rd\",\n      \"address_line_2\": \"\",\n      \"address_line_3\": \"\",\n      \"locality\": \"MELBOURNE\",\n      \"region\": \"VIC\",\n      \"postal_code\": \"3004\",\n      \"country\": \"AUSTRALIA\"\n    },\n    \"components\": {\n      \"country_name\": \"AUSTRALIA\",\n      \"country_iso_3\": \"AUS\",\n      \"country_iso_2\": \"AU\",\n      \"postal_code\": {\n        \"full_name\": \"3004\",\n        \"primary\": \"3004\"\n      },\n      \"sub_building\": {\n        \"floor\": {\n          \"full_name\": \"L 6\",\n          \"type\": \"L\",\n          \"value\": \"6\"\n        }\n      },\n      \"building\": {\n        \"building_number\": \"549\"\n      },\n      \"street\": {\n        \"full_name\": \"St Kilda Rd\",\n        \"name\": \"St Kilda\",\n        \"type\": \"Rd\"\n      },\n      \"locality\": {\n        \"town\": {\n          \"name\": \"MELBOURNE\"\n        }\n      }\n    }\n  },\n  \"metadata\": {\n    \"address_info\": {\n      \"identifier\": {\n        \"dpid\": \"62147712\",\n        \"hin\": \"203060068\"\n      }\n    },\n    \"barcode\": {\n      \"delivery_point_barcode\": \"1301012002011121210102312002130231113\",\n      \"sort_plan_number\": \"022\"\n    },\n    \"address_classification\": {\n      \"delivery_type\": \"Business\"\n    }\n  }\n}"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/format/v1/{global_address_key} for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.global_address_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.global_address_key`)) {\n                    const value = ld.get(jsonResponse, `result.global_address_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.global_address_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address`)) {\n                    const value = ld.get(jsonResponse, `result.address`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.address:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_1` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_1`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_1`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.address_line_1:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_2`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_3` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_3`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.locality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.locality`)) {\n                    const value = ld.get(jsonResponse, `result.address.locality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.locality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.region`)) {\n                    const value = ld.get(jsonResponse, `result.address.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.postal_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.postal_code`)) {\n                    const value = ld.get(jsonResponse, `result.address.postal_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.postal_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.country`)) {\n                    const value = ld.get(jsonResponse, `result.address.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.country:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components`)) {\n                    const value = ld.get(jsonResponse, `result.components`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_name` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_name`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_name`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_name:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_iso_3` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_iso_3`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_iso_3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_3 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_3 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_iso_3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.country_iso_2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.country_iso_2`)) {\n                    const value = ld.get(jsonResponse, `result.components.country_iso_2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.components.country_iso_2:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_2 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_2`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.components.country_iso_2:\", error.message);\n            }\n        })\n  \n        pm.test(`result.components.country_iso_2 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.components.country_iso_2`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.components.country_iso_2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.postal_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.postal_code`)) {\n                    const value = ld.get(jsonResponse, `result.components.postal_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.postal_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.sub_building` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.sub_building`)) {\n                    const value = ld.get(jsonResponse, `result.components.sub_building`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.sub_building:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.building` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.building`)) {\n                    const value = ld.get(jsonResponse, `result.components.building`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.building:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.street` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.street`)) {\n                    const value = ld.get(jsonResponse, `result.components.street`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.street:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.components.locality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.components.locality`)) {\n                    const value = ld.get(jsonResponse, `result.components.locality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.components.locality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata`)) {\n                    const value = ld.get(jsonResponse, `metadata`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_info` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_info`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_info`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_info:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_info.identifier` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_info.identifier`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_info.identifier`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_info.identifier:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.barcode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode.delivery_point_barcode` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode.delivery_point_barcode`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode.delivery_point_barcode`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.delivery_point_barcode length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.delivery_point_barcode`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.delivery_point_barcode length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.delivery_point_barcode`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.barcode.delivery_point_barcode:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.barcode.sort_plan_number` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.barcode.sort_plan_number`)) {\n                    const value = ld.get(jsonResponse, `metadata.barcode.sort_plan_number`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.sort_plan_number length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.sort_plan_number`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.barcode.sort_plan_number length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.barcode.sort_plan_number`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.barcode.sort_plan_number:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_classification` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_classification`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_classification`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field metadata.address_classification:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `metadata.address_classification.delivery_type` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`metadata.address_classification.delivery_type`)) {\n                    const value = ld.get(jsonResponse, `metadata.address_classification.delivery_type`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.address_classification.delivery_type length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.address_classification.delivery_type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n  \n        pm.test(`metadata.address_classification.delivery_type length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `metadata.address_classification.delivery_type`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for metadata.address_classification.delivery_type:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "suggestions",
          "item": [
            {
              "name": "Step into a suggestion.",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/address/suggestions/stepin/v1/:global_address_key",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "suggestions",
                    "stepin",
                    "v1",
                    ":global_address_key"
                  ],
                  "variable": [
                    {
                      "key": "global_address_key",
                      "value": "{{global_address_key}}",
                      "description": "(Required) Global address key."
                    }
                  ]
                }
              },
              "response": [
                {
                  "name": "Success",
                  "originalRequest": {
                    "method": "GET",
                    "header": [
                      {
                        "description": "Your unique key, called a token, that is required to submit an API request.",
                        "key": "Auth-Token",
                        "value": ""
                      },
                      {
                        "description": "Alternative Auth Token header.",
                        "key": "x-app-key",
                        "value": ""
                      },
                      {
                        "description": "Optional identifier that will be returned in the response to help you track the request.",
                        "key": "Reference-Id",
                        "value": ""
                      },
                      {
                        "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                        "key": "Timeout-Seconds",
                        "value": ""
                      }
                    ],
                    "url": {
                      "raw": "{{baseUrl}}/address/suggestions/stepin/v1/:global_address_key",
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "path": [
                        "address",
                        "suggestions",
                        "stepin",
                        "v1",
                        ":global_address_key"
                      ],
                      "variable": [
                        {
                          "key": "global_address_key",
                          "value": "{{global_address_key}}",
                          "description": "(Required) Global address key."
                        }
                      ]
                    }
                  },
                  "status": "OK",
                  "code": 200,
                  "_postman_previewlanguage": "json",
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "cookie": [],
                  "body": "{\n  \"result\": {\n    \"more_results_available\": false,\n    \"confidence\": \"Verified match\",\n    \"suggestions_key\": \"R0JSfjcuNzMwUk1HQlJGQWpsQndBQUFBQUJBUUVBQVFBQUFBQ0ltWHVSZ0NFd2doTUFJQUFBQUFBQkFFRndZWEowYldWdWRDQXhOUUEzT1FBQS4uOVFBQUFBQVAuLi4uOEFBQUFBQUFBQUFBQUFBQUFBQUEtLX40Mg\",\n    \"suggestions_prompt\": \"Enter selection\",\n    \"suggestions\": [\n      {\n        \"global_address_key\": \"R0JSfjcuNzMwVU9HQlJGQWpsQndBQUFBQUJBd0VBQUFBQWlKbDdrWUFoTUlJVEFDQUFBQUFBQVFCQmNHRnlkRzFsYm5RZ01UVUFOemtBQVAuLlVBQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBUVhCaGNuUnRaVzUwSURFMUxDQTNPU0JUZEdGMGFXOXVJRkp2WVdRc0lFdEZURlJaTENCR2FXWmxBQUFBQUFBLX40Mg\",\n        \"text\": \"Apartment 15, 79 Station Road, KELTY, Fife KY4 0BL\",\n        \"format\": \"https://api.experianaperture.io/address/format/v1/R0JSfjcuNzMwVU9HQlJGQWpsQndBQUFBQUJBd0VBQUFBQWlKbDdrWUFoTUlJVEFDQUFBQUFBQVFCQmNHRnlkRzFsYm5RZ01UVUFOemtBQVAuLlVBQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBUVhCaGNuUnRaVzUwSURFMUxDQTNPU0JUZEdGMGFXOXVJRkp2WVdRc0lFdEZURlJaTENCR2FXWmxBQUFBQUFBLX40Mg\",\n        \"additional_attributes\": [\n          {\n            \"name\": \"picklist_display\",\n            \"value\": \"Apartment 15, 79 Station Road, KELTY, Fife\"\n          },\n          {\n            \"name\": \"score\",\n            \"value\": \"100\"\n          },\n          {\n            \"name\": \"postcode\",\n            \"value\": \"KY4 0BL\"\n          }\n        ]\n      }\n    ]\n  }\n}"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/suggestions/stepin/v1/{global_address_key} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_key`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_prompt` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_prompt`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_prompt`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.suggestions[${suggestions_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'additional_attributes' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].additional_attributes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].additional_attributes`)) {\n                    let additional_attributesArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].additional_attributes`, []);\n                    if (Array.isArray(additional_attributesArray)) {\n                        for (let additional_attributes_it = 0; additional_attributes_it < additional_attributesArray.length; additional_attributes_it++) {\n                            let iterator = additional_attributes_it;\n                            if (additional_attributesArray[additional_attributes_it] !== null && additional_attributesArray[additional_attributes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value' has 'value' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ]
            },
            {
              "name": "Refine a suggestion.",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"refinement\": \"{{refinement_*string}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/suggestions/refine/v1/:key",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "suggestions",
                    "refine",
                    "v1",
                    ":key"
                  ],
                  "variable": [
                    {
                      "key": "key",
                      "value": "{{key}}",
                      "description": "(Required) Global_address_key or suggestions_key."
                    }
                  ]
                }
              },
              "response": [
                {
                  "name": "Success",
                  "originalRequest": {
                    "method": "POST",
                    "header": [
                      {
                        "description": "Your unique key, called a token, that is required to submit an API request.",
                        "key": "Auth-Token",
                        "value": ""
                      },
                      {
                        "description": "Alternative Auth Token header.",
                        "key": "x-app-key",
                        "value": ""
                      },
                      {
                        "description": "Optional identifier that will be returned in the response to help you track the request.",
                        "key": "Reference-Id",
                        "value": ""
                      },
                      {
                        "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                        "key": "Timeout-Seconds",
                        "value": ""
                      }
                    ],
                    "body": {
                      "mode": "raw",
                      "raw": "{\n    \"refinement\": \"{{refinement_*string}}\"\n}",
                      "options": {
                        "raw": {
                          "language": "json"
                        }
                      }
                    },
                    "url": {
                      "raw": "{{baseUrl}}/address/suggestions/refine/v1/:key",
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "path": [
                        "address",
                        "suggestions",
                        "refine",
                        "v1",
                        ":key"
                      ],
                      "variable": [
                        {
                          "key": "key",
                          "value": "{{key}}",
                          "description": "(Required) Global_address_key or suggestions_key."
                        }
                      ]
                    }
                  },
                  "status": "OK",
                  "code": 200,
                  "_postman_previewlanguage": "json",
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "cookie": [],
                  "body": "{\n  \"result\": {\n    \"more_results_available\": false,\n    \"confidence\": \"Verified match\",\n    \"suggestions_key\": \"R0JSfjcuNzMwUk1HQlJGQWpsQndBQUFBQUJBUUVBQVFBQUFBQ0ltWHVSZ0NFd2doTUFJQUFBQUFBQkFFRndZWEowYldWdWRDQXhOUUEzT1FBQS4uOVFBQUFBQVAuLi4uOEFBQUFBQUFBQUFBQUFBQUFBQUEtLX40Mg\",\n    \"suggestions_prompt\": \"Enter selection\",\n    \"suggestions\": [\n      {\n        \"global_address_key\": \"R0JSfjcuNzMwVU9HQlJGQWpsQndBQUFBQUJBd0VBQUFBQWlKbDdrWUFoTUlJVEFDQUFBQUFBQVFCQmNHRnlkRzFsYm5RZ01UVUFOemtBQVAuLlVBQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBUVhCaGNuUnRaVzUwSURFMUxDQTNPU0JUZEdGMGFXOXVJRkp2WVdRc0lFdEZURlJaTENCR2FXWmxBQUFBQUFBLX40Mg\",\n        \"text\": \"Apartment 15, 79 Station Road, KELTY, Fife KY4 0BL\",\n        \"format\": \"https://api.experianaperture.io/address/format/v1/R0JSfjcuNzMwVU9HQlJGQWpsQndBQUFBQUJBd0VBQUFBQWlKbDdrWUFoTUlJVEFDQUFBQUFBQVFCQmNHRnlkRzFsYm5RZ01UVUFOemtBQVAuLlVBQUFBQUQuLi4uLkFBQUFBQUFBQUFBQUFBQUFBQUFBUVhCaGNuUnRaVzUwSURFMUxDQTNPU0JUZEdGMGFXOXVJRkp2WVdRc0lFdEZURlJaTENCR2FXWmxBQUFBQUFBLX40Mg\",\n        \"additional_attributes\": [\n          {\n            \"name\": \"picklist_display\",\n            \"value\": \"Apartment 15, 79 Station Road, KELTY, Fife\"\n          },\n          {\n            \"name\": \"score\",\n            \"value\": \"100\"\n          },\n          {\n            \"name\": \"postcode\",\n            \"value\": \"KY4 0BL\"\n          }\n        ]\n      }\n    ]\n  }\n}"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/suggestions/refine/v1/{key} for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_key`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_prompt` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_prompt`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_prompt`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.suggestions[${suggestions_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'additional_attributes' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].additional_attributes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].additional_attributes`)) {\n                    let additional_attributesArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].additional_attributes`, []);\n                    if (Array.isArray(additional_attributesArray)) {\n                        for (let additional_attributes_it = 0; additional_attributes_it < additional_attributesArray.length; additional_attributes_it++) {\n                            let iterator = additional_attributes_it;\n                            if (additional_attributesArray[additional_attributes_it] !== null && additional_attributesArray[additional_attributes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value' has 'value' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ]
            },
            {
              "name": "Search and format a list of suggestions.",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  },
                  {
                    "description": "Specifies if the response should contain the address broken down into its components.",
                    "key": "Add-Components",
                    "value": "{{Add-Components}}"
                  },
                  {
                    "description": "Specify whether the response should return all fields and values, in addition to the main core information.",
                    "key": "Add-Metadata",
                    "value": "{{Add-Metadata}}"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"max_suggestions\": \"{{max_suggestions_*number}}\",\n    \"components\": {\n        \"unspecified\": [\n            \"{{components.unspecified_0_*string}}\"\n        ]\n    },\n    \"layouts\": [\n        \"{{layouts_0_*string}}\"\n    ]\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/suggestions/format/v1",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "suggestions",
                    "format",
                    "v1"
                  ]
                }
              },
              "response": [
                {
                  "name": "Success",
                  "originalRequest": {
                    "method": "POST",
                    "header": [
                      {
                        "description": "Your unique key, called a token, that is required to submit an API request.",
                        "key": "Auth-Token",
                        "value": ""
                      },
                      {
                        "description": "Alternative Auth Token header.",
                        "key": "x-app-key",
                        "value": ""
                      },
                      {
                        "description": "Optional identifier that will be returned in the response to help you track the request.",
                        "key": "Reference-Id",
                        "value": ""
                      },
                      {
                        "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                        "key": "Timeout-Seconds",
                        "value": ""
                      },
                      {
                        "description": "Specifies if the response should contain the address broken down into its components.",
                        "key": "Add-Components",
                        "value": "{{Add-Components}}"
                      },
                      {
                        "description": "Specify whether the response should return all fields and values, in addition to the main core information.",
                        "key": "Add-Metadata",
                        "value": "{{Add-Metadata}}"
                      }
                    ],
                    "body": {
                      "mode": "raw",
                      "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"max_suggestions\": \"{{max_suggestions_*number}}\",\n    \"components\": {\n        \"unspecified\": [\n            \"{{components.unspecified_0_*string}}\"\n        ]\n    },\n    \"layouts\": [\n        \"{{layouts_0_*string}}\"\n    ]\n}",
                      "options": {
                        "raw": {
                          "language": "json"
                        }
                      }
                    },
                    "url": {
                      "raw": "{{baseUrl}}/address/suggestions/format/v1",
                      "host": [
                        "{{baseUrl}}"
                      ],
                      "path": [
                        "address",
                        "suggestions",
                        "format",
                        "v1"
                      ]
                    }
                  },
                  "status": "OK",
                  "code": 200,
                  "_postman_previewlanguage": "json",
                  "header": [
                    {
                      "key": "Content-Type",
                      "value": "application/json"
                    }
                  ],
                  "cookie": [],
                  "body": "{\n  \"result\": {\n    \"more_results_available\": true,\n    \"confidence\": \"Multiple matches\",\n    \"suggestions\": [\n      {\n        \"global_address_key\": \"R0JSfjcuNzMwLk9HQlJFd3ZsQndBQUFBQUJBd0VBQUFBQm5JZVpVZ0FoRUFJQUFBQUFBQUFBQUFELi4yUUFBQUFBLi4uLi53QUFBQUFBQUFBQUFBQUFBQUFBQURFMk1Dd2dVMFV4SURoRldnQUFBQUFBfjEyfjI\",\n        \"addresses_formatted\": [\n          {\n            \"layout_name\": \"default_classic\",\n            \"address\": {\n              \"LINE_1\": \"Axon Communications\",\n              \"LINE_2\": \"160 Blackfriars Road\",\n              \"Town\": \"LONDON\",\n              \"County\": \"\",\n              \"Postcode\": \"SE1 8EZ\"\n            }\n          }\n        ]\n      },\n      {\n        \"global_address_key\": \"R0JSfjcuNzMwV09HQlJFd3ZsQndBQUFBQUJBd0VBQUFBQm5JZWJVZ0FoRUFJQUFBQUFBQUFBQUFELi4yUUFBQUFBLi4uLi53QUFBQUFBQUFBQUFBQUFBQUFBQURFMk1Dd2dVMFV4SURoRldnQUFBQUFBfjEyfjI\",\n        \"addresses_formatted\": [\n          {\n            \"layout_name\": \"default_classic\",\n            \"address\": {\n              \"LINE_1\": \"C Q G UK Ltd\",\n              \"LINE_2\": \"160 Blackfriars Road\",\n              \"Town\": \"LONDON\",\n              \"County\": \"\",\n              \"Postcode\": \"SE1 8EZ\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}"
                }
              ],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "exec": [
                      " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/suggestions/format/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'addresses_formatted' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].addresses_formatted`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].addresses_formatted:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].addresses_formatted length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].addresses_formatted`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].addresses_formatted:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].addresses_formatted length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].addresses_formatted`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].addresses_formatted:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].addresses_formatted field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].addresses_formatted`)) {\n                    let addresses_formattedArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].addresses_formatted`, []);\n                    if (Array.isArray(addresses_formattedArray)) {\n                        for (let addresses_formatted_it = 0; addresses_formatted_it < addresses_formattedArray.length; addresses_formatted_it++) {\n                            let iterator = addresses_formatted_it;\n                            if (addresses_formattedArray[addresses_formatted_it] !== null && addresses_formattedArray[addresses_formatted_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name' has 'layout_name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].layout_name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].address' has 'address' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].address`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].addresses_formatted[${addresses_formatted_it}].address:\", error.message);\n            }\n        })\n\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].addresses_formatted:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                    ],
                    "type": "text/javascript"
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Get the available datasets for the supplied country.",
          "request": {
            "method": "GET",
            "header": [
              {
                "description": "Your unique key, called a token, that is required to submit an API request.",
                "key": "Auth-Token",
                "value": ""
              },
              {
                "description": "Alternative Auth Token header.",
                "key": "x-app-key",
                "value": ""
              },
              {
                "description": "Optional identifier that will be returned in the response to help you track the request.",
                "key": "Reference-Id",
                "value": ""
              },
              {
                "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                "key": "Timeout-Seconds",
                "value": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/address/datasets/v1?country_iso=",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "address",
                "datasets",
                "v1"
              ],
              "query": [
                {
                  "key": "country_iso",
                  "value": "{{country_iso}}",
                  "description": "3-letter ISO code for country."
                }
              ]
            }
          },
          "response": [
            {
              "name": "Success",
              "originalRequest": {
                "method": "GET",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/address/datasets/v1?country_iso=",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "datasets",
                    "v1"
                  ],
                  "query": [
                    {
                      "key": "country_iso",
                      "value": "{{country_iso}}"
                    }
                  ]
                }
              },
              "status": "OK",
              "code": 200,
              "_postman_previewlanguage": "json",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "cookie": [],
              "body": "{\n  \"result\": [\n    {\n      \"country_iso_3\": \"AUS\",\n      \"country_name\": \"Australia\",\n      \"datasets\": [\n        {\n          \"id\": \"au-address\",\n          \"name\": \"Australia Postal Address\"\n        },\n        {\n          \"id\": \"au-address-beta\",\n          \"name\": \"Australia Postal Address\"\n        },\n        {\n          \"id\": \"au-address-datafusion\",\n          \"name\": \"Australia Enhanced Address\"\n        },\n        {\n          \"id\": \"au-address-gnaf\",\n          \"name\": \"Australia Geocoded National Address\"\n        },\n        {\n          \"id\": \"au-address-gnaf-beta\",\n          \"name\": \"Australia Geocoded National Address\"\n        }\n      ]\n    }\n  ]\n}"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/datasets/v1?country_iso={{country_iso}} for http method type get in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result:\", error.message);\n            }\n        })\n  \n        pm.test(`result length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result:\", error.message);\n            }\n        })\n  \n        pm.test(`result length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    let resultArray = ld.get(jsonResponse, `result`, []);\n                    if (Array.isArray(resultArray)) {\n                        for (let result_it = 0; result_it < resultArray.length; result_it++) {\n                            let iterator = result_it;\n                            if (resultArray[result_it] !== null && resultArray[result_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result[${result_it}].country_iso_3' has 'country_iso_3' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].country_iso_3 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].country_iso_3 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result[${result_it}].country_name' has 'country_name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].country_name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result[${result_it}].country_name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].country_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result[${result_it}].country_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].country_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].country_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result[${result_it}].country_name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultArray' has 'datasets' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result[${result_it}].datasets:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].datasets length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result[${result_it}].datasets:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].datasets length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result[${result_it}].datasets:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result[${result_it}].datasets field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result[${result_it}].datasets`)) {\n                    let datasetsArray = ld.get(jsonResponse, `result[${result_it}].datasets`, []);\n                    if (Array.isArray(datasetsArray)) {\n                        for (let datasets_it = 0; datasets_it < datasetsArray.length; datasets_it++) {\n                            let iterator = datasets_it;\n                            if (datasetsArray[datasets_it] !== null && datasetsArray[datasets_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result[${result_it}].datasets[${datasets_it}].id' has 'id' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].datasets[${datasets_it}].id`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result[${result_it}].datasets[${datasets_it}].id:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].datasets[${datasets_it}].id length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets[${datasets_it}].id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result[${result_it}].datasets[${datasets_it}].id:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].datasets[${datasets_it}].id length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets[${datasets_it}].id`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result[${result_it}].datasets[${datasets_it}].id:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result[${result_it}].datasets[${datasets_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].datasets[${datasets_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result[${result_it}].datasets[${datasets_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].datasets[${datasets_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets[${datasets_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result[${result_it}].datasets[${datasets_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].datasets[${datasets_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets[${datasets_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result[${result_it}].datasets[${datasets_it}].name:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result[${result_it}].datasets:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Get the available layouts for the supplied country.",
          "request": {
            "method": "POST",
            "header": [
              {
                "description": "Your unique key, called a token, that is required to submit an API request.",
                "key": "Auth-Token",
                "value": ""
              },
              {
                "description": "Alternative Auth Token header.",
                "key": "x-app-key",
                "value": ""
              },
              {
                "description": "Optional identifier that will be returned in the response to help you track the request.",
                "key": "Reference-Id",
                "value": ""
              },
              {
                "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                "key": "Timeout-Seconds",
                "value": ""
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/address/layouts/v1",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "address",
                "layouts",
                "v1"
              ]
            }
          },
          "response": [
            {
              "name": "Success",
              "originalRequest": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ]\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/layouts/v1",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "layouts",
                    "v1"
                  ]
                }
              },
              "status": "OK",
              "code": 200,
              "_postman_previewlanguage": "json",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "cookie": [],
              "body": "{\n  \"result\": [\n    {\n      \"name\": \"Default\",\n      \"country_iso_3\": \"AUS\",\n      \"datasets\": [\n        \"au-address-gnaf\"\n      ]\n    },\n    {\n      \"name\": \"JB Hifi\",\n      \"country_iso_3\": \"AUS\",\n      \"datasets\": [\n        \"au-address-gnaf\"\n      ]\n    },\n    {\n      \"name\": \"JB Hifi_all\",\n      \"country_iso_3\": \"AUS\",\n      \"datasets\": [\n        \"au-address-gnaf\"\n      ]\n    }\n  ]\n}"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/layouts/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result:\", error.message);\n            }\n        })\n  \n        pm.test(`result length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result:\", error.message);\n            }\n        })\n  \n        pm.test(`result length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    let resultArray = ld.get(jsonResponse, `result`, []);\n                    if (Array.isArray(resultArray)) {\n                        for (let result_it = 0; result_it < resultArray.length; result_it++) {\n                            let iterator = result_it;\n                            if (resultArray[result_it] !== null && resultArray[result_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result[${result_it}].name' has 'name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result[${result_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result[${result_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result[${result_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result[${result_it}].country_iso_3' has 'country_iso_3' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].country_iso_3 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].country_iso_3 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].country_iso_3`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result[${result_it}].country_iso_3:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'resultArray' has 'datasets' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result[${result_it}].datasets:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result[${result_it}].datasets length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result[${result_it}].datasets:\", error.message);\n            }\n        })\n  \n        pm.test(`result[${result_it}].datasets length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result[${result_it}].datasets`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result[${result_it}].datasets:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Lookup an address based on a key.",
          "request": {
            "method": "POST",
            "header": [
              {
                "description": "Your unique key, called a token, that is required to submit an API request.",
                "key": "Auth-Token",
                "value": ""
              },
              {
                "description": "Alternative Auth Token header.",
                "key": "x-app-key",
                "value": ""
              },
              {
                "description": "Optional identifier that will be returned in the response to help you track the request.",
                "key": "Reference-Id",
                "value": ""
              },
              {
                "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                "key": "Timeout-Seconds",
                "value": ""
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"key\": {\n        \"type\": \"{{key.type_*string}}\",\n        \"value\": \"{{key.value_*number}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/address/lookup/v1",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "address",
                "lookup",
                "v1"
              ]
            }
          },
          "response": [
            {
              "name": "Success",
              "originalRequest": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"key\": {\n        \"type\": \"{{key.type_*string}}\",\n        \"value\": \"{{key.value_*number}}\"\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/lookup/v1",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "lookup",
                    "v1"
                  ]
                }
              },
              "status": "OK",
              "code": 200,
              "_postman_previewlanguage": "json",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "cookie": [],
              "body": "{\n  \"result\": {\n    \"more_results_available\": false,\n    \"confidence\": \"Verified match\",\n    \"suggestions_key\": \"R0JHfjcuNzMweE1HQkdGQWpsQndBQUFBQUZBUUVBQVFBQUFBRXF4R2ZZQUNHUUFnQUFBQUFBQUFBQUFQLi5BQUFBQUFELi4uLi5BQUFBQUFBQUFBQUFBQUFBQUFBLX4xMA\",\n    \"suggestions_prompt\": \"Enter selection\",\n    \"suggestions\": [\n      {\n        \"global_address_key\": \"R0JHfjcuNzMwbk9HQkdGQWpsQndBQUFBQUZBd0VBQUFBQktzUm4yQUFoa0FJQUFBQUFBQUFBQUFELi53QUFBQUFBLi4uLi53QUFBQUFBQUFBQUFBQUFBQUFBQURJME9ERTRORGt6TURnQUFBQUFBQS0tfjEw\",\n        \"text\": \"6 Valley View, Highley, BRIDGNORTH, Shropshire WV16 6EF\",\n        \"format\": \"https://api.experianaperture.io/address/format/v1/R0JHfjcuNzMwbk9HQkdGQWpsQndBQUFBQUZBd0VBQUFBQktzUm4yQUFoa0FJQUFBQUFBQUFBQUFELi53QUFBQUFBLi4uLi53QUFBQUFBQUFBQUFBQUFBQUFBQURJME9ERTRORGt6TURnQUFBQUFBQS0tfjEw\",\n        \"additional_attributes\": [\n          {\n            \"name\": \"picklist_display\",\n            \"value\": \"6 Valley View, Highley, BRIDGNORTH, Shropshire\"\n          },\n          {\n            \"name\": \"postcode\",\n            \"value\": \"WV16 6EF\"\n          }\n        ]\n      }\n    ]\n  }\n}"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/lookup/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_key`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_prompt` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_prompt`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_prompt`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.suggestions[${suggestions_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'additional_attributes' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].additional_attributes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].additional_attributes`)) {\n                    let additional_attributesArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].additional_attributes`, []);\n                    if (Array.isArray(additional_attributesArray)) {\n                        for (let additional_attributes_it = 0; additional_attributes_it < additional_attributesArray.length; additional_attributes_it++) {\n                            let iterator = additional_attributes_it;\n                            if (additional_attributesArray[additional_attributes_it] !== null && additional_attributesArray[additional_attributes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value' has 'value' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Lookup an address based on a key V2",
          "request": {
            "method": "POST",
            "header": [
              {
                "description": "Your unique key, called a token, that is required to submit an API request.",
                "key": "Auth-Token",
                "value": ""
              },
              {
                "description": "Alternative Auth Token header.",
                "key": "x-app-key",
                "value": ""
              },
              {
                "description": "Optional identifier that will be returned in the response to help you track the request.",
                "key": "Reference-Id",
                "value": ""
              },
              {
                "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                "key": "Timeout-Seconds",
                "value": ""
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              },
              {
                "description": "A boolean, indicating if addresses should be added to the response.",
                "key": "Add-Addresses",
                "value": "{{Add-Addresses}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"max_addresses\": \"{{max_addresses_*number}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"key\": {\n        \"type\": \"{{key.type_*string}}\",\n        \"value\": \"{{key.value_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/address/lookup/v2",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "address",
                "lookup",
                "v2"
              ]
            }
          },
          "response": [
            {
              "name": "Success",
              "originalRequest": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"max_addresses\": \"{{max_addresses_*number}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"key\": {\n        \"type\": \"{{key.type_*string}}\",\n        \"value\": \"{{key.value_*string}}\"\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/lookup/v2",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "lookup",
                    "v2"
                  ]
                }
              },
              "status": "OK",
              "code": 200,
              "_postman_previewlanguage": "json",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "cookie": [],
              "body": "{\n    \"result\": {\n        \"more_results_available\": false,\n        \"confidence\": \"Multiple matches\",\n        \"suggestions\": [\n            {\n                \"locality\": {\n                    \"town\": {\n                        \"name\": \"London\"\n                    }\n                },\n                \"postal_code\": {\n                    \"full_name\": \"Wc2r 1La\"\n                }\n            }\n        ],\n        \"addresses\": [\n            {\n                \"text\": \"43 Matlock Court, Copley Close, London, W7 1EB\",\n                \"matched\": [\n                    [\n                        32,\n                        38\n                    ]\n                ],\n                \"global_address_key\": \"aWQ9NDMgTWF0bG9jayBDb3VydCwgQ29wbGV5IENsb3NlLCBMb25kb24sIFc3IDFFQiwgVW5pdGVkIEtpbmdkb21-YWx0X2tleT01NjE0NDI1Nn5kYXRhc2V0PUdCUl9QQUZ-Zm9ybWF0X2tleT1HQlIkZ2ItYWRkcmVzcyQxNGMzYzg4Ny0wMzI2LTRlZDEtYjJhZi00ZGRkYTk3YzI1MDIkJCQ\",\n                \"format\": \"https://api.experianaperture.io/address/format/v1/aWQ9NDMgTWF0bG9jayBDb3VydCwgQ29wbGV5IENsb3NlLCBMb25kb24sIFc3IDFFQiwgVW5pdGVkIEtpbmdkb21-YWx0X2tleT01NjE0NDI1Nn5kYXRhc2V0PUdCUl9QQUZ-Zm9ybWF0X2tleT1HQlIkZ2ItYWRkcmVzcyQxNGMzYzg4Ny0wMzI2LTRlZDEtYjJhZi00ZGRkYTk3YzI1MDIkJCR-UUw9Ng\"\n            },\n            {\n                \"text\": \"St. Thomas Church, Prince George Avenue, London, N14 4SN\",\n                \"matched\": [\n                    [\n                        41,\n                        47\n                    ]\n                ],\n                \"global_address_key\": \"aWQ9U3QuIFRob21hcyBDaHVyY2gsIFByaW5jZSBHZW9yZ2UgQXZlbnVlLCBMb25kb24sIE4xNCA0U04sIFVuaXRlZCBLaW5nZG9tfmFsdF9rZXk9NTcwNDkyNDN-ZGF0YXNldD1HQlJfUEFGfmZvcm1hdF9rZXk9R0JSJGdiLWFkZHJlc3MkNTE2ZDNhMDYtYjg2OC00Y2EwLWEwZTktNGMyZDY2M2E0NGZkJCQk\",\n                \"format\": \"https://api.experianaperture.io/address/format/v1/aWQ9U3QuIFRob21hcyBDaHVyY2gsIFByaW5jZSBHZW9yZ2UgQXZlbnVlLCBMb25kb24sIE4xNCA0U04sIFVuaXRlZCBLaW5nZG9tfmFsdF9rZXk9NTcwNDkyNDN-ZGF0YXNldD1HQlJfUEFGfmZvcm1hdF9rZXk9R0JSJGdiLWFkZHJlc3MkNTE2ZDNhMDYtYjg2OC00Y2EwLWEwZTktNGMyZDY2M2E0NGZkJCQkflFMPTY\"\n            },\n            {\n                \"text\": \"London, NW2 9WH\",\n                \"matched\": [\n                    [\n                        0,\n                        6\n                    ]\n                ],\n                \"global_address_key\": \"aWQ9TG9uZG9uLCBOVzIgOVdILCBVbml0ZWQgS2luZ2RvbX5hbHRfa2V5PTU3MDQ2MDg3fmRhdGFzZXQ9R0JSX1BBRn5mb3JtYXRfa2V5PUdCUiRnYi1hZGRyZXNzJDRkY2Q4NDM3LWRhNmUtNDJjMC04NjQyLTlmNzE4MDc1MTJmNiQkJA\",\n                \"format\": \"https://api.experianaperture.io/address/format/v1/aWQ9TG9uZG9uLCBOVzIgOVdILCBVbml0ZWQgS2luZ2RvbX5hbHRfa2V5PTU3MDQ2MDg3fmRhdGFzZXQ9R0JSX1BBRn5mb3JtYXRfa2V5PUdCUiRnYi1hZGRyZXNzJDRkY2Q4NDM3LWRhNmUtNDJjMC04NjQyLTlmNzE4MDc1MTJmNiQkJH5RTD02\"\n            }\n        ]\n    }\n}"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/lookup/v2 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].locality' has 'locality' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].locality`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].locality:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].locality.town' has 'town' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].locality.town`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].locality.town:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].locality.town.name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].locality.town.name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].locality.town.name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].locality.town.name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].locality.town.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].locality.town.name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].locality.town.name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].locality.town.name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].locality.town.name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].postal_code' has 'postal_code' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].postal_code`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].postal_code:\", error.message);\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].postal_code.full_name' has 'full_name' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].postal_code.full_name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].postal_code.full_name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].postal_code.full_name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].postal_code.full_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].postal_code.full_name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].postal_code.full_name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].postal_code.full_name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].postal_code.full_name:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.addresses` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.addresses`)) {\n                    const value = ld.get(jsonResponse, `result.addresses`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.addresses:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.addresses:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.addresses:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.addresses field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.addresses`)) {\n                    let addressesArray = ld.get(jsonResponse, `result.addresses`, []);\n                    if (Array.isArray(addressesArray)) {\n                        for (let addresses_it = 0; addresses_it < addressesArray.length; addresses_it++) {\n                            let iterator = addresses_it;\n                            if (addressesArray[addresses_it] !== null && addressesArray[addresses_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.addresses[${addresses_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.addresses[${addresses_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.addresses[${addresses_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.addresses[${addresses_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.addresses[${addresses_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses[${addresses_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.addresses[${addresses_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'addressesArray' has 'matched' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.addresses[${addresses_it}].matched`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.addresses[${addresses_it}].matched:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.addresses[${addresses_it}].matched length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].matched`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.addresses[${addresses_it}].matched:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses[${addresses_it}].matched length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].matched`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.addresses[${addresses_it}].matched:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.addresses[${addresses_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.addresses[${addresses_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.addresses[${addresses_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.addresses[${addresses_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.addresses[${addresses_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses[${addresses_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.addresses[${addresses_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.addresses[${addresses_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.addresses[${addresses_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.addresses[${addresses_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.addresses[${addresses_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.addresses[${addresses_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.addresses[${addresses_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.addresses[${addresses_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.addresses[${addresses_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.addresses[${addresses_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.addresses[${addresses_it}].format:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.addresses:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Get the available prompt sets.",
          "request": {
            "method": "POST",
            "header": [
              {
                "description": "Your unique key, called a token, that is required to submit an API request.",
                "key": "Auth-Token",
                "value": ""
              },
              {
                "description": "Alternative Auth Token header.",
                "key": "x-app-key",
                "value": ""
              },
              {
                "description": "Optional identifier that will be returned in the response to help you track the request.",
                "key": "Reference-Id",
                "value": ""
              },
              {
                "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                "key": "Timeout-Seconds",
                "value": ""
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"search_type\": \"{{search_type_*string}}\",\n    \"prompt_set\": \"{{prompt_set_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/address/promptsets/v1",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "address",
                "promptsets",
                "v1"
              ]
            }
          },
          "response": [
            {
              "name": "Success",
              "originalRequest": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"search_type\": \"{{search_type_*string}}\",\n    \"prompt_set\": \"{{prompt_set_*string}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/promptsets/v1",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "promptsets",
                    "v1"
                  ]
                }
              },
              "status": "OK",
              "code": 200,
              "_postman_previewlanguage": "json",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "cookie": [],
              "body": "{\n  \"result\": {\n    \"lines\": [\n      {\n        \"prompt\": \"Building Number or Name\",\n        \"suggested_input_length\": 40,\n        \"example\": \"125v\"\n      },\n      {\n        \"prompt\": \"Street\",\n        \"suggested_input_length\": 40,\n        \"example\": \"Summer St\"\n      },\n      {\n        \"prompt\": \"Town or City\",\n        \"suggested_input_length\": 40,\n        \"example\": \"Boston\"\n      },\n      {\n        \"prompt\": \"Postal code\",\n        \"suggested_input_length\": 10,\n        \"example\": \"02110-1615\"\n      }\n    ]\n  }\n}"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/promptsets/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.lines` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.lines`)) {\n                    const value = ld.get(jsonResponse, `result.lines`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.lines:\", error.message);\n            }\n        })\n  \n        pm.test(`result.lines length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.lines:\", error.message);\n            }\n        })\n  \n        pm.test(`result.lines length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.lines:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.lines field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.lines`)) {\n                    let linesArray = ld.get(jsonResponse, `result.lines`, []);\n                    if (Array.isArray(linesArray)) {\n                        for (let lines_it = 0; lines_it < linesArray.length; lines_it++) {\n                            let iterator = lines_it;\n                            if (linesArray[lines_it] !== null && linesArray[lines_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.lines[${lines_it}].prompt' has 'prompt' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.lines[${lines_it}].prompt`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.lines[${lines_it}].prompt:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.lines[${lines_it}].prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.lines[${lines_it}].prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.lines[${lines_it}].prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.lines[${lines_it}].prompt:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'linesArray' has 'suggested_input_length' as number`, function(){ \n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].suggested_input_length`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                }\n            } catch (error) {\n                console.log(\"Error checking number type for result.lines[${lines_it}].suggested_input_length:\", error.message);\n            }\n        })\n  \n        pm.test('result.lines[${lines_it}].suggested_input_length maximum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `result.lines[${lines_it}].suggested_input_length`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.most(1040);\n                }\n            } catch (error) {\n                console.log(\"Error checking maximum for result.lines[${lines_it}].suggested_input_length:\", error.message);\n            }\n        })\n  \n        pm.test('result.lines[${lines_it}].suggested_input_length minimum value validation', function(){\n            try {\n                const value = ld.get(pm.response.json(), `result.lines[${lines_it}].suggested_input_length`, null);\n                if (value !== null && value !== undefined && typeof value === 'number') {\n                    pm.expect(value).to.be.at.least(-960);\n                }\n            } catch (error) {\n                console.log(\"Error checking minimum for result.lines[${lines_it}].suggested_input_length:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.lines[${lines_it}].example' has 'example' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.lines[${lines_it}].example`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.lines[${lines_it}].example:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.lines[${lines_it}].example length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].example`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.lines[${lines_it}].example:\", error.message);\n            }\n        })\n  \n        pm.test(`result.lines[${lines_it}].example length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.lines[${lines_it}].example`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.lines[${lines_it}].example:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.lines:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Search for an address.",
          "request": {
            "method": "POST",
            "header": [
              {
                "description": "Your unique key, called a token, that is required to submit an API request.",
                "key": "Auth-Token",
                "value": ""
              },
              {
                "description": "Alternative Auth Token header.",
                "key": "x-app-key",
                "value": ""
              },
              {
                "description": "Optional identifier that will be returned in the response to help you track the request.",
                "key": "Reference-Id",
                "value": ""
              },
              {
                "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                "key": "Timeout-Seconds",
                "value": ""
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"max_suggestions\": \"{{max_suggestions_*number}}\",\n    \"components\": {\n        \"unspecified\": [\n            \"{{components.unspecified_0_*string}}\"\n        ]\n    },\n    \"options\": [\n        {\n            \"name\": \"{{options_0.name_*string}}\",\n            \"value\": \"{{options_0.value_*string}}\"\n        },\n        {\n            \"name\": \"{{options_1.name_*string}}\",\n            \"value\": \"{{options_1.value_*boolean}}\"\n        },\n        {\n            \"name\": \"{{options_2.name_*string}}\",\n            \"value\": \"{{options_2.value_*string}}\"\n        },\n        {\n            \"name\": \"{{options_3.name_*string}}\",\n            \"value\": \"{{options_3.value_*string}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{baseUrl}}/address/search/v1",
              "host": [
                "{{baseUrl}}"
              ],
              "path": [
                "address",
                "search",
                "v1"
              ]
            }
          },
          "response": [
            {
              "name": "Success",
              "originalRequest": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"max_suggestions\": \"{{max_suggestions_*number}}\",\n    \"components\": {\n        \"unspecified\": [\n            \"{{components.unspecified_0_*string}}\"\n        ]\n    },\n    \"options\": [\n        {\n            \"name\": \"{{options_0.name_*string}}\",\n            \"value\": \"{{options_0.value_*string}}\"\n        },\n        {\n            \"name\": \"{{options_1.name_*string}}\",\n            \"value\": \"{{options_1.value_*boolean}}\"\n        },\n        {\n            \"name\": \"{{options_2.name_*string}}\",\n            \"value\": \"{{options_2.value_*string}}\"\n        },\n        {\n            \"name\": \"{{options_3.name_*string}}\",\n            \"value\": \"{{options_3.value_*string}}\"\n        }\n    ]\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/search/v1",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "search",
                    "v1"
                  ]
                }
              },
              "status": "OK",
              "code": 200,
              "_postman_previewlanguage": "json",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "cookie": [],
              "body": "{\n  \"result\": {\n    \"more_results_available\": false,\n    \"confidence\": \"Verified match\",\n    \"suggestions_key\": \"QVVTfjcuNzMwUk1BVVNIQW5sQndBQUFBQUJBUUVBQVFBQUFBQkVHczlSZ0NFd2doTUFJUUVDRUFnaEFBSUFBQUFBQUFBQU1RQUEuLjlrQUFBQUFQLi4uLjhBQUFBQUFBQUFBQUFBQUFBQUFBLS1-MzY\",\n    \"suggestions_prompt\": \"Enter selection\",\n    \"suggestions\": [\n      {\n        \"global_address_key\": \"QVVTfjcuNzMwVU9BVVNIQW5sQndBQUFBQUJBd0VBQUFBQVJCclBVWUFoTUlJVEFDRUJBaEFJSVFBQ0FBQUFBQUFBQURFQUFQLi5aQUFBQUFELi4uLi5BQUFBQUFBQUFBQUFBQUFBQUFBQVZXNXBkQ0F4SUNBNElFMWhhVzRnUVhabGJuVmxMQ0JNU1VSRFQwMUNSU0FnVGxOWEFBQUFBQUEtfjM2\",\n        \"text\": \"Unit 1  8 Main Avenue, LIDCOMBE  NSW  2141\",\n        \"format\": \"https://api.experianaperture.io/address/format/v1/QVVTfjcuNzMwVU9BVVNIQW5sQndBQUFBQUJBd0VBQUFBQVJCclBVWUFoTUlJVEFDRUJBaEFJSVFBQ0FBQUFBQUFBQURFQUFQLi5aQUFBQUFELi4uLi5BQUFBQUFBQUFBQUFBQUFBQUFBQVZXNXBkQ0F4SUNBNElFMWhhVzRnUVhabGJuVmxMQ0JNU1VSRFQwMUNSU0FnVGxOWEFBQUFBQUEtfjM2\",\n        \"additional_attributes\": [\n          {\n            \"name\": \"picklist_display\",\n            \"value\": \"Unit 1  8 Main Avenue, LIDCOMBE  NSW\"\n          },\n          {\n            \"name\": \"score\",\n            \"value\": \"100\"\n          },\n          {\n            \"name\": \"postcode\",\n            \"value\": \"2141\"\n          }\n        ]\n      }\n    ]\n  }\n}"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/search/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.more_results_available` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.more_results_available`)) {\n                    const value = ld.get(jsonResponse, `result.more_results_available`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking boolean field result.more_results_available:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_key` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_key`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_key`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_key:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions_prompt` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions_prompt`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions_prompt`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions_prompt length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions_prompt`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions_prompt:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.suggestions` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    const value = ld.get(jsonResponse, `result.suggestions`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking array field result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions`)) {\n                    let suggestionsArray = ld.get(jsonResponse, `result.suggestions`, []);\n                    if (Array.isArray(suggestionsArray)) {\n                        for (let suggestions_it = 0; suggestions_it < suggestionsArray.length; suggestions_it++) {\n                            let iterator = suggestions_it;\n                            if (suggestionsArray[suggestions_it] !== null && suggestionsArray[suggestions_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].global_address_key' has 'global_address_key' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].global_address_key length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].global_address_key`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].global_address_key:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].text' has 'text' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].text length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].text`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].text:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].format' has 'format' as 'string'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                }\n            } catch (error) {\n                console.log(\"Error checking string type for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].format length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n  \n        pm.test('result.suggestions[${suggestions_it}].format format to be url',function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].format`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value).to.match(/^(https?|ftp)://[^s/$.?#].[^s]*$/);\n                }\n            } catch (error) {\n                console.log(\"Error checking URL format for result.suggestions[${suggestions_it}].format:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'suggestionsArray' has 'additional_attributes' as an array`,function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(Array.isArray(value)).to.equal(true);\n                }\n            } catch (error) {\n                console.log(\"Error checking array type for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atmost '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.most(100);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes length to be atleast '100'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes`, null);\n                if (value !== null && value !== undefined && Array.isArray(value)) {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minItems for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n        pm.test(`Each object in the result.suggestions[${suggestions_it}].additional_attributes field has all the required fields`,function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.suggestions[${suggestions_it}].additional_attributes`)) {\n                    let additional_attributesArray = ld.get(jsonResponse, `result.suggestions[${suggestions_it}].additional_attributes`, []);\n                    if (Array.isArray(additional_attributesArray)) {\n                        for (let additional_attributes_it = 0; additional_attributes_it < additional_attributesArray.length; additional_attributes_it++) {\n                            let iterator = additional_attributes_it;\n                            if (additional_attributesArray[additional_attributes_it] !== null && additional_attributesArray[additional_attributes_it] !== undefined) {\n                                \n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name' has 'name' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].name:\", error.message);\n            }\n        })\n\n        pm.test(`${iterator} element of array 'result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value' has 'value' as 'object'`, function(){ \n            try {\n                const value = ld.get(pm.response.json(), `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                }\n            } catch (error) {\n                console.log(\"Error checking object type for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n  \n        pm.test(`result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.suggestions[${suggestions_it}].additional_attributes[${additional_attributes_it}].value:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions[${suggestions_it}].additional_attributes:\", error.message);\n            }\n        })\n\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error validating array objects for result.suggestions:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Validate an address.",
          "request": {
            "method": "POST",
            "header": [
              {
                "description": "Your unique key, called a token, that is required to submit an API request.",
                "key": "Auth-Token",
                "value": ""
              },
              {
                "description": "Alternative Auth Token header.",
                "key": "x-app-key",
                "value": ""
              },
              {
                "description": "Optional identifier that will be returned in the response to help you track the request.",
                "key": "Reference-Id",
                "value": ""
              },
              {
                "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                "key": "Timeout-Seconds",
                "value": ""
              },
              {
                "description": "Specifies if the response should contain the address broken down into its components.",
                "key": "Add-Components",
                "value": "{{Add-Components}}"
              },
              {
                "description": "Specify whether the response should return all fields and values, in addition to the main core information.",
                "key": "Add-Metadata",
                "value": "{{Add-Metadata}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"components\": {\n        \"unspecified\": [\n            \"{{components.unspecified_0_*string}}\"\n        ]\n    },\n    \"options\": [\n        {\n            \"name\": \"{{options_0.name_*string}}\",\n            \"value\": \"{{options_0.value_*string}}\"\n        },\n        {\n            \"name\": \"{{options_1.name_*string}}\",\n            \"value\": \"{{options_1.value_*boolean}}\"\n        },\n        {\n            \"name\": \"{{options_2.name_*string}}\",\n            \"value\": \"{{options_2.value_*string}}\"\n        }\n    ],\n    \"layouts\": [\n        \"{{layouts_0_*string}}\"\n    ],\n    \"layout_format\": \"{{layout_format_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "https://api.experianaperture.io/address/validate/v1",
              "protocol": "https",
              "host": [
                "api",
                "experianaperture",
                "io"
              ],
              "path": [
                "address",
                "validate",
                "v1"
              ]
            }
          },
          "response": [
            {
              "name": "Success",
              "originalRequest": {
                "method": "POST",
                "header": [
                  {
                    "description": "Your unique key, called a token, that is required to submit an API request.",
                    "key": "Auth-Token",
                    "value": ""
                  },
                  {
                    "description": "Alternative Auth Token header.",
                    "key": "x-app-key",
                    "value": ""
                  },
                  {
                    "description": "Optional identifier that will be returned in the response to help you track the request.",
                    "key": "Reference-Id",
                    "value": ""
                  },
                  {
                    "description": "Maximum time you are prepared to wait for a response, expressed in seconds. Acceptable values: 2-15. If a timeout occurs, an HTTP status code of 408 - Request Timeout will be returned.",
                    "key": "Timeout-Seconds",
                    "value": ""
                  },
                  {
                    "description": "Specifies if the response should contain the address broken down into its components.",
                    "key": "Add-Components",
                    "value": "{{Add-Components}}"
                  },
                  {
                    "description": "Specify whether the response should return all fields and values, in addition to the main core information.",
                    "key": "Add-Metadata",
                    "value": "{{Add-Metadata}}"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"country_iso\": \"{{country_iso_*string}}\",\n    \"datasets\": [\n        \"{{datasets_0_*string}}\"\n    ],\n    \"components\": {\n        \"unspecified\": [\n            \"{{components.unspecified_0_*string}}\"\n        ]\n    },\n    \"options\": [\n        {\n            \"name\": \"{{options_0.name_*string}}\",\n            \"value\": \"{{options_0.value_*string}}\"\n        },\n        {\n            \"name\": \"{{options_1.name_*string}}\",\n            \"value\": \"{{options_1.value_*boolean}}\"\n        },\n        {\n            \"name\": \"{{options_2.name_*string}}\",\n            \"value\": \"{{options_2.value_*string}}\"\n        }\n    ],\n    \"layouts\": [\n        \"{{layouts_0_*string}}\"\n    ],\n    \"layout_format\": \"{{layout_format_*string}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/address/validate/v1",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "address",
                    "validate",
                    "v1"
                  ]
                }
              },
              "status": "OK",
              "code": 200,
              "_postman_previewlanguage": "json",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "cookie": [],
              "body": "{\n  \"result\": {\n    \"confidence\": \"Verified match\",\n    \"address\": {\n      \"address_line_1\": \"U 1  8 Main Ave\",\n      \"address_line_2\": \"\",\n      \"address_line_3\": \"\",\n      \"locality\": \"LIDCOMBE\",\n      \"region\": \"NSW\",\n      \"postal_code\": \"2141\",\n      \"country\": \"AUSTRALIA\"\n    }\n  }\n}"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test postman-collection-test using AI Type Open AI and AI Model gpt-4o\n\n\nTest generated for address/validate/v1 for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n         console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n      try {\n            responseData = pm.response.json();\n      } catch (error) {\n            console.log(\"Error parsing response:\", error.message);\n      }\n}\nif (pm.variables.get(\"statusCode\")) {\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\nif (pm.response.code == 200){\n    pm.test(\"Success\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"OK\");\n        pm.test(\"Response has Content-Type header\", function () {\n            try {\n                pm.response.to.have.header(\"Content-Type\");\n            } catch (error) {\n                console.error('Error checking Content-Type header:', error.message);\n            }\n        });\n        pm.test(\"Content-Type is application/json\", function () {\n            try {\n                pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n            } catch (error) {\n                console.error('Error validating JSON Content-Type:', error.message);\n            }\n        });\n        pm.test(\"Response object structure validation\", function () {\n            try {\n                if (responseData !== null && responseData !== undefined) {\n        pm.test('Response has the `result` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result`)) {\n                    const value = ld.get(jsonResponse, `result`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.confidence` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.confidence`)) {\n                    const value = ld.get(jsonResponse, `result.confidence`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.confidence:\", error.message);\n            }\n        })\n  \n        pm.test(`result.confidence length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.confidence`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.confidence:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address`)) {\n                    const value = ld.get(jsonResponse, `result.address`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"object\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking object field result.address:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_1` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_1`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_1`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.address_line_1:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.address_line_1 length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.address_line_1`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.address_line_1:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_2` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_2`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_2`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_2:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.address_line_3` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.address_line_3`)) {\n                    const value = ld.get(jsonResponse, `result.address.address_line_3`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.address_line_3:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.locality` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.locality`)) {\n                    const value = ld.get(jsonResponse, `result.address.locality`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.locality:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.locality length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.locality`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.locality:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.region` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.region`)) {\n                    const value = ld.get(jsonResponse, `result.address.region`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.region:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.region length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.region`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.region:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.postal_code` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.postal_code`)) {\n                    const value = ld.get(jsonResponse, `result.address.postal_code`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.postal_code:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.postal_code length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.postal_code`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.postal_code:\", error.message);\n            }\n        })\n\n        pm.test('Response has the `result.address.country` field',function(){\n            try {\n                const jsonResponse = pm.response.json();\n                if (jsonResponse && pm.expect(jsonResponse).to.have.nested.property(`result.address.country`)) {\n                    const value = ld.get(jsonResponse, `result.address.country`, null);\n                    if (value !== null && value !== undefined) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                    }\n                }\n            } catch (error) {\n                console.log(\"Error checking string field result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be atmost '1000'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.most(1000);\n                }\n            } catch (error) {\n                console.log(\"Error checking maxLength for result.address.country:\", error.message);\n            }\n        })\n  \n        pm.test(`result.address.country length to be alteast '0'`,function(){\n            try {\n                const value = ld.get(responseData, `result.address.country`, null);\n                if (value !== null && value !== undefined && typeof value === 'string') {\n                    pm.expect(value.length).to.be.at.least(0);\n                }\n            } catch (error) {\n                console.log(\"Error checking minLength for result.address.country:\", error.message);\n            }\n        })\n\n                }\n            } catch (error) {\n                console.error('Error validating object structure:', error.message);\n            }\n        });\n        pm.test(\"Response reflects the request data\", function () {\n            try {\n                if (pm.request.body && pm.request.body.mode === 'raw' && responseData) {\n                    const requestData = JSON.parse(pm.request.body.raw);\n                    if (requestData && typeof requestData === 'object') {\n                        const hasMatchingFields = Object.keys(requestData).some(key => \n                            responseData && responseData.hasOwnProperty && responseData.hasOwnProperty(key)\n                        );\n                        if (hasMatchingFields) {\n                            pm.expect(hasMatchingFields).to.be.true;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Error validating request-response data matching:', error.message);\n            }\n        });\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ]
        }
      ]
    }
  ],
  "variable": [
    {
      "key": "baseUrl",
      "value": "https://api.experianaperture.io/",
      "type": "string"
    },
    {
      "key": "globalAddressKey",
      "value": "global_address_key"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ]
}