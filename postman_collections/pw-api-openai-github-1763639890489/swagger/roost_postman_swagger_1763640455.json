{
  "item": [
    {
      "name": "Submit Request",
      "request": {
        "name": "Submit Request",
        "description": {
          "content": "Meta API request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "submitRequest"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "\"{{value_*object}}\"",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "submitRequest"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "\"{{value_*object}}\"",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for submitRequest for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AuthToken",
      "request": {
        "name": "AuthToken",
        "description": {
          "content": "Get authentication token",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "authToken"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null
      },
      "response": [
        {
          "name": "successful login",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"token\": \"token\"\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "authToken"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {}
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for authToken for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful login\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: token\n\n        pm.test(`'responseData field has token that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`token`)) {\n            const value = responseData?.token;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "Deposit",
      "request": {
        "name": "Deposit",
        "description": {
          "content": "Deposit amount to customer's account",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deposit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*string}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Deposit success",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deposit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"image\": {\n        \"frontImage\": \"{{image.frontImage_*string}}\",\n        \"backImage\": \"{{image.backImage_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deposit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Deposit success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetAccountInfo",
      "request": {
        "name": "GetAccountInfo",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"customerId\": 2277.5807678140445,\n  \"accounts\": [\n    {\n      \"customerId\": 4007.457453344452,\n      \"accountName\": \"string\",\n      \"accountNickname\": \"string\",\n      \"accountNumber\": \"string\",\n      \"accountType\": \"string\",\n      \"activatedDate\": \"string\",\n      \"availableBalance\": 1660.361454969681,\n      \"availableCash\": 2111.39489474049,\n      \"availableCashLimit\": 9890.702943935468,\n      \"availableCredit\": 4747.396525056036,\n      \"bankName\": \"string\",\n      \"branchName\": \"string\",\n      \"cardName\": \"string\",\n      \"cardNumber\": \"string\",\n      \"cardStatus\": \"string\",\n      \"cardType\": \"string\",\n      \"creditLimit\": 1597.5608201870139,\n      \"currency\": \"string\",\n      \"currentBalance\": 3882.3952276929763,\n      \"deactivatedDate\": \"string\",\n      \"dueAmount\": 3490.482213743158,\n      \"dueDate\": \"string\",\n      \"earlyWithdrawalPenalty\": 6670.644509659489,\n      \"email\": \"string\",\n      \"expDate\": \"string\",\n      \"fdType\": \"string\",\n      \"image\": \"string\",\n      \"interestRate\": 799.3128948367367,\n      \"internalTransferFromEnabled\": true,\n      \"internalTransferToEnabled\": false,\n      \"isPrimaryMobile\": false,\n      \"isAlternateMobileNumber\": true,\n      \"isStatement\": true,\n      \"lastDrawDate\": \"string\",\n      \"loanMaturityDate\": \"string\",\n      \"loanOriginationDate\": \"string\",\n      \"location\": \"string\",\n      \"lastUpdated\": \"string\",\n      \"maxTransactionLimit\": \"string\",\n      \"maturityDate\": \"string\",\n      \"minimumPaymentDue\": \"string\",\n      \"minimumBalance\": \"string\",\n      \"monthlyPayment\": 5323.210351229269,\n      \"openingBalance\": 3975.814685024186,\n      \"originalLoanAmount\": 3928.6370102338396,\n      \"P2PLimit\": 4922.869912287398,\n      \"p2pEnabled\": 7672.636748912851,\n      \"paybillEnabled\": false,\n      \"payoffAmount\": 1012.452642876378,\n      \"personalBankerName\": \"string\",\n      \"personalBankerContact\": {\n        \"email\": \"string\",\n        \"mobileNumber\": \"string\"\n      },\n      \"phone\": 7252.3503581366385,\n      \"postedBalance\": 1026.727969691108,\n      \"principalBalance\": \"string\",\n      \"productCode\": \"string\",\n      \"productName\": \"string\",\n      \"propertyAddress\": \"string\",\n      \"rewardPoints\": \"string\",\n      \"routingNumber\": \"string\",\n      \"statementDate\": \"string\",\n      \"status\": \"string\",\n      \"swiftCode\": \"string\",\n      \"totalBalance\": 3482.2291583729047,\n      \"unbilledAmount\": 5224.033515196287,\n      \"valueAtMaturity\": 6814.0037966004365,\n      \"holdAmount\": 6971.442147813811,\n      \"unclearFundsAmount\": 1203.7749150329203,\n      \"averageMonthlyBalance\": 8366.330474319711,\n      \"netWithdrawableBalance\": 3083.51558131251,\n      \"totalTenure\": \"string\",\n      \"remainingTenure\": \"string\",\n      \"debitAccountNumber\": \"string\",\n      \"lateFee\": 5762.821077741671,\n      \"bounceCharge\": 8636.411413843485,\n      \"totalCharges\": 8196.572493358772,\n      \"overDueAmount\": 9677.717389615034,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": false,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 2297.261179533083,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 5852.749843040803,\n          \"partialPaymentPaid\": 4044.069181470207\n        },\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": false,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 7202.117870297897,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 2159.0447256135058,\n          \"partialPaymentPaid\": 5960.408535482074\n        }\n      ],\n      \"IsCrossAccount\": false\n    },\n    {\n      \"customerId\": 1473.8242358506493,\n      \"accountName\": \"string\",\n      \"accountNickname\": \"string\",\n      \"accountNumber\": \"string\",\n      \"accountType\": \"string\",\n      \"activatedDate\": \"string\",\n      \"availableBalance\": 5991.632449709685,\n      \"availableCash\": 2713.8219444395604,\n      \"availableCashLimit\": 9161.908702340583,\n      \"availableCredit\": 8015.713964847553,\n      \"bankName\": \"string\",\n      \"branchName\": \"string\",\n      \"cardName\": \"string\",\n      \"cardNumber\": \"string\",\n      \"cardStatus\": \"string\",\n      \"cardType\": \"string\",\n      \"creditLimit\": 8717.460933012771,\n      \"currency\": \"string\",\n      \"currentBalance\": 6779.773451959565,\n      \"deactivatedDate\": \"string\",\n      \"dueAmount\": 4140.196247556103,\n      \"dueDate\": \"string\",\n      \"earlyWithdrawalPenalty\": 4870.297387867368,\n      \"email\": \"string\",\n      \"expDate\": \"string\",\n      \"fdType\": \"string\",\n      \"image\": \"string\",\n      \"interestRate\": 2196.611149948786,\n      \"internalTransferFromEnabled\": true,\n      \"internalTransferToEnabled\": false,\n      \"isPrimaryMobile\": true,\n      \"isAlternateMobileNumber\": false,\n      \"isStatement\": false,\n      \"lastDrawDate\": \"string\",\n      \"loanMaturityDate\": \"string\",\n      \"loanOriginationDate\": \"string\",\n      \"location\": \"string\",\n      \"lastUpdated\": \"string\",\n      \"maxTransactionLimit\": \"string\",\n      \"maturityDate\": \"string\",\n      \"minimumPaymentDue\": \"string\",\n      \"minimumBalance\": \"string\",\n      \"monthlyPayment\": 2434.0196130436298,\n      \"openingBalance\": 360.8286345009604,\n      \"originalLoanAmount\": 9910.744710350433,\n      \"P2PLimit\": 1895.2517512899792,\n      \"p2pEnabled\": 8598.160774129818,\n      \"paybillEnabled\": true,\n      \"payoffAmount\": 2266.0988561114204,\n      \"personalBankerName\": \"string\",\n      \"personalBankerContact\": {\n        \"email\": \"string\",\n        \"mobileNumber\": \"string\"\n      },\n      \"phone\": 2353.252279894753,\n      \"postedBalance\": 9594.687807259306,\n      \"principalBalance\": \"string\",\n      \"productCode\": \"string\",\n      \"productName\": \"string\",\n      \"propertyAddress\": \"string\",\n      \"rewardPoints\": \"string\",\n      \"routingNumber\": \"string\",\n      \"statementDate\": \"string\",\n      \"status\": \"string\",\n      \"swiftCode\": \"string\",\n      \"totalBalance\": 6122.824337950945,\n      \"unbilledAmount\": 9182.646788674223,\n      \"valueAtMaturity\": 612.5299646367299,\n      \"holdAmount\": 32.2657027155615,\n      \"unclearFundsAmount\": 7636.47053283405,\n      \"averageMonthlyBalance\": 1670.1425806862292,\n      \"netWithdrawableBalance\": 5006.588995864756,\n      \"totalTenure\": \"string\",\n      \"remainingTenure\": \"string\",\n      \"debitAccountNumber\": \"string\",\n      \"lateFee\": 4234.339412336117,\n      \"bounceCharge\": 6504.732180415045,\n      \"totalCharges\": 4860.722853867903,\n      \"overDueAmount\": 5431.895773947175,\n      \"cardDetails\": [\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": false,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": false,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 4754.488499029259,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 8491.930563295451,\n          \"partialPaymentPaid\": 179.04103417031524\n        },\n        {\n          \"cardName\": \"string\",\n          \"cardNumber\": \"string\",\n          \"cardStatus\": \"string\",\n          \"cardImage\": \"string\",\n          \"cardType\": \"string\",\n          \"expDate\": \"string\",\n          \"displayCardStatus\": \"string\",\n          \"primaryCard\": \"string\",\n          \"cardChannelInfo\": {\n            \"ATM\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"offline\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"international\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"online\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"contactless\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"cardRestrictions\": {\n            \"countries\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ],\n            \"MCC\": [\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              },\n              {\n                \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n              }\n            ]\n          },\n          \"blockReason\": \"string\",\n          \"nameOnCard\": \"string\",\n          \"cardNetwork\": \"string\",\n          \"autopay\": {\n            \"enabled\": true,\n            \"sourceAccountId\": \"string\",\n            \"paymentType\": \"string\",\n            \"onStatementDate\": true,\n            \"dayOfMonth\": \"string\"\n          },\n          \"dueAmount\": 3368.574422070081,\n          \"dueDate\": \"string\",\n          \"minimumPaymentDue\": 4086.984721753759,\n          \"partialPaymentPaid\": 8808.271627320633\n        }\n      ],\n      \"IsCrossAccount\": false\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'accounts' as type array'`, function() {\n          const value = responseData?.accounts;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.accounts field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`accounts`)) {\n            let accountsArray = ld.get(responseData, `accounts`, []);\n            if (Array.isArray(accountsArray)) {\n              for (let accounts_it = 0; accounts_it < accountsArray.length; accounts_it++) {\n                let iterator = accounts_it;\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'customerId' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.customerId;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountNickname' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountNickname;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'accountType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.accountType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'activatedDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.activatedDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCash' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCash;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCashLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCashLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'availableCredit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.availableCredit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'bankName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.bankName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'branchName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.branchName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardStatus;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.cardType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'creditLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.creditLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'currency' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.currency;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'currentBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.currentBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'deactivatedDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.deactivatedDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.dueAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.dueDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'earlyWithdrawalPenalty' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.earlyWithdrawalPenalty;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'email' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.email;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.expDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'fdType' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.fdType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'image' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.image;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'interestRate' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.interestRate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'internalTransferFromEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.internalTransferFromEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'internalTransferToEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.internalTransferToEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isPrimaryMobile' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isPrimaryMobile;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isAlternateMobileNumber' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isAlternateMobileNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'isStatement' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.isStatement;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lastDrawDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.lastDrawDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'loanMaturityDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.loanMaturityDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'loanOriginationDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.loanOriginationDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'location' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.location;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lastUpdated' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.lastUpdated;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'maxTransactionLimit' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.maxTransactionLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'maturityDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.maturityDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'minimumPaymentDue' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.minimumPaymentDue;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'minimumBalance' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.minimumBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'monthlyPayment' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.monthlyPayment;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'openingBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.openingBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'originalLoanAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.originalLoanAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'P2PLimit' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.P2PLimit;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'p2pEnabled' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.p2pEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'paybillEnabled' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.paybillEnabled;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'payoffAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.payoffAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'personalBankerName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.personalBankerName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'personalBankerContact' as type 'object'`, function() {\n                    const value = accountsArray[iterator]?.personalBankerContact;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: accountsArray[${iterator}].personalBankerContact\n                  // subKey: email\n                  // array: accountsArray\n\n\n                  pm.test(`'accountsArray[${iterator}].personalBankerContact field has email that is of type string'`, function() {\n                    let parent = accountsArray[iterator].personalBankerContact;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`email`)) {\n                      const value = accountsArray[iterator].personalBankerContact?.email;\n                      console.log(`accountsArray[iterator].personalBankerContact?.email`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: accountsArray[${iterator}].personalBankerContact\n                  // subKey: mobileNumber\n                  // array: accountsArray\n\n\n                  pm.test(`'accountsArray[${iterator}].personalBankerContact field has mobileNumber that is of type string'`, function() {\n                    let parent = accountsArray[iterator].personalBankerContact;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n                      const value = accountsArray[iterator].personalBankerContact?.mobileNumber;\n                      console.log(`accountsArray[iterator].personalBankerContact?.mobileNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'phone' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.phone;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'postedBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.postedBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'principalBalance' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.principalBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'productCode' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.productCode;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'productName' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.productName;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'propertyAddress' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.propertyAddress;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'rewardPoints' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.rewardPoints;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'routingNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.routingNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'statementDate' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.statementDate;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'status' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.status;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'swiftCode' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.swiftCode;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.totalBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'unbilledAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.unbilledAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'valueAtMaturity' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.valueAtMaturity;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'holdAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.holdAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'unclearFundsAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.unclearFundsAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'averageMonthlyBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.averageMonthlyBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'netWithdrawableBalance' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.netWithdrawableBalance;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalTenure' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.totalTenure;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'remainingTenure' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.remainingTenure;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'debitAccountNumber' as type 'string'`, function() {\n                    const value = accountsArray[iterator]?.debitAccountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'lateFee' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.lateFee;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'bounceCharge' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.bounceCharge;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'totalCharges' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.totalCharges;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'overDueAmount' as type 'number'`, function() {\n                    const value = accountsArray[iterator]?.overDueAmount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // array condition with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'cardDetails' as type array'`, function() {\n                    const value = accountsArray[iterator]?.cardDetails;\n\n                    if (value !== null && value !== undefined) {\n                      pm.expect(Array.isArray(value)).to.equal(true);\n                    }\n\n                  })\n\n\n                  pm.test(`Each object in the accountsArray[${iterator}].cardDetails field has all the required fields and correct data-types`, function() {\n                    if (pm.expect(accountsArray[iterator]).to.have.nested.property(`cardDetails`)) {\n                      let cardDetailsArray = ld.get(accountsArray[iterator], `cardDetails`, []);\n                      if (Array.isArray(cardDetailsArray)) {\n                        for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                          let iterator = cardDetails_it;\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardName;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardNumber;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardStatus;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardImage' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardImage;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardType;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.expDate;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'displayCardStatus' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.displayCardStatus;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'primaryCard' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.primaryCard;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardChannelInfo' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardChannelInfo;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: ATM\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has ATM that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`ATM`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.ATM;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.ATM`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: offline\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has offline that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`offline`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.offline;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.offline`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.offline?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.offline?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: international\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has international that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`international`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.international;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.international`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.international?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.international?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: online\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has online that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`online`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.online;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.online`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.online?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.online?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                            // subKey: contactless\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has contactless that is of type object'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`contactless`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo?.contactless;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo?.contactless`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"object\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                            // subKey: enable\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has enable that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.enable;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.enable`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                            // subKey: limit\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has limit that is of type number'`, function() {\n                              let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                                const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.limit;\n                                console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.limit`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"number\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardRestrictions' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardRestrictions;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // array condition and parent property is not an array\n                            pm.test(`'Response has the `\n                              cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                              function() {\n                                if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                                  const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                                  if (value !== null && value !== undefined) {\n                                    pm.expect(Array.isArray(value)).to.equal(true);\n                                  }\n\n                                }\n                              })\n\n                            pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.countries field has all the required fields and correct data-types`, function() {\n                              if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`countries`)) {\n                                let countriesArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `countries`, []);\n                                if (Array.isArray(countriesArray)) {\n                                  for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                                    let iterator = countries_it;\n                                    if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at countriesArray[${iterator}]' has 'countrycode' as type 'string'`, function() {\n                                        const value = countriesArray[iterator]?.countrycode;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                  }\n                                }\n                              }\n                            })\n\n                            // array condition and parent property is not an array\n                            pm.test(`'Response has the `\n                              cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                              function() {\n                                if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                                  const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                                  if (value !== null && value !== undefined) {\n                                    pm.expect(Array.isArray(value)).to.equal(true);\n                                  }\n\n                                }\n                              })\n\n                            pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.MCC field has all the required fields and correct data-types`, function() {\n                              if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`MCC`)) {\n                                let MCCArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `MCC`, []);\n                                if (Array.isArray(MCCArray)) {\n                                  for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                                    let iterator = MCC_it;\n                                    if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at MCCArray[${iterator}]' has 'name' as type 'string'`, function() {\n                                        const value = MCCArray[iterator]?.name;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                    if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                      // Condition: Raw data type with defined arrayName and parent property is an array\n                                      pm.test(`'Item at MCCArray[${iterator}]' has 'description' as type 'string'`, function() {\n                                        const value = MCCArray[iterator]?.description;\n\n                                        if (!ld.isEmpty(value)) {\n                                          pm.expect(typeof value).to.equal(\"string\");\n                                        }\n                                      })\n\n\n                                    }\n                                  }\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'blockReason' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.blockReason;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'nameOnCard' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.nameOnCard;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNetwork' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.cardNetwork;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'autopay' as type 'object'`, function() {\n                              const value = cardDetailsArray[iterator]?.autopay;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"object\");\n                              }\n                            })\n\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: enabled\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has enabled that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`enabled`)) {\n                                const value = cardDetailsArray[iterator].autopay?.enabled;\n                                console.log(`cardDetailsArray[iterator].autopay?.enabled`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: sourceAccountId\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has sourceAccountId that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`sourceAccountId`)) {\n                                const value = cardDetailsArray[iterator].autopay?.sourceAccountId;\n                                console.log(`cardDetailsArray[iterator].autopay?.sourceAccountId`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: paymentType\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has paymentType that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`paymentType`)) {\n                                const value = cardDetailsArray[iterator].autopay?.paymentType;\n                                console.log(`cardDetailsArray[iterator].autopay?.paymentType`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: onStatementDate\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has onStatementDate that is of type boolean'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`onStatementDate`)) {\n                                const value = cardDetailsArray[iterator].autopay?.onStatementDate;\n                                console.log(`cardDetailsArray[iterator].autopay?.onStatementDate`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"boolean\");\n                                }\n                              }\n                            })\n\n                            // Condition: Raw data type, got arrayName and parent property is not an array\n                            // pathStr: cardDetailsArray[${iterator}].autopay\n                            // subKey: dayOfMonth\n                            // array: cardDetailsArray\n\n\n                            pm.test(`'cardDetailsArray[${iterator}].autopay field has dayOfMonth that is of type string'`, function() {\n                              let parent = cardDetailsArray[iterator].autopay;\n                              // console.log(parent);\n                              if (pm.expect(parent).to.have.nested.property(`dayOfMonth`)) {\n                                const value = cardDetailsArray[iterator].autopay?.dayOfMonth;\n                                console.log(`cardDetailsArray[iterator].autopay?.dayOfMonth`, value);\n\n                                if (!ld.isEmpty(value)) {\n                                  pm.expect(typeof value).to.equal(\"string\");\n                                }\n                              }\n                            })\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.dueAmount;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                              const value = cardDetailsArray[iterator]?.dueDate;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"string\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'minimumPaymentDue' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.minimumPaymentDue;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                          if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                            // Condition: Raw data type with defined arrayName and parent property is an array\n                            pm.test(`'Item at cardDetailsArray[${iterator}]' has 'partialPaymentPaid' as type 'number'`, function() {\n                              const value = cardDetailsArray[iterator]?.partialPaymentPaid;\n\n                              if (!ld.isEmpty(value)) {\n                                pm.expect(typeof value).to.equal(\"number\");\n                              }\n                            })\n\n\n                          }\n                        }\n                      }\n                    }\n                  })\n\n                }\n                if (accountsArray[accounts_it] !== null && accountsArray[accounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at accountsArray[${iterator}]' has 'IsCrossAccount' as type 'boolean'`, function() {\n                    const value = accountsArray[iterator]?.IsCrossAccount;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"boolean\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the details of the mentioned customer account",
      "request": {
        "name": "to get the details of the mentioned customer account",
        "description": {
          "content": "fetch customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountDetails"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*string}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*string}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*string}}\"\n        }\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 5411.381367147347,\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"activatedDate\": \"string\",\n    \"availableBalance\": 4460.049835587159,\n    \"availableCash\": 932.2727870989401,\n    \"availableCashLimit\": 6731.325798250192,\n    \"availableCredit\": 8531.95787842698,\n    \"bankName\": \"string\",\n    \"branchName\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"cardStatus\": \"string\",\n    \"cardType\": \"string\",\n    \"creditLimit\": 3811.596351944766,\n    \"currency\": \"string\",\n    \"currentBalance\": 4522.139050028007,\n    \"deactivatedDate\": \"string\",\n    \"dueAmount\": 8350.294613753771,\n    \"dueDate\": \"string\",\n    \"earlyWithdrawalPenalty\": 8514.385322282662,\n    \"email\": \"string\",\n    \"expDate\": \"string\",\n    \"fdType\": \"string\",\n    \"image\": \"string\",\n    \"interestRate\": 8225.791469939513,\n    \"internalTransferFromEnabled\": false,\n    \"internalTransferToEnabled\": true,\n    \"isPrimaryMobile\": true,\n    \"isAlternateMobileNumber\": false,\n    \"isStatement\": true,\n    \"lastDrawDate\": \"string\",\n    \"loanMaturityDate\": \"string\",\n    \"loanOriginationDate\": \"string\",\n    \"location\": \"string\",\n    \"lastUpdated\": \"string\",\n    \"maxTransactionLimit\": \"string\",\n    \"maturityDate\": \"string\",\n    \"minimumPaymentDue\": \"string\",\n    \"minimumBalance\": \"string\",\n    \"monthlyPayment\": 7187.419806443076,\n    \"openingBalance\": 5653.92309065329,\n    \"originalLoanAmount\": 7325.258910739672,\n    \"P2PLimit\": 5405.233839411237,\n    \"p2pEnabled\": 3706.8746907516825,\n    \"paybillEnabled\": true,\n    \"payoffAmount\": 5218.408941225152,\n    \"personalBankerName\": \"string\",\n    \"personalBankerContact\": {\n      \"email\": \"string\",\n      \"mobileNumber\": \"string\"\n    },\n    \"phone\": 8999.820996985454,\n    \"postedBalance\": 1320.2589613914472,\n    \"principalBalance\": \"string\",\n    \"productCode\": \"string\",\n    \"productName\": \"string\",\n    \"propertyAddress\": \"string\",\n    \"rewardPoints\": \"string\",\n    \"routingNumber\": \"string\",\n    \"statementDate\": \"string\",\n    \"status\": \"string\",\n    \"swiftCode\": \"string\",\n    \"totalBalance\": 3901.9378464736487,\n    \"unbilledAmount\": 5767.742881583559,\n    \"valueAtMaturity\": 6757.900860829906,\n    \"holdAmount\": 7553.574744218192,\n    \"unclearFundsAmount\": 1929.6910937847579,\n    \"averageMonthlyBalance\": 9882.142133276911,\n    \"netWithdrawableBalance\": 916.0126314564399,\n    \"totalTenure\": \"string\",\n    \"remainingTenure\": \"string\",\n    \"debitAccountNumber\": \"string\",\n    \"lateFee\": 1269.4619866301625,\n    \"bounceCharge\": 7133.196858187716,\n    \"totalCharges\": 7560.841223517709,\n    \"overDueAmount\": 6565.680573494661,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 959.6601884537437,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 7661.679680274249,\n        \"partialPaymentPaid\": 5006.711796253482\n      },\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": false,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": true,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 6153.137276514209,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 4792.198533087464,\n        \"partialPaymentPaid\": 1780.9227365145318\n      }\n    ],\n    \"IsCrossAccount\": false\n  },\n  {\n    \"customerId\": 8743.368300582293,\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"activatedDate\": \"string\",\n    \"availableBalance\": 9061.026489379996,\n    \"availableCash\": 2093.6887261758884,\n    \"availableCashLimit\": 7448.232806131927,\n    \"availableCredit\": 1315.1611614139647,\n    \"bankName\": \"string\",\n    \"branchName\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"cardStatus\": \"string\",\n    \"cardType\": \"string\",\n    \"creditLimit\": 2464.3986201587186,\n    \"currency\": \"string\",\n    \"currentBalance\": 4308.864611597951,\n    \"deactivatedDate\": \"string\",\n    \"dueAmount\": 707.8128886840718,\n    \"dueDate\": \"string\",\n    \"earlyWithdrawalPenalty\": 9700.226994694163,\n    \"email\": \"string\",\n    \"expDate\": \"string\",\n    \"fdType\": \"string\",\n    \"image\": \"string\",\n    \"interestRate\": 4549.914305825755,\n    \"internalTransferFromEnabled\": true,\n    \"internalTransferToEnabled\": false,\n    \"isPrimaryMobile\": true,\n    \"isAlternateMobileNumber\": false,\n    \"isStatement\": false,\n    \"lastDrawDate\": \"string\",\n    \"loanMaturityDate\": \"string\",\n    \"loanOriginationDate\": \"string\",\n    \"location\": \"string\",\n    \"lastUpdated\": \"string\",\n    \"maxTransactionLimit\": \"string\",\n    \"maturityDate\": \"string\",\n    \"minimumPaymentDue\": \"string\",\n    \"minimumBalance\": \"string\",\n    \"monthlyPayment\": 843.4446208572299,\n    \"openingBalance\": 8819.981065418522,\n    \"originalLoanAmount\": 8475.174375130564,\n    \"P2PLimit\": 6141.058758323714,\n    \"p2pEnabled\": 3165.0701016162184,\n    \"paybillEnabled\": false,\n    \"payoffAmount\": 6857.908686403569,\n    \"personalBankerName\": \"string\",\n    \"personalBankerContact\": {\n      \"email\": \"string\",\n      \"mobileNumber\": \"string\"\n    },\n    \"phone\": 4168.9654272623675,\n    \"postedBalance\": 5636.949623691954,\n    \"principalBalance\": \"string\",\n    \"productCode\": \"string\",\n    \"productName\": \"string\",\n    \"propertyAddress\": \"string\",\n    \"rewardPoints\": \"string\",\n    \"routingNumber\": \"string\",\n    \"statementDate\": \"string\",\n    \"status\": \"string\",\n    \"swiftCode\": \"string\",\n    \"totalBalance\": 3654.564673308107,\n    \"unbilledAmount\": 4418.213705648875,\n    \"valueAtMaturity\": 3582.421475681481,\n    \"holdAmount\": 5703.125489332366,\n    \"unclearFundsAmount\": 7591.489645799694,\n    \"averageMonthlyBalance\": 9660.657475676773,\n    \"netWithdrawableBalance\": 3914.863619522102,\n    \"totalTenure\": \"string\",\n    \"remainingTenure\": \"string\",\n    \"debitAccountNumber\": \"string\",\n    \"lateFee\": 4767.485761667786,\n    \"bounceCharge\": 5767.687585594217,\n    \"totalCharges\": 4639.322994595787,\n    \"overDueAmount\": 2445.1286782660354,\n    \"cardDetails\": [\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 4956.00033482619,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 7791.098008431787,\n        \"partialPaymentPaid\": 4605.581558143645\n      },\n      {\n        \"cardName\": \"string\",\n        \"cardNumber\": \"string\",\n        \"cardStatus\": \"string\",\n        \"cardImage\": \"string\",\n        \"cardType\": \"string\",\n        \"expDate\": \"string\",\n        \"displayCardStatus\": \"string\",\n        \"primaryCard\": \"string\",\n        \"cardChannelInfo\": {\n          \"ATM\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"offline\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"international\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"online\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          },\n          \"contactless\": {\n            \"enable\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            \"limit\": {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          }\n        },\n        \"cardRestrictions\": {\n          \"countries\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ],\n          \"MCC\": [\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            },\n            {\n              \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n            }\n          ]\n        },\n        \"blockReason\": \"string\",\n        \"nameOnCard\": \"string\",\n        \"cardNetwork\": \"string\",\n        \"autopay\": {\n          \"enabled\": true,\n          \"sourceAccountId\": \"string\",\n          \"paymentType\": \"string\",\n          \"onStatementDate\": false,\n          \"dayOfMonth\": \"string\"\n        },\n        \"dueAmount\": 3392.4023247479586,\n        \"dueDate\": \"string\",\n        \"minimumPaymentDue\": 1162.1625919753576,\n        \"partialPaymentPaid\": 8074.833522836042\n      }\n    ],\n    \"IsCrossAccount\": true\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountDetails"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountInfo\": [\n        {\n            \"accountType\": \"{{accountInfo_0.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_0.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_0.cardNumber_*number}}\"\n        },\n        {\n            \"accountType\": \"{{accountInfo_1.accountType_*string}}\",\n            \"accountNumber\": \"{{accountInfo_1.accountNumber_*number}}\",\n            \"cardNumber\": \"{{accountInfo_1.cardNumber_*number}}\"\n        }\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountDetails for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountName\n\n              pm.test(`'item field has accountName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountName`)) {\n                  const value = item?.accountName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNickname\n\n              pm.test(`'item field has accountNickname that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNickname`)) {\n                  const value = item?.accountNickname;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountType\n\n              pm.test(`'item field has accountType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountType`)) {\n                  const value = item?.accountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: activatedDate\n\n              pm.test(`'item field has activatedDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`activatedDate`)) {\n                  const value = item?.activatedDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableBalance\n\n              pm.test(`'item field has availableBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableBalance`)) {\n                  const value = item?.availableBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCash\n\n              pm.test(`'item field has availableCash that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCash`)) {\n                  const value = item?.availableCash;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCashLimit\n\n              pm.test(`'item field has availableCashLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCashLimit`)) {\n                  const value = item?.availableCashLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCredit\n\n              pm.test(`'item field has availableCredit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCredit`)) {\n                  const value = item?.availableCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: bankName\n\n              pm.test(`'item field has bankName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`bankName`)) {\n                  const value = item?.bankName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: branchName\n\n              pm.test(`'item field has branchName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`branchName`)) {\n                  const value = item?.branchName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardName\n\n              pm.test(`'item field has cardName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardName`)) {\n                  const value = item?.cardName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardNumber\n\n              pm.test(`'item field has cardNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                  const value = item?.cardNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardStatus\n\n              pm.test(`'item field has cardStatus that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardStatus`)) {\n                  const value = item?.cardStatus;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardType\n\n              pm.test(`'item field has cardType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardType`)) {\n                  const value = item?.cardType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: creditLimit\n\n              pm.test(`'item field has creditLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`creditLimit`)) {\n                  const value = item?.creditLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currentBalance\n\n              pm.test(`'item field has currentBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currentBalance`)) {\n                  const value = item?.currentBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: deactivatedDate\n\n              pm.test(`'item field has deactivatedDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`deactivatedDate`)) {\n                  const value = item?.deactivatedDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: dueAmount\n\n              pm.test(`'item field has dueAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`dueAmount`)) {\n                  const value = item?.dueAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: dueDate\n\n              pm.test(`'item field has dueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`dueDate`)) {\n                  const value = item?.dueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: earlyWithdrawalPenalty\n\n              pm.test(`'item field has earlyWithdrawalPenalty that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`earlyWithdrawalPenalty`)) {\n                  const value = item?.earlyWithdrawalPenalty;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: email\n\n              pm.test(`'item field has email that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`email`)) {\n                  const value = item?.email;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: expDate\n\n              pm.test(`'item field has expDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`expDate`)) {\n                  const value = item?.expDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: fdType\n\n              pm.test(`'item field has fdType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`fdType`)) {\n                  const value = item?.fdType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: image\n\n              pm.test(`'item field has image that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`image`)) {\n                  const value = item?.image;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: interestRate\n\n              pm.test(`'item field has interestRate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`interestRate`)) {\n                  const value = item?.interestRate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: internalTransferFromEnabled\n\n              pm.test(`'item field has internalTransferFromEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`internalTransferFromEnabled`)) {\n                  const value = item?.internalTransferFromEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: internalTransferToEnabled\n\n              pm.test(`'item field has internalTransferToEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`internalTransferToEnabled`)) {\n                  const value = item?.internalTransferToEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isPrimaryMobile\n\n              pm.test(`'item field has isPrimaryMobile that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isPrimaryMobile`)) {\n                  const value = item?.isPrimaryMobile;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isAlternateMobileNumber\n\n              pm.test(`'item field has isAlternateMobileNumber that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n                  const value = item?.isAlternateMobileNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: isStatement\n\n              pm.test(`'item field has isStatement that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`isStatement`)) {\n                  const value = item?.isStatement;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lastDrawDate\n\n              pm.test(`'item field has lastDrawDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lastDrawDate`)) {\n                  const value = item?.lastDrawDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: loanMaturityDate\n\n              pm.test(`'item field has loanMaturityDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`loanMaturityDate`)) {\n                  const value = item?.loanMaturityDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: loanOriginationDate\n\n              pm.test(`'item field has loanOriginationDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`loanOriginationDate`)) {\n                  const value = item?.loanOriginationDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: location\n\n              pm.test(`'item field has location that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`location`)) {\n                  const value = item?.location;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lastUpdated\n\n              pm.test(`'item field has lastUpdated that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lastUpdated`)) {\n                  const value = item?.lastUpdated;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: maxTransactionLimit\n\n              pm.test(`'item field has maxTransactionLimit that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maxTransactionLimit`)) {\n                  const value = item?.maxTransactionLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: maturityDate\n\n              pm.test(`'item field has maturityDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maturityDate`)) {\n                  const value = item?.maturityDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: minimumPaymentDue\n\n              pm.test(`'item field has minimumPaymentDue that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`minimumPaymentDue`)) {\n                  const value = item?.minimumPaymentDue;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: minimumBalance\n\n              pm.test(`'item field has minimumBalance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`minimumBalance`)) {\n                  const value = item?.minimumBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: monthlyPayment\n\n              pm.test(`'item field has monthlyPayment that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthlyPayment`)) {\n                  const value = item?.monthlyPayment;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: openingBalance\n\n              pm.test(`'item field has openingBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`openingBalance`)) {\n                  const value = item?.openingBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: originalLoanAmount\n\n              pm.test(`'item field has originalLoanAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`originalLoanAmount`)) {\n                  const value = item?.originalLoanAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: P2PLimit\n\n              pm.test(`'item field has P2PLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`P2PLimit`)) {\n                  const value = item?.P2PLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: p2pEnabled\n\n              pm.test(`'item field has p2pEnabled that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`p2pEnabled`)) {\n                  const value = item?.p2pEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: paybillEnabled\n\n              pm.test(`'item field has paybillEnabled that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`paybillEnabled`)) {\n                  const value = item?.paybillEnabled;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: payoffAmount\n\n              pm.test(`'item field has payoffAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`payoffAmount`)) {\n                  const value = item?.payoffAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: personalBankerName\n\n              pm.test(`'item field has personalBankerName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`personalBankerName`)) {\n                  const value = item?.personalBankerName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: personalBankerContact\n\n              pm.test(`'item field has personalBankerContact that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`personalBankerContact`)) {\n                  const value = item?.personalBankerContact;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.personalBankerContact\n              // subKey: email\n\n              pm.test(`'item.personalBankerContact field has email that is of type string'`, function() {\n                let parent = item.personalBankerContact;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`email`)) {\n                  const value = item.personalBankerContact?.email;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.personalBankerContact\n              // subKey: mobileNumber\n\n              pm.test(`'item.personalBankerContact field has mobileNumber that is of type string'`, function() {\n                let parent = item.personalBankerContact;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n                  const value = item.personalBankerContact?.mobileNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: phone\n\n              pm.test(`'item field has phone that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`phone`)) {\n                  const value = item?.phone;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: postedBalance\n\n              pm.test(`'item field has postedBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`postedBalance`)) {\n                  const value = item?.postedBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: principalBalance\n\n              pm.test(`'item field has principalBalance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`principalBalance`)) {\n                  const value = item?.principalBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: productCode\n\n              pm.test(`'item field has productCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`productCode`)) {\n                  const value = item?.productCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: productName\n\n              pm.test(`'item field has productName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`productName`)) {\n                  const value = item?.productName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: propertyAddress\n\n              pm.test(`'item field has propertyAddress that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`propertyAddress`)) {\n                  const value = item?.propertyAddress;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: rewardPoints\n\n              pm.test(`'item field has rewardPoints that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`rewardPoints`)) {\n                  const value = item?.rewardPoints;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: routingNumber\n\n              pm.test(`'item field has routingNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`routingNumber`)) {\n                  const value = item?.routingNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: statementDate\n\n              pm.test(`'item field has statementDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`statementDate`)) {\n                  const value = item?.statementDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: swiftCode\n\n              pm.test(`'item field has swiftCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`swiftCode`)) {\n                  const value = item?.swiftCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalBalance\n\n              pm.test(`'item field has totalBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalBalance`)) {\n                  const value = item?.totalBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: unbilledAmount\n\n              pm.test(`'item field has unbilledAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`unbilledAmount`)) {\n                  const value = item?.unbilledAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: valueAtMaturity\n\n              pm.test(`'item field has valueAtMaturity that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`valueAtMaturity`)) {\n                  const value = item?.valueAtMaturity;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: holdAmount\n\n              pm.test(`'item field has holdAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`holdAmount`)) {\n                  const value = item?.holdAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: unclearFundsAmount\n\n              pm.test(`'item field has unclearFundsAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`unclearFundsAmount`)) {\n                  const value = item?.unclearFundsAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: averageMonthlyBalance\n\n              pm.test(`'item field has averageMonthlyBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`averageMonthlyBalance`)) {\n                  const value = item?.averageMonthlyBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: netWithdrawableBalance\n\n              pm.test(`'item field has netWithdrawableBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`netWithdrawableBalance`)) {\n                  const value = item?.netWithdrawableBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalTenure\n\n              pm.test(`'item field has totalTenure that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalTenure`)) {\n                  const value = item?.totalTenure;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: remainingTenure\n\n              pm.test(`'item field has remainingTenure that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`remainingTenure`)) {\n                  const value = item?.remainingTenure;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: debitAccountNumber\n\n              pm.test(`'item field has debitAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`debitAccountNumber`)) {\n                  const value = item?.debitAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: lateFee\n\n              pm.test(`'item field has lateFee that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`lateFee`)) {\n                  const value = item?.lateFee;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: bounceCharge\n\n              pm.test(`'item field has bounceCharge that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`bounceCharge`)) {\n                  const value = item?.bounceCharge;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: totalCharges\n\n              pm.test(`'item field has totalCharges that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`totalCharges`)) {\n                  const value = item?.totalCharges;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: overDueAmount\n\n              pm.test(`'item field has overDueAmount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`overDueAmount`)) {\n                  const value = item?.overDueAmount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // array condition without arrayName and parent property is an array\n              pm.test(`'item has 'cardDetails' as type array'`, function() {\n                const value = item?.cardDetails;\n\n                if (value !== null && value !== undefined) {\n                  pm.expect(Array.isArray(value)).to.equal(true);\n                }\n\n              })\n\n\n              pm.test(`Each object in the item.cardDetails field has all the required fields and correct data-types`, function() {\n                if (pm.expect(item).to.have.nested.property(`cardDetails`)) {\n                  let cardDetailsArray = ld.get(item, `cardDetails`, []);\n                  if (Array.isArray(cardDetailsArray)) {\n                    for (let cardDetails_it = 0; cardDetails_it < cardDetailsArray.length; cardDetails_it++) {\n                      let iterator = cardDetails_it;\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardName' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardName;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNumber' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardNumber;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardStatus' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardStatus;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardImage' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardImage;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardType' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardType;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'expDate' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.expDate;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'displayCardStatus' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.displayCardStatus;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'primaryCard' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.primaryCard;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardChannelInfo' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardChannelInfo;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: ATM\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has ATM that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`ATM`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.ATM;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.ATM`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.ATM\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.ATM field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.ATM;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.ATM?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.ATM?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: offline\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has offline that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`offline`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.offline;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.offline`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.offline?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.offline\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.offline field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.offline;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.offline?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.offline?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: international\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has international that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`international`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.international;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.international`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.international?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.international\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.international field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.international;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.international?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.international?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: online\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has online that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`online`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.online;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.online`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.online?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.online\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.online field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.online;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.online?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.online?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo\n                        // subKey: contactless\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo field has contactless that is of type object'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`contactless`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo?.contactless;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo?.contactless`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"object\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                        // subKey: enable\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has enable that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enable`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.enable;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.enable`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].cardChannelInfo.contactless\n                        // subKey: limit\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].cardChannelInfo.contactless field has limit that is of type number'`, function() {\n                          let parent = cardDetailsArray[iterator].cardChannelInfo.contactless;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`limit`)) {\n                            const value = cardDetailsArray[iterator].cardChannelInfo.contactless?.limit;\n                            console.log(`cardDetailsArray[iterator].cardChannelInfo.contactless?.limit`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"number\");\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardRestrictions' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardRestrictions;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // array condition and parent property is not an array\n                        pm.test(`'Response has the `\n                          cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                          function() {\n                            if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                              const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                              if (value !== null && value !== undefined) {\n                                pm.expect(Array.isArray(value)).to.equal(true);\n                              }\n\n                            }\n                          })\n\n                        pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.countries field has all the required fields and correct data-types`, function() {\n                          if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`countries`)) {\n                            let countriesArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `countries`, []);\n                            if (Array.isArray(countriesArray)) {\n                              for (let countries_it = 0; countries_it < countriesArray.length; countries_it++) {\n                                let iterator = countries_it;\n                                if (countriesArray[countries_it] !== null && countriesArray[countries_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at countriesArray[${iterator}]' has 'countrycode' as type 'string'`, function() {\n                                    const value = countriesArray[iterator]?.countrycode;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                              }\n                            }\n                          }\n                        })\n\n                        // array condition and parent property is not an array\n                        pm.test(`'Response has the `\n                          cardDetailsArray[iterator].cardRestrictions` field of type array'`,\n                          function() {\n                            if (pm.expect(item).to.have.nested.property(`cardDetailsArray[iterator].cardRestrictions`)) {\n                              const value = responseData?.cardDetailsArray[iterator].cardRestrictions;\n\n                              if (value !== null && value !== undefined) {\n                                pm.expect(Array.isArray(value)).to.equal(true);\n                              }\n\n                            }\n                          })\n\n                        pm.test(`Each object in the cardDetailsArray[${iterator}].cardRestrictions.MCC field has all the required fields and correct data-types`, function() {\n                          if (pm.expect(cardDetailsArray[iterator].cardRestrictions).to.have.nested.property(`MCC`)) {\n                            let MCCArray = ld.get(cardDetailsArray[iterator].cardRestrictions, `MCC`, []);\n                            if (Array.isArray(MCCArray)) {\n                              for (let MCC_it = 0; MCC_it < MCCArray.length; MCC_it++) {\n                                let iterator = MCC_it;\n                                if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at MCCArray[${iterator}]' has 'name' as type 'string'`, function() {\n                                    const value = MCCArray[iterator]?.name;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                                if (MCCArray[MCC_it] !== null && MCCArray[MCC_it] !== undefined) {\n\n                                  // Condition: Raw data type with defined arrayName and parent property is an array\n                                  pm.test(`'Item at MCCArray[${iterator}]' has 'description' as type 'string'`, function() {\n                                    const value = MCCArray[iterator]?.description;\n\n                                    if (!ld.isEmpty(value)) {\n                                      pm.expect(typeof value).to.equal(\"string\");\n                                    }\n                                  })\n\n\n                                }\n                              }\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'blockReason' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.blockReason;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'nameOnCard' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.nameOnCard;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'cardNetwork' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.cardNetwork;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'autopay' as type 'object'`, function() {\n                          const value = cardDetailsArray[iterator]?.autopay;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"object\");\n                          }\n                        })\n\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: enabled\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has enabled that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`enabled`)) {\n                            const value = cardDetailsArray[iterator].autopay?.enabled;\n                            console.log(`cardDetailsArray[iterator].autopay?.enabled`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: sourceAccountId\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has sourceAccountId that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`sourceAccountId`)) {\n                            const value = cardDetailsArray[iterator].autopay?.sourceAccountId;\n                            console.log(`cardDetailsArray[iterator].autopay?.sourceAccountId`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: paymentType\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has paymentType that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`paymentType`)) {\n                            const value = cardDetailsArray[iterator].autopay?.paymentType;\n                            console.log(`cardDetailsArray[iterator].autopay?.paymentType`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: onStatementDate\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has onStatementDate that is of type boolean'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`onStatementDate`)) {\n                            const value = cardDetailsArray[iterator].autopay?.onStatementDate;\n                            console.log(`cardDetailsArray[iterator].autopay?.onStatementDate`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"boolean\");\n                            }\n                          }\n                        })\n\n                        // Condition: Raw data type, got arrayName and parent property is not an array\n                        // pathStr: cardDetailsArray[${iterator}].autopay\n                        // subKey: dayOfMonth\n                        // array: cardDetailsArray\n\n\n                        pm.test(`'cardDetailsArray[${iterator}].autopay field has dayOfMonth that is of type string'`, function() {\n                          let parent = cardDetailsArray[iterator].autopay;\n                          // console.log(parent);\n                          if (pm.expect(parent).to.have.nested.property(`dayOfMonth`)) {\n                            const value = cardDetailsArray[iterator].autopay?.dayOfMonth;\n                            console.log(`cardDetailsArray[iterator].autopay?.dayOfMonth`, value);\n\n                            if (!ld.isEmpty(value)) {\n                              pm.expect(typeof value).to.equal(\"string\");\n                            }\n                          }\n                        })\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueAmount' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.dueAmount;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'dueDate' as type 'string'`, function() {\n                          const value = cardDetailsArray[iterator]?.dueDate;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"string\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'minimumPaymentDue' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.minimumPaymentDue;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                      if (cardDetailsArray[cardDetails_it] !== null && cardDetailsArray[cardDetails_it] !== undefined) {\n\n                        // Condition: Raw data type with defined arrayName and parent property is an array\n                        pm.test(`'Item at cardDetailsArray[${iterator}]' has 'partialPaymentPaid' as type 'number'`, function() {\n                          const value = cardDetailsArray[iterator]?.partialPaymentPaid;\n\n                          if (!ld.isEmpty(value)) {\n                            pm.expect(typeof value).to.equal(\"number\");\n                          }\n                        })\n\n\n                      }\n                    }\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: IsCrossAccount\n\n              pm.test(`'item field has IsCrossAccount that is of type boolean'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`IsCrossAccount`)) {\n                  const value = item?.IsCrossAccount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"boolean\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountsLimit"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"balance\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"currency\": \"string\",\n    \"customerId\": 703.7382295158534,\n    \"perTxn\": 7206.451260407758,\n    \"status\": \"string\",\n    \"availableCashLimit\": 852.8856897754,\n    \"creditLimit\": 77.40687995480667,\n    \"availableCredit\": 5897.555093890516,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 4138.749841938489,\n          \"maximum\": 1817.5468258807025,\n          \"spent\": 4555.676488662215\n        },\n        \"daily\": {\n          \"available\": 6392.296570981397,\n          \"maximum\": 5818.846132588254,\n          \"spent\": 4047.03132186272\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 5962.447295891995,\n          \"maximum\": 5376.991938332822,\n          \"usedup\": 405.2278305545021\n        },\n        \"daily\": {\n          \"available\": 1662.3256911142726,\n          \"maximum\": 6327.755131446819,\n          \"usedup\": 1967.8758930485628\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 4424.902414024165,\n      \"maximum\": 3412.016646465308,\n      \"usedup\": 5083.638993117385,\n      \"amountperday\": 2162.5985097641797\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 2114.3574577390955,\n          \"maximum\": 515.326453209517,\n          \"spent\": 3940.075035912063\n        },\n        \"daily\": {\n          \"available\": 3909.356886326629,\n          \"maximum\": 6491.5476335384255,\n          \"spent\": 1995.7292374328529\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 9084.376652746016,\n          \"maximum\": 4539.69222261102,\n          \"usedup\": 5073.65930086834\n        },\n        \"daily\": {\n          \"available\": 7773.718968414553,\n          \"maximum\": 2479.66138224069,\n          \"usedup\": 8255.659397389947\n        }\n      }\n    }\n  },\n  {\n    \"accountName\": \"string\",\n    \"accountNickname\": \"string\",\n    \"accountNumber\": \"string\",\n    \"accountType\": \"string\",\n    \"balance\": \"string\",\n    \"cardName\": \"string\",\n    \"cardNumber\": \"string\",\n    \"currency\": \"string\",\n    \"customerId\": 7684.445333635883,\n    \"perTxn\": 3292.065849832031,\n    \"status\": \"string\",\n    \"availableCashLimit\": 4347.417257121495,\n    \"creditLimit\": 1116.4097068909439,\n    \"availableCredit\": 6041.009665170449,\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 9690.971022411068,\n          \"maximum\": 5559.986712464371,\n          \"spent\": 1780.0135958739083\n        },\n        \"daily\": {\n          \"available\": 6705.981080194032,\n          \"maximum\": 6968.171177116753,\n          \"spent\": 2079.779220485578\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 3955.6876050874102,\n          \"maximum\": 4371.7865259457485,\n          \"usedup\": 5694.265353098691\n        },\n        \"daily\": {\n          \"available\": 4299.428332901778,\n          \"maximum\": 7473.793060725787,\n          \"usedup\": 3129.969255324787\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 6918.481419718399,\n      \"maximum\": 1844.2143021631275,\n      \"usedup\": 1320.5934524425534,\n      \"amountperday\": 7334.651105636216\n    },\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 6125.987973583793,\n          \"maximum\": 4714.267771559375,\n          \"spent\": 6798.904813514077\n        },\n        \"daily\": {\n          \"available\": 5833.07852734291,\n          \"maximum\": 9706.646091181661,\n          \"spent\": 9323.704029161592\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 119.32327289848388,\n          \"maximum\": 4122.092834475448,\n          \"usedup\": 7877.646326104473\n        },\n        \"daily\": {\n          \"available\": 1801.165822216444,\n          \"maximum\": 3681.018828292153,\n          \"usedup\": 1684.6646625455674\n        }\n      }\n    }\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountsLimit"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountsLimit for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountName\n\n              pm.test(`'item field has accountName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountName`)) {\n                  const value = item?.accountName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNickname\n\n              pm.test(`'item field has accountNickname that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNickname`)) {\n                  const value = item?.accountNickname;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountType\n\n              pm.test(`'item field has accountType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountType`)) {\n                  const value = item?.accountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: balance\n\n              pm.test(`'item field has balance that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`balance`)) {\n                  const value = item?.balance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardName\n\n              pm.test(`'item field has cardName that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardName`)) {\n                  const value = item?.cardName;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: cardNumber\n\n              pm.test(`'item field has cardNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                  const value = item?.cardNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: perTxn\n\n              pm.test(`'item field has perTxn that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`perTxn`)) {\n                  const value = item?.perTxn;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCashLimit\n\n              pm.test(`'item field has availableCashLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCashLimit`)) {\n                  const value = item?.availableCashLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: creditLimit\n\n              pm.test(`'item field has creditLimit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`creditLimit`)) {\n                  const value = item?.creditLimit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: availableCredit\n\n              pm.test(`'item field has availableCredit that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`availableCredit`)) {\n                  const value = item?.availableCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: purchase\n\n              pm.test(`'item field has purchase that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`purchase`)) {\n                  const value = item?.purchase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: limits\n\n              pm.test(`'item.purchase field has limits that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.purchase?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: monthly\n\n              pm.test(`'item.purchase.limits field has monthly that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: daily\n\n              pm.test(`'item.purchase.limits field has daily that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: transactions\n\n              pm.test(`'item.purchase field has transactions that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.purchase?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: monthly\n\n              pm.test(`'item.purchase.transactions field has monthly that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: daily\n\n              pm.test(`'item.purchase.transactions field has daily that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: txnsPerDay\n\n              pm.test(`'item field has txnsPerDay that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`txnsPerDay`)) {\n                  const value = item?.txnsPerDay;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: available\n\n              pm.test(`'item.txnsPerDay field has available that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.txnsPerDay?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: maximum\n\n              pm.test(`'item.txnsPerDay field has maximum that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.txnsPerDay?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: usedup\n\n              pm.test(`'item.txnsPerDay field has usedup that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.txnsPerDay?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: amountperday\n\n              pm.test(`'item.txnsPerDay field has amountperday that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amountperday`)) {\n                  const value = item.txnsPerDay?.amountperday;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: withdrawal\n\n              pm.test(`'item field has withdrawal that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`withdrawal`)) {\n                  const value = item?.withdrawal;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: limits\n\n              pm.test(`'item.withdrawal field has limits that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.withdrawal?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.limits field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.limits field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: transactions\n\n              pm.test(`'item.withdrawal field has transactions that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.withdrawal?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.transactions field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.transactions field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to get the limits of customer accounts",
      "request": {
        "name": "to get the limits of customer accounts",
        "description": {
          "content": "fetch customer account limits",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetAccountSpecificLimitsInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 1045300,\n    \"currency\": \"USD\",\n    \"withdrawal\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"purchase\": {\n      \"limits\": {\n        \"monthly\": {\n          \"available\": 5000,\n          \"maximum\": 8000,\n          \"spent\": 3000\n        },\n        \"daily\": {\n          \"available\": 500,\n          \"maximum\": 800,\n          \"spent\": 300\n        }\n      },\n      \"transactions\": {\n        \"monthly\": {\n          \"available\": 20,\n          \"maximum\": 30,\n          \"usedup\": 10\n        },\n        \"daily\": {\n          \"available\": 5,\n          \"maximum\": 8,\n          \"usedup\": 3\n        }\n      }\n    },\n    \"txnsPerDay\": {\n      \"available\": 5,\n      \"maximum\": 8,\n      \"usedup\": 3,\n      \"amount\": 500\n    },\n    \"perTxn\": 500\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetAccountSpecificLimitsInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": [\n        \"{{accountNumber_0_*number}}\"\n    ],\n    \"cardNumber\": [\n        \"{{cardNumber_0_*string}}\",\n        \"{{cardNumber_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetAccountSpecificLimitsInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: perTxn\n\n              pm.test(`'item field has perTxn that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`perTxn`)) {\n                  const value = item?.perTxn;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: purchase\n\n              pm.test(`'item field has purchase that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`purchase`)) {\n                  const value = item?.purchase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: limits\n\n              pm.test(`'item.purchase field has limits that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.purchase?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: monthly\n\n              pm.test(`'item.purchase.limits field has monthly that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits\n              // subKey: daily\n\n              pm.test(`'item.purchase.limits field has daily that is of type object'`, function() {\n                let parent = item.purchase.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.limits.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.purchase.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.purchase.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.purchase.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase\n              // subKey: transactions\n\n              pm.test(`'item.purchase field has transactions that is of type object'`, function() {\n                let parent = item.purchase;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.purchase?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: monthly\n\n              pm.test(`'item.purchase.transactions field has monthly that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.purchase.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions\n              // subKey: daily\n\n              pm.test(`'item.purchase.transactions field has daily that is of type object'`, function() {\n                let parent = item.purchase.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.purchase.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.purchase.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.purchase.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.purchase.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.purchase.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.purchase.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.purchase.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.purchase.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.purchase.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: txnsPerDay\n\n              pm.test(`'item field has txnsPerDay that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`txnsPerDay`)) {\n                  const value = item?.txnsPerDay;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: available\n\n              pm.test(`'item.txnsPerDay field has available that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.txnsPerDay?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: maximum\n\n              pm.test(`'item.txnsPerDay field has maximum that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.txnsPerDay?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: usedup\n\n              pm.test(`'item.txnsPerDay field has usedup that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.txnsPerDay?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.txnsPerDay\n              // subKey: amount\n\n              pm.test(`'item.txnsPerDay field has amount that is of type number'`, function() {\n                let parent = item.txnsPerDay;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amount`)) {\n                  const value = item.txnsPerDay?.amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: withdrawal\n\n              pm.test(`'item field has withdrawal that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`withdrawal`)) {\n                  const value = item?.withdrawal;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: limits\n\n              pm.test(`'item.withdrawal field has limits that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`limits`)) {\n                  const value = item.withdrawal?.limits;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.limits field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.limits?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.monthly\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.monthly field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.monthly?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.limits field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.limits;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.limits?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.limits.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.limits.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.limits.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.limits.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.limits.daily\n              // subKey: spent\n\n              pm.test(`'item.withdrawal.limits.daily field has spent that is of type number'`, function() {\n                let parent = item.withdrawal.limits.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`spent`)) {\n                  const value = item.withdrawal.limits.daily?.spent;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal\n              // subKey: transactions\n\n              pm.test(`'item.withdrawal field has transactions that is of type object'`, function() {\n                let parent = item.withdrawal;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactions`)) {\n                  const value = item.withdrawal?.transactions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: monthly\n\n              pm.test(`'item.withdrawal.transactions field has monthly that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`monthly`)) {\n                  const value = item.withdrawal.transactions?.monthly;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.monthly field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.monthly?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.monthly field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.monthly?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.monthly\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.monthly field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.monthly;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.monthly?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions\n              // subKey: daily\n\n              pm.test(`'item.withdrawal.transactions field has daily that is of type object'`, function() {\n                let parent = item.withdrawal.transactions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`daily`)) {\n                  const value = item.withdrawal.transactions?.daily;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: available\n\n              pm.test(`'item.withdrawal.transactions.daily field has available that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`available`)) {\n                  const value = item.withdrawal.transactions.daily?.available;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: maximum\n\n              pm.test(`'item.withdrawal.transactions.daily field has maximum that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`maximum`)) {\n                  const value = item.withdrawal.transactions.daily?.maximum;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.withdrawal.transactions.daily\n              // subKey: usedup\n\n              pm.test(`'item.withdrawal.transactions.daily field has usedup that is of type number'`, function() {\n                let parent = item.withdrawal.transactions.daily;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usedup`)) {\n                  const value = item.withdrawal.transactions.daily?.usedup;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateAccountInfo",
      "request": {
        "name": "UpdateAccountInfo",
        "description": {
          "content": "Update customer account details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateAccountInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateAccountInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\",\n    \"isStatement\": \"{{isStatement_*boolean}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateAccountInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCustomerInfo",
      "request": {
        "name": "GetCustomerInfo",
        "description": {
          "content": "fetch customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"alternatePhoneNumber\": 1000.5647362510883,\n  \"customerId\": \"string\",\n  \"email\": \"string\",\n  \"identificationNumber\": 2786.5818872784876,\n  \"identificationType\": \"string\",\n  \"image\": \"string\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": true,\n  \"location\": \"string\",\n  \"name\": \"string\",\n  \"firstName\": \"string\",\n  \"lastName\": \"string\",\n  \"personalBanker\": {\n    \"name\": \"string\",\n    \"email\": \"string\",\n    \"mobileNumber\": \"string\"\n  },\n  \"phone\": 142.00759203598423,\n  \"securityQuestions\": [\n    \"string\",\n    \"string\"\n  ],\n  \"segmentId\": 5906.500559597636\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCustomerInfo for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alternatePhoneNumber\n\n        pm.test(`'responseData field has alternatePhoneNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alternatePhoneNumber`)) {\n            const value = responseData?.alternatePhoneNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: email\n\n        pm.test(`'responseData field has email that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationNumber\n\n        pm.test(`'responseData field has identificationNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationNumber`)) {\n            const value = responseData?.identificationNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationType\n\n        pm.test(`'responseData field has identificationType that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationType`)) {\n            const value = responseData?.identificationType;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: image\n\n        pm.test(`'responseData field has image that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`image`)) {\n            const value = responseData?.image;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isAlternateMobileNumber\n\n        pm.test(`'responseData field has isAlternateMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n            const value = responseData?.isAlternateMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isPrimaryMobileNumber\n\n        pm.test(`'responseData field has isPrimaryMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isPrimaryMobileNumber`)) {\n            const value = responseData?.isPrimaryMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: firstName\n\n        pm.test(`'responseData field has firstName that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`firstName`)) {\n            const value = responseData?.firstName;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: lastName\n\n        pm.test(`'responseData field has lastName that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`lastName`)) {\n            const value = responseData?.lastName;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalBanker\n\n        pm.test(`'responseData field has personalBanker that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalBanker`)) {\n            const value = responseData?.personalBanker;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: name\n\n        pm.test(`'responseData.personalBanker field has name that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.personalBanker?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: email\n\n        pm.test(`'responseData.personalBanker field has email that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData.personalBanker?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: mobileNumber\n\n        pm.test(`'responseData.personalBanker field has mobileNumber that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n            const value = responseData.personalBanker?.mobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: phone\n\n        pm.test(`'responseData field has phone that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`phone`)) {\n            const value = responseData?.phone;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'securityQuestions' as type array'`, function() {\n          const value = responseData?.securityQuestions;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: segmentId\n\n        pm.test(`'responseData field has segmentId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`segmentId`)) {\n            const value = responseData?.segmentId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateCustomerInfo",
      "request": {
        "name": "UpdateCustomerInfo",
        "description": {
          "content": "Update customer information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateCustomerInfo"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateCustomerInfo"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"alternatePhoneNumber\": \"{{alternatePhoneNumber_*number}}\",\n    \"isAlternateMobileNumber\": \"{{isAlternateMobileNumber_*boolean}}\",\n    \"phone\": \"{{phone_*number}}\",\n    \"isPrimaryMobileNumber\": \"{{isPrimaryMobileNumber_*boolean}}\",\n    \"location\": \"{{location_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateCustomerInfo for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetTransactions",
      "request": {
        "name": "GetTransactions",
        "description": {
          "content": "Fetch transactions information",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetTransactions"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "disabled": false,
            "key": "X_Auth_token",
            "value": "{{X_Auth_token}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "X_CORRELATION_ID",
            "value": "{{X_CORRELATION_ID}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "GetTransactions"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "X_Auth_token",
                "value": "{{X_Auth_token}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "X_CORRELATION_ID",
                "value": "{{X_CORRELATION_ID}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": [\n        \"{{accountNumber_0_*string}}\",\n        \"{{accountNumber_1_*string}}\"\n    ],\n    \"customerId\": \"{{customerId_*string}}\",\n    \"numOfTransactions\": \"{{numOfTransactions_*number}}\",\n    \"status\": \"{{status_*string}}\",\n    \"startDate\": \"{{startDate_*date}}\",\n    \"endDate\": \"{{endDate_*date}}\",\n    \"sort\": {\n        \"type\": \"{{sort.type_*string}}\",\n        \"value\": \"{{sort.value_*string}}\"\n    },\n    \"transactionAmount\": {\n        \"amount1\": \"{{transactionAmount.amount1_*number}}\",\n        \"amount\": {},\n        \"currency\": \"{{transactionAmount.currency_*string}}\"\n    },\n    \"category\": [\n        {\n            \"codeType\": \"{{category_0.codeType_*string}}\",\n            \"value\": [\n                \"{{category_0.value_0_*string}}\",\n                \"{{category_0.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_0.source_*string}}\"\n        },\n        {\n            \"codeType\": \"{{category_1.codeType_*string}}\",\n            \"value\": [\n                \"{{category_1.value_0_*string}}\",\n                \"{{category_1.value_1_*string}}\"\n            ],\n            \"source\": \"{{category_1.source_*string}}\"\n        }\n    ],\n    \"debitOrCredit\": \"{{debitOrCredit_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"customerId\": 5304.736940054884,\n    \"transactionId\": 8985.872121074593,\n    \"accountNumber\": \"string\",\n    \"timestamp\": 2292.6381090794034,\n    \"amount\": 1048.5446757516747,\n    \"currency\": \"string\",\n    \"debitOrCredit\": \"string\",\n    \"description\": \"string\",\n    \"paymentMode\": \"string\",\n    \"DBANames\": \"string\",\n    \"status\": \"string\",\n    \"closingBalance\": 7610.22261384833,\n    \"transacitonType\": \"string\",\n    \"ACHCode\": \"string\",\n    \"MCCCode\": \"string\",\n    \"SICCode\": \"string\",\n    \"name\": \"string\",\n    \"address\": \"string\",\n    \"street\": \"string\",\n    \"city\": \"string\",\n    \"state\": \"string\",\n    \"zip\": \"string\",\n    \"country\": \"string\",\n    \"phoneNumber\": 3545.408011405917,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  },\n  {\n    \"customerId\": 5766.506577100943,\n    \"transactionId\": 7836.9645409898485,\n    \"accountNumber\": \"string\",\n    \"timestamp\": 980.5773025427378,\n    \"amount\": 8597.492561566256,\n    \"currency\": \"string\",\n    \"debitOrCredit\": \"string\",\n    \"description\": \"string\",\n    \"paymentMode\": \"string\",\n    \"DBANames\": \"string\",\n    \"status\": \"string\",\n    \"closingBalance\": 4991.075272453071,\n    \"transacitonType\": \"string\",\n    \"ACHCode\": \"string\",\n    \"MCCCode\": \"string\",\n    \"SICCode\": \"string\",\n    \"name\": \"string\",\n    \"address\": \"string\",\n    \"street\": \"string\",\n    \"city\": \"string\",\n    \"state\": \"string\",\n    \"zip\": \"string\",\n    \"country\": \"string\",\n    \"phoneNumber\": 4744.578447947139,\n    \"metaInfo\": [\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      },\n      {\n        \"name\": \"string\",\n        \"value\": \"string\"\n      }\n    ]\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetTransactions for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: customerId\n\n              pm.test(`'item field has customerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n                  const value = item?.customerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: transactionId\n\n              pm.test(`'item field has transactionId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transactionId`)) {\n                  const value = item?.transactionId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: accountNumber\n\n              pm.test(`'item field has accountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n                  const value = item?.accountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: timestamp\n\n              pm.test(`'item field has timestamp that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`timestamp`)) {\n                  const value = item?.timestamp;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: amount\n\n              pm.test(`'item field has amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amount`)) {\n                  const value = item?.amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: currency\n\n              pm.test(`'item field has currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`currency`)) {\n                  const value = item?.currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: debitOrCredit\n\n              pm.test(`'item field has debitOrCredit that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`debitOrCredit`)) {\n                  const value = item?.debitOrCredit;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: description\n\n              pm.test(`'item field has description that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`description`)) {\n                  const value = item?.description;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: paymentMode\n\n              pm.test(`'item field has paymentMode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`paymentMode`)) {\n                  const value = item?.paymentMode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DBANames\n\n              pm.test(`'item field has DBANames that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DBANames`)) {\n                  const value = item?.DBANames;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: status\n\n              pm.test(`'item field has status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`status`)) {\n                  const value = item?.status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: closingBalance\n\n              pm.test(`'item field has closingBalance that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`closingBalance`)) {\n                  const value = item?.closingBalance;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: transacitonType\n\n              pm.test(`'item field has transacitonType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`transacitonType`)) {\n                  const value = item?.transacitonType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ACHCode\n\n              pm.test(`'item field has ACHCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ACHCode`)) {\n                  const value = item?.ACHCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: MCCCode\n\n              pm.test(`'item field has MCCCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`MCCCode`)) {\n                  const value = item?.MCCCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SICCode\n\n              pm.test(`'item field has SICCode that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SICCode`)) {\n                  const value = item?.SICCode;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: name\n\n              pm.test(`'item field has name that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`name`)) {\n                  const value = item?.name;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: address\n\n              pm.test(`'item field has address that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`address`)) {\n                  const value = item?.address;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: street\n\n              pm.test(`'item field has street that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`street`)) {\n                  const value = item?.street;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: city\n\n              pm.test(`'item field has city that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`city`)) {\n                  const value = item?.city;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: state\n\n              pm.test(`'item field has state that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`state`)) {\n                  const value = item?.state;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: zip\n\n              pm.test(`'item field has zip that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`zip`)) {\n                  const value = item?.zip;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: country\n\n              pm.test(`'item field has country that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`country`)) {\n                  const value = item?.country;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: phoneNumber\n\n              pm.test(`'item field has phoneNumber that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`phoneNumber`)) {\n                  const value = item?.phoneNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // array condition without arrayName and parent property is an array\n              pm.test(`'item has 'metaInfo' as type array'`, function() {\n                const value = item?.metaInfo;\n\n                if (value !== null && value !== undefined) {\n                  pm.expect(Array.isArray(value)).to.equal(true);\n                }\n\n              })\n\n\n              pm.test(`Each object in the item.metaInfo field has all the required fields and correct data-types`, function() {\n                if (pm.expect(item).to.have.nested.property(`metaInfo`)) {\n                  let metaInfoArray = ld.get(item, `metaInfo`, []);\n                  if (Array.isArray(metaInfoArray)) {\n                    for (let metaInfo_it = 0; metaInfo_it < metaInfoArray.length; metaInfo_it++) {\n                      let iterator = metaInfo_it;\n                      // Condition: Raw data type with defined arrayName and parent property is an array\n                      pm.test(`'Item at metaInfoArray[${iterator}]' has 'name' as type 'string'`, function() {\n                        const value = metaInfoArray[iterator]?.name;\n\n                        pm.expect(typeof value).to.equal(\"string\");\n\n                      })\n\n\n                      // Condition: Raw data type with defined arrayName and parent property is an array\n                      pm.test(`'Item at metaInfoArray[${iterator}]' has 'value' as type 'string'`, function() {\n                        const value = metaInfoArray[iterator]?.value;\n\n                        pm.expect(typeof value).to.equal(\"string\");\n\n                      })\n\n\n                    }\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "TransferFunds",
      "request": {
        "name": "TransferFunds",
        "description": {
          "content": "Transfers funds between accounts",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "TransferFunds"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*string}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Transaction success",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "TransferFunds"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"date\": \"{{date_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"TransactionType\": \"{{TransactionType_*number}}\",\n    \"PaymentType\": \"{{PaymentType_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for TransferFunds for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Transaction success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetScheduleTransfers",
      "request": {
        "name": "GetScheduleTransfers",
        "description": {
          "content": "Fetches the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 7575.653478705398,\n    \"Amount\": 1273.1891462798717,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"InvoiceNumber\": 245.1878090786086,\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 8491.72713163142,\n    \"NextScheduleDate\": 7941.7248996913495,\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 4947.502143602531,\n    \"Amount\": 3475.0238348130424,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"InvoiceNumber\": 3925.947088756947,\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 7569.422691604044,\n    \"NextScheduleDate\": 6431.706860683175,\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: InvoiceNumber\n\n              pm.test(`'item field has InvoiceNumber that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`InvoiceNumber`)) {\n                  const value = item?.InvoiceNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ScheduledDate\n\n              pm.test(`'item field has ScheduledDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ScheduledDate`)) {\n                  const value = item?.ScheduledDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: NextScheduleDate\n\n              pm.test(`'item field has NextScheduleDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`NextScheduleDate`)) {\n                  const value = item?.NextScheduleDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateScheduleTransfers",
      "request": {
        "name": "UpdateScheduleTransfers",
        "description": {
          "content": "Update the scheduled transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateScheduleTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Scheduled transfer updated successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteScheduleTransfers",
      "request": {
        "name": "DeleteScheduleTransfers",
        "description": {
          "content": "Delete the scheduled transfer",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteScheduleTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Scheduled transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteScheduleTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteScheduleTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Scheduled transfer deleted successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "AddRecurringTransfers",
      "request": {
        "name": "AddRecurringTransfers",
        "description": {
          "content": "Adds the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "AddRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer added successfully",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "AddRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"status\": \"{{status_*string}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        }\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for AddRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer added successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetRecurringTransfers",
      "request": {
        "name": "GetRecurringTransfers",
        "description": {
          "content": "Fetches all the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 7045.9416554111785,\n    \"Amount\": 4463.684713671913,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 4736.795405007694,\n    \"recurringOptions\": {\n      \"amountType\": \"string\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"string\",\n          \"untilDate\": \"string\",\n          \"numberOfPayments\": \"string\"\n        },\n        \"iterate\": \"string\"\n      }\n    },\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 5184.898285306532,\n    \"Amount\": 2050.6412063685507,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"ScheduledDate\": 3663.693951715539,\n    \"recurringOptions\": {\n      \"amountType\": \"string\",\n      \"frequency\": {\n        \"duration\": {\n          \"untilStop\": \"string\",\n          \"untilDate\": \"string\",\n          \"numberOfPayments\": \"string\"\n        },\n        \"iterate\": \"string\"\n      }\n    },\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: ScheduledDate\n\n              pm.test(`'item field has ScheduledDate that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`ScheduledDate`)) {\n                  const value = item?.ScheduledDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: recurringOptions\n\n              pm.test(`'item field has recurringOptions that is of type object'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`recurringOptions`)) {\n                  const value = item?.recurringOptions;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions\n              // subKey: amountType\n\n              pm.test(`'item.recurringOptions field has amountType that is of type string'`, function() {\n                let parent = item.recurringOptions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`amountType`)) {\n                  const value = item.recurringOptions?.amountType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions\n              // subKey: frequency\n\n              pm.test(`'item.recurringOptions field has frequency that is of type object'`, function() {\n                let parent = item.recurringOptions;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`frequency`)) {\n                  const value = item.recurringOptions?.frequency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency\n              // subKey: duration\n\n              pm.test(`'item.recurringOptions.frequency field has duration that is of type object'`, function() {\n                let parent = item.recurringOptions.frequency;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`duration`)) {\n                  const value = item.recurringOptions.frequency?.duration;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"object\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: untilStop\n\n              pm.test(`'item.recurringOptions.frequency.duration field has untilStop that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`untilStop`)) {\n                  const value = item.recurringOptions.frequency.duration?.untilStop;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: untilDate\n\n              pm.test(`'item.recurringOptions.frequency.duration field has untilDate that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`untilDate`)) {\n                  const value = item.recurringOptions.frequency.duration?.untilDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency.duration\n              // subKey: numberOfPayments\n\n              pm.test(`'item.recurringOptions.frequency.duration field has numberOfPayments that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency.duration;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`numberOfPayments`)) {\n                  const value = item.recurringOptions.frequency.duration?.numberOfPayments;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item.recurringOptions.frequency\n              // subKey: iterate\n\n              pm.test(`'item.recurringOptions.frequency field has iterate that is of type string'`, function() {\n                let parent = item.recurringOptions.frequency;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`iterate`)) {\n                  const value = item.recurringOptions.frequency?.iterate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "UpdateRecurringTransfers",
      "request": {
        "name": "UpdateRecurringTransfers",
        "description": {
          "content": "Update the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "UpdateRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"amount\": \"{{amount_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"duration\": {\n                \"untilStop\": \"{{recurringOptions.frequency.duration.untilStop_*string}}\",\n                \"untilDate\": \"{{recurringOptions.frequency.duration.untilDate_*number}}\",\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            },\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\"\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer updated successfully",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "UpdateRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"recurringOptions\": {\n        \"amountType\": \"{{recurringOptions.amountType_*string}}\",\n        \"frequency\": {\n            \"iterate\": \"{{recurringOptions.frequency.iterate_*string}}\",\n            \"duration\": {\n                \"numberOfTransfers\": \"{{recurringOptions.frequency.duration.numberOfTransfers_*number}}\"\n            }\n        },\n        \"updateTransferType\": \"{{recurringOptions.updateTransferType_*string}}\"\n    },\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\",\n    \"targetAccountId\": \"{{targetAccountId_*number}}\",\n    \"scheduledDate\": \"{{scheduledDate_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for UpdateRecurringTransfers for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Recurring transfer updated successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "DeleteRecurringTransfers",
      "request": {
        "name": "DeleteRecurringTransfers",
        "description": {
          "content": "Delete the recurring transfers",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "DeleteRecurringTransfers"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "key": "userCode",
            "value": "{{userCode}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Recurring transfer deleted successfully",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "DeleteRecurringTransfers"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "key": "userCode",
                "value": "{{userCode}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"paymentId\": \"{{paymentId_*string}}\",\n    \"updateTransferType\": \"{{updateTransferType_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for DeleteRecurringTransfers for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Recurring transfer deleted successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "resetPassword",
      "request": {
        "name": "resetPassword",
        "description": {
          "content": "It allows to reset the password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "resetPassword"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"password\": \"{{password_*string}}\",\n    \"username\": \"{{username_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "password has been updated successfully.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "resetPassword"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"password\": \"{{password_*number}}\",\n    \"username\": \"{{username_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for resetPassword for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"password has been updated successfully.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "debitcardInfoValidation",
      "request": {
        "name": "debitcardInfoValidation",
        "description": {
          "content": "for validating card info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "debitcardInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*string}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*string}}\",\n    \"expiryDate\": \"{{expiryDate_*string}}\",\n    \"pin\": \"{{pin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "debitcardInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cvv\": \"{{cvv_*number}}\",\n    \"debitCardNumber\": \"{{debitCardNumber_*number}}\",\n    \"expiryDate\": \"{{expiryDate_*date}}\",\n    \"pin\": \"{{pin_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for debitcardInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Validated Successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "personalInfoValidation",
      "request": {
        "name": "personalInfoValidation",
        "description": {
          "content": "for validating personal info",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "personalInfoValidation"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*string}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*string}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Validated Successfully",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "personalInfoValidation"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dob\": \"{{dob_*date}}\",\n    \"ssn\": \"{{ssn_*number}}\",\n    \"secrectPassword\": \"{{secrectPassword_*string}}\",\n    \"AccNumber\": \"{{AccNumber_*number}}\",\n    \"lastDepositAmt\": \"{{lastDepositAmt_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for personalInfoValidation for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Validated Successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "disputeTransaction",
      "request": {
        "name": "disputeTransaction",
        "description": {
          "content": "dispute a transaction",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "disputeTransaction"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Dispute Transactions reported successfully",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "disputeTransaction"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"transactionsData\": [\n        {\n            \"reasonCode\": \"{{transactionsData_0.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_0.transactionId_*number}}\"\n        },\n        {\n            \"reasonCode\": \"{{transactionsData_1.reasonCode_*string}}\",\n            \"transactionId\": \"{{transactionsData_1.transactionId_*number}}\"\n        }\n    ],\n    \"emailId\": \"{{emailId_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for disputeTransaction for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Dispute Transactions reported successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "ccPay",
      "request": {
        "name": "ccPay",
        "description": {
          "content": "to pay cc bill",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "ccPay"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "Credit Card payment scheduled successfully",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "ccPay"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"amount\": \"{{amount_*number}}\",\n    \"currency\": \"{{currency_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"dueDate\": \"{{dueDate_*string}}\",\n    \"sourceAccountId\": \"{{sourceAccountId_*string}}\",\n    \"targetAccountId\": \"{{targetAccountId_*string}}\",\n    \"transactionType\": \"{{transactionType_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for ccPay for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"Credit Card payment scheduled successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "GetCCSchedule",
      "request": {
        "name": "GetCCSchedule",
        "description": {
          "content": "Fetch cc payment list",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "GetCCSchedule"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "schedule transfer list response",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 4329.061922373991,\n    \"Amount\": 4393.682682654449,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"id\": \"string\"\n  },\n  {\n    \"Type\": \"string\",\n    \"CustomerId\": 1607.909384320263,\n    \"Amount\": 7244.361005993874,\n    \"SourceAccountNumber\": \"string\",\n    \"TargetAccountNumber\": \"string\",\n    \"DueDate\": \"string\",\n    \"Currency\": \"string\",\n    \"Status\": \"string\",\n    \"id\": \"string\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "GetCCSchedule"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"status\": \"{{status_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for GetCCSchedule for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"schedule transfer list response\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Type\n\n              pm.test(`'item field has Type that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Type`)) {\n                  const value = item?.Type;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: CustomerId\n\n              pm.test(`'item field has CustomerId that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`CustomerId`)) {\n                  const value = item?.CustomerId;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Amount\n\n              pm.test(`'item field has Amount that is of type number'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Amount`)) {\n                  const value = item?.Amount;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"number\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: SourceAccountNumber\n\n              pm.test(`'item field has SourceAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`SourceAccountNumber`)) {\n                  const value = item?.SourceAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: TargetAccountNumber\n\n              pm.test(`'item field has TargetAccountNumber that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`TargetAccountNumber`)) {\n                  const value = item?.TargetAccountNumber;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: DueDate\n\n              pm.test(`'item field has DueDate that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`DueDate`)) {\n                  const value = item?.DueDate;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Currency\n\n              pm.test(`'item field has Currency that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Currency`)) {\n                  const value = item?.Currency;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: Status\n\n              pm.test(`'item field has Status that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`Status`)) {\n                  const value = item?.Status;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: id\n\n              pm.test(`'item field has id that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`id`)) {\n                  const value = item?.id;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendsecuremessage",
      "request": {
        "name": "sendsecuremessage",
        "description": {
          "content": "send secure message",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendsecuremessage"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendsecuremessage"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"authType\": \"{{authType_*string}}\",\n    \"firstName\": \"{{firstName_*string}}\",\n    \"lastName\": \"{{lastName_*string}}\",\n    \"email\": \"{{email_*string}}\",\n    \"phoneNumber\": \"{{phoneNumber_*number}}\",\n    \"topic\": \"{{topic_*string}}\",\n    \"message\": \"{{message_*string}}\",\n    \"availableTime\": \"{{availableTime_*string}}\",\n    \"chatHistory\": \"{{chatHistory_*string}}\",\n    \"cif\": \"{{cif_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendsecuremessage for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "locateProfile",
      "request": {
        "name": "locateProfile",
        "description": {
          "content": "get profile details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "locateProfile"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"accountNumber\": \"string\",\n  \"cardDetails\": {\n    \"cardNumber\": \"string\",\n    \"expiryDate\": \"string\",\n    \"cvv\": \"string\",\n    \"pin\": \"string\"\n  },\n  \"personalQuestions\": {\n    \"DOB\": \"string\",\n    \"SSN\": 2061.887477508546,\n    \"SecretPassword\": \"string\",\n    \"LDAmount\": 9262.05497153029,\n    \"AccNumber\": \"string\"\n  },\n  \"ssNumber\": 8110.512806464442,\n  \"ssnShort\": 5561.816247489859,\n  \"alternatePhoneNumber\": 8021.324873356097,\n  \"customerId\": \"string\",\n  \"email\": \"string\",\n  \"identificationNumber\": \"string\",\n  \"identificationType\": \"string\",\n  \"image\": \"string\",\n  \"isAlternateMobileNumber\": false,\n  \"isPrimaryMobileNumber\": true,\n  \"location\": \"string\",\n  \"name\": \"string\",\n  \"personalBanker\": {\n    \"name\": \"string\",\n    \"email\": \"string\",\n    \"mobileNumber\": \"string\"\n  },\n  \"phone\": 3730.3129378808662,\n  \"securityQuestions\": [\n    \"string\",\n    \"string\"\n  ],\n  \"segmentId\": 1410.5194886231698,\n  \"multiAccounts\": [\n    {\n      \"accountNumber\": \"string\",\n      \"cardDetails\": {\n        \"cardNumber\": \"string\",\n        \"expiryDate\": \"string\",\n        \"cvv\": \"string\",\n        \"pin\": \"string\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"string\",\n        \"SSN\": 9447.049477832821,\n        \"SecretPassword\": \"string\",\n        \"LDAmount\": 9769.184363226086,\n        \"AccNumber\": \"string\"\n      },\n      \"ssNumber\": 5275.370199958446,\n      \"ssnShort\": 5736.9275186061,\n      \"alternatePhoneNumber\": 542.7106276968008,\n      \"customerId\": \"string\",\n      \"email\": \"string\",\n      \"identificationNumber\": \"string\",\n      \"identificationType\": \"string\",\n      \"location\": \"string\",\n      \"name\": \"string\",\n      \"phone\": 6442.974182111805\n    },\n    {\n      \"accountNumber\": \"string\",\n      \"cardDetails\": {\n        \"cardNumber\": \"string\",\n        \"expiryDate\": \"string\",\n        \"cvv\": \"string\",\n        \"pin\": \"string\"\n      },\n      \"personalQuestions\": {\n        \"DOB\": \"string\",\n        \"SSN\": 7480.306045260059,\n        \"SecretPassword\": \"string\",\n        \"LDAmount\": 8448.477693972907,\n        \"AccNumber\": \"string\"\n      },\n      \"ssNumber\": 7194.437747990605,\n      \"ssnShort\": 6531.336126846425,\n      \"alternatePhoneNumber\": 2374.710600368746,\n      \"customerId\": \"string\",\n      \"email\": \"string\",\n      \"identificationNumber\": \"string\",\n      \"identificationType\": \"string\",\n      \"location\": \"string\",\n      \"name\": \"string\",\n      \"phone\": 9635.452127027162\n    }\n  ],\n  \"warningCodes\": [\n    {\n      \"code\": 7166.541879381616,\n      \"level\": \"string\",\n      \"description\": \"string\"\n    },\n    {\n      \"code\": 9192.733996304458,\n      \"level\": \"string\",\n      \"description\": \"string\"\n    }\n  ]\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "locateProfile"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*string}}\",\n    \"ssNumber\": \"{{ssNumber_*string}}\",\n    \"ssnShort\": \"{{ssnShort_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for locateProfile for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: accountNumber\n\n        pm.test(`'responseData field has accountNumber that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`accountNumber`)) {\n            const value = responseData?.accountNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: cardDetails\n\n        pm.test(`'responseData field has cardDetails that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cardDetails`)) {\n            const value = responseData?.cardDetails;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: cardNumber\n\n        pm.test(`'responseData.cardDetails field has cardNumber that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n            const value = responseData.cardDetails?.cardNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: expiryDate\n\n        pm.test(`'responseData.cardDetails field has expiryDate that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`expiryDate`)) {\n            const value = responseData.cardDetails?.expiryDate;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: cvv\n\n        pm.test(`'responseData.cardDetails field has cvv that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`cvv`)) {\n            const value = responseData.cardDetails?.cvv;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.cardDetails\n        // subKey: pin\n\n        pm.test(`'responseData.cardDetails field has pin that is of type string'`, function() {\n          let parent = responseData.cardDetails;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`pin`)) {\n            const value = responseData.cardDetails?.pin;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalQuestions\n\n        pm.test(`'responseData field has personalQuestions that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalQuestions`)) {\n            const value = responseData?.personalQuestions;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: DOB\n\n        pm.test(`'responseData.personalQuestions field has DOB that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`DOB`)) {\n            const value = responseData.personalQuestions?.DOB;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: SSN\n\n        pm.test(`'responseData.personalQuestions field has SSN that is of type number'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`SSN`)) {\n            const value = responseData.personalQuestions?.SSN;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: SecretPassword\n\n        pm.test(`'responseData.personalQuestions field has SecretPassword that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`SecretPassword`)) {\n            const value = responseData.personalQuestions?.SecretPassword;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: LDAmount\n\n        pm.test(`'responseData.personalQuestions field has LDAmount that is of type number'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`LDAmount`)) {\n            const value = responseData.personalQuestions?.LDAmount;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalQuestions\n        // subKey: AccNumber\n\n        pm.test(`'responseData.personalQuestions field has AccNumber that is of type string'`, function() {\n          let parent = responseData.personalQuestions;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`AccNumber`)) {\n            const value = responseData.personalQuestions?.AccNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ssNumber\n\n        pm.test(`'responseData field has ssNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ssNumber`)) {\n            const value = responseData?.ssNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: ssnShort\n\n        pm.test(`'responseData field has ssnShort that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`ssnShort`)) {\n            const value = responseData?.ssnShort;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: alternatePhoneNumber\n\n        pm.test(`'responseData field has alternatePhoneNumber that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`alternatePhoneNumber`)) {\n            const value = responseData?.alternatePhoneNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: customerId\n\n        pm.test(`'responseData field has customerId that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`customerId`)) {\n            const value = responseData?.customerId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: email\n\n        pm.test(`'responseData field has email that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationNumber\n\n        pm.test(`'responseData field has identificationNumber that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationNumber`)) {\n            const value = responseData?.identificationNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: identificationType\n\n        pm.test(`'responseData field has identificationType that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`identificationType`)) {\n            const value = responseData?.identificationType;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: image\n\n        pm.test(`'responseData field has image that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`image`)) {\n            const value = responseData?.image;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isAlternateMobileNumber\n\n        pm.test(`'responseData field has isAlternateMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isAlternateMobileNumber`)) {\n            const value = responseData?.isAlternateMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: isPrimaryMobileNumber\n\n        pm.test(`'responseData field has isPrimaryMobileNumber that is of type boolean'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`isPrimaryMobileNumber`)) {\n            const value = responseData?.isPrimaryMobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"boolean\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: location\n\n        pm.test(`'responseData field has location that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`location`)) {\n            const value = responseData?.location;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: name\n\n        pm.test(`'responseData field has name that is of type string'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: personalBanker\n\n        pm.test(`'responseData field has personalBanker that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`personalBanker`)) {\n            const value = responseData?.personalBanker;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: name\n\n        pm.test(`'responseData.personalBanker field has name that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`name`)) {\n            const value = responseData.personalBanker?.name;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: email\n\n        pm.test(`'responseData.personalBanker field has email that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`email`)) {\n            const value = responseData.personalBanker?.email;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.personalBanker\n        // subKey: mobileNumber\n\n        pm.test(`'responseData.personalBanker field has mobileNumber that is of type string'`, function() {\n          let parent = responseData.personalBanker;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`mobileNumber`)) {\n            const value = responseData.personalBanker?.mobileNumber;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: phone\n\n        pm.test(`'responseData field has phone that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`phone`)) {\n            const value = responseData?.phone;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'securityQuestions' as type array'`, function() {\n          const value = responseData?.securityQuestions;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: segmentId\n\n        pm.test(`'responseData field has segmentId that is of type number'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`segmentId`)) {\n            const value = responseData?.segmentId;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"number\");\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'multiAccounts' as type array'`, function() {\n          const value = responseData?.multiAccounts;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.multiAccounts field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`multiAccounts`)) {\n            let multiAccountsArray = ld.get(responseData, `multiAccounts`, []);\n            if (Array.isArray(multiAccountsArray)) {\n              for (let multiAccounts_it = 0; multiAccounts_it < multiAccountsArray.length; multiAccounts_it++) {\n                let iterator = multiAccounts_it;\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'accountNumber' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.accountNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'cardDetails' as type 'object'`, function() {\n                    const value = multiAccountsArray[iterator]?.cardDetails;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: cardNumber\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has cardNumber that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`cardNumber`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.cardNumber;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.cardNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: expiryDate\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has expiryDate that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`expiryDate`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.expiryDate;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.expiryDate`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: cvv\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has cvv that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`cvv`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.cvv;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.cvv`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].cardDetails\n                  // subKey: pin\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].cardDetails field has pin that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].cardDetails;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`pin`)) {\n                      const value = multiAccountsArray[iterator].cardDetails?.pin;\n                      console.log(`multiAccountsArray[iterator].cardDetails?.pin`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'personalQuestions' as type 'object'`, function() {\n                    const value = multiAccountsArray[iterator]?.personalQuestions;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"object\");\n                    }\n                  })\n\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: DOB\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has DOB that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`DOB`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.DOB;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.DOB`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: SSN\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has SSN that is of type number'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`SSN`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.SSN;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.SSN`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: SecretPassword\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has SecretPassword that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`SecretPassword`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.SecretPassword;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.SecretPassword`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: LDAmount\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has LDAmount that is of type number'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`LDAmount`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.LDAmount;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.LDAmount`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"number\");\n                      }\n                    }\n                  })\n\n                  // Condition: Raw data type, got arrayName and parent property is not an array\n                  // pathStr: multiAccountsArray[${iterator}].personalQuestions\n                  // subKey: AccNumber\n                  // array: multiAccountsArray\n\n\n                  pm.test(`'multiAccountsArray[${iterator}].personalQuestions field has AccNumber that is of type string'`, function() {\n                    let parent = multiAccountsArray[iterator].personalQuestions;\n                    // console.log(parent);\n                    if (pm.expect(parent).to.have.nested.property(`AccNumber`)) {\n                      const value = multiAccountsArray[iterator].personalQuestions?.AccNumber;\n                      console.log(`multiAccountsArray[iterator].personalQuestions?.AccNumber`, value);\n\n                      if (!ld.isEmpty(value)) {\n                        pm.expect(typeof value).to.equal(\"string\");\n                      }\n                    }\n                  })\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'ssNumber' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.ssNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'ssnShort' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.ssnShort;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'alternatePhoneNumber' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.alternatePhoneNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'customerId' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.customerId;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'email' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.email;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'identificationNumber' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.identificationNumber;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'identificationType' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.identificationType;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'location' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.location;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'name' as type 'string'`, function() {\n                    const value = multiAccountsArray[iterator]?.name;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (multiAccountsArray[multiAccounts_it] !== null && multiAccountsArray[multiAccounts_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at multiAccountsArray[${iterator}]' has 'phone' as type 'number'`, function() {\n                    const value = multiAccountsArray[iterator]?.phone;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n        // array condition without arrayName and parent property is an array\n        pm.test(`'responseData has 'warningCodes' as type array'`, function() {\n          const value = responseData?.warningCodes;\n\n          if (value !== null && value !== undefined) {\n            pm.expect(Array.isArray(value)).to.equal(true);\n          }\n\n        })\n\n\n        pm.test(`Each object in the responseData.warningCodes field has all the required fields and correct data-types`, function() {\n          if (pm.expect(responseData).to.have.nested.property(`warningCodes`)) {\n            let warningCodesArray = ld.get(responseData, `warningCodes`, []);\n            if (Array.isArray(warningCodesArray)) {\n              for (let warningCodes_it = 0; warningCodes_it < warningCodesArray.length; warningCodes_it++) {\n                let iterator = warningCodes_it;\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'code' as type 'number'`, function() {\n                    const value = warningCodesArray[iterator]?.code;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"number\");\n                    }\n                  })\n\n\n                }\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'level' as type 'string'`, function() {\n                    const value = warningCodesArray[iterator]?.level;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n                if (warningCodesArray[warningCodes_it] !== null && warningCodesArray[warningCodes_it] !== undefined) {\n\n                  // Condition: Raw data type with defined arrayName and parent property is an array\n                  pm.test(`'Item at warningCodesArray[${iterator}]' has 'description' as type 'string'`, function() {\n                    const value = warningCodesArray[iterator]?.description;\n\n                    if (!ld.isEmpty(value)) {\n                      pm.expect(typeof value).to.equal(\"string\");\n                    }\n                  })\n\n\n                }\n              }\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the exiting user",
      "request": {
        "name": "to validate the exiting user",
        "description": {
          "content": "to validate the in of existing user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validateUser"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validateUser"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validateUser for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PINs matched\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate the pins entered by the new user",
      "request": {
        "name": "to validate the pins entered by the new user",
        "description": {
          "content": "to validate the pins entered by the new user",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePIN"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PINs matched",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePIN"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\",\n    \"targetPin\": \"{{targetPin_*string}}\",\n    \"profileInfo\": {\n        \"customerId\": \"{{profileInfo.customerId_*string}}\",\n        \"accountNumber\": \"{{profileInfo.accountNumber_*string}}\",\n        \"ssn\": \"{{profileInfo.ssn_*string}}\"\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePIN for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PINs matched\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to validate if pin entered by new user follows pin rules",
      "request": {
        "name": "to validate if pin entered by new user follows pin rules",
        "description": {
          "content": "to validate if pin entered by new user follows pin rules",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "validatePINRules"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "PIN rules satisfied",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "validatePINRules"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"sourcePin\": \"{{sourcePin_*string}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for validatePINRules for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"PIN rules satisfied\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the account closure status",
      "request": {
        "name": "to fetch the account closure status",
        "description": {
          "content": "to fetch the account closure status",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "getRequestStatus"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "getRequestStatus"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "[\n    {\n        \"accountName\": \"{{_0.accountName_*string}}\",\n        \"accountNumber\": \"{{_0.accountNumber_*string}}\",\n        \"customerId\": \"{{_0.customerId_*number}}\",\n        \"description\": \"{{_0.description_*string}}\",\n        \"estimation\": \"{{_0.estimation_*number}}\",\n        \"modifyDate\": \"{{_0.modifyDate_*number}}\",\n        \"requestDate\": \"{{_0.requestDate_*number}}\",\n        \"requestId\": \"{{_0.requestId_*string}}\",\n        \"requestSubType\": \"{{_0.requestSubType_*string}}\",\n        \"requestType\": \"{{_0.requestType_*string}}\",\n        \"status\": \"{{_0.status_*string}}\"\n    },\n    {\n        \"accountName\": \"{{_1.accountName_*string}}\",\n        \"accountNumber\": \"{{_1.accountNumber_*string}}\",\n        \"customerId\": \"{{_1.customerId_*number}}\",\n        \"description\": \"{{_1.description_*string}}\",\n        \"estimation\": \"{{_1.estimation_*number}}\",\n        \"modifyDate\": \"{{_1.modifyDate_*number}}\",\n        \"requestDate\": \"{{_1.requestDate_*number}}\",\n        \"requestId\": \"{{_1.requestId_*string}}\",\n        \"requestSubType\": \"{{_1.requestSubType_*string}}\",\n        \"requestType\": \"{{_1.requestType_*string}}\",\n        \"status\": \"{{_1.status_*string}}\"\n    }\n]",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for getRequestStatus for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to place the request",
      "request": {
        "name": "to place the request",
        "description": {
          "content": "to place the request",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "request"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*string}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "request"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"accountName\": \"{{accountName_*string}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"cardNumber\": \"{{cardNumber_*number}}\",\n    \"description\": \"{{description_*string}}\",\n    \"requestSubType\": \"{{requestSubType_*string}}\",\n    \"serviceType\": \"{{serviceType_*string}}\",\n    \"requestType\": \"{{requestType_*string}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for request for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to enable or disable e or paper statements at profile level",
      "request": {
        "name": "to enable or disable e or paper statements at profile level",
        "description": {
          "content": "to enable or disable e or paper statements at profile level",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "enableEStatement"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "enableEStatement"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"email\": \"{{email_*string}}\",\n    \"secondaryEmail\": \"{{secondaryEmail_*string}}\",\n    \"subscribe\": \"{{subscribe_*boolean}}\",\n    \"meta\": {}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for enableEStatement for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to update the cheque book details of customer accounts",
      "request": {
        "name": "to update the cheque book details of customer accounts",
        "description": {
          "content": "Update customer cheque book details",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "RequestChequeBook"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "botId",
            "value": "{{botId}}"
          },
          {
            "disabled": false,
            "description": "(Required)",
            "key": "accountId",
            "value": "{{accountId}}"
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "PUT",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"accountNumber\": \"{{accountNumber_*string}}\",\n    \"customerId\": \"{{customerId_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "successful operation",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "RequestChequeBook"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "botId",
                "value": "{{botId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "accountId",
                "value": "{{accountId}}"
              },
              {
                "disabled": false,
                "description": "(Required)",
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\",\n    \"accountNumber\": \"{{accountNumber_*number}}\",\n    \"numberOfChequeBooks\": \"{{numberOfChequeBooks_*number}}\",\n    \"numberOfLeaves\": \"{{numberOfLeaves_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for RequestChequeBook for http method type put in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"successful operation\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "sendOTP",
      "request": {
        "name": "sendOTP",
        "description": {
          "content": "sends OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "sendOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "verification code has been sent to your mobile number",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "sendOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for sendOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"verification code has been sent to your mobile number\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "verifyOTP",
      "request": {
        "name": "verifyOTP",
        "description": {
          "content": "to verify OTP for reset password",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "verifyOTP"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "OTP verifid successfully",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "text/plain"
            }
          ],
          "body": "",
          "cookie": [],
          "_postman_previewlanguage": "text"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "verifyOTP"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"code\": \"{{code_*number}}\",\n    \"customerId\": \"{{customerId_*number}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for verifyOTP for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"OTP verifid successfully\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    },
    {
      "name": "to fetch the deeplink",
      "request": {
        "name": "to fetch the deeplink",
        "description": {
          "content": "to fetch the deeplink",
          "type": "text/plain"
        },
        "url": {
          "path": [
            "deeplink"
          ],
          "host": [
            "{{baseUrl}}"
          ],
          "query": [],
          "variable": []
        },
        "header": [
          {
            "disabled": false,
            "key": "koreUserId",
            "value": "{{koreUserId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "botId",
            "value": "{{botId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "accountId",
            "value": "{{accountId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "tenantId",
            "value": "{{tenantId}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "environment",
            "value": "{{environment}}",
            "description": ""
          },
          {
            "disabled": false,
            "key": "channel",
            "value": "{{channel}}",
            "description": ""
          },
          {
            "key": "Content-Type",
            "value": "application/json"
          },
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "method": "POST",
        "auth": null,
        "body": {
          "mode": "raw",
          "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        }
      },
      "response": [
        {
          "name": "success",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "OK",
          "code": 200,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "[\n  {\n    \"usecase\": \"addbeneficiary\",\n    \"link\": \"www.google.com\",\n    \"linkType\": \"deeplink\"\n  }\n]",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Authorisation failed.",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Unauthorized",
          "code": 401,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        },
        {
          "name": "Error: Not Found",
          "originalRequest": {
            "url": {
              "path": [
                "deeplink"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "description": {
                  "content": "Added as a part of security scheme: bearer",
                  "type": "text/plain"
                },
                "key": "Authorization",
                "value": "{{Authorization}}"
              },
              {
                "disabled": false,
                "key": "koreUserId",
                "value": "{{koreUserId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "botId",
                "value": "{{botId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "accountId",
                "value": "{{accountId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "tenantId",
                "value": "{{tenantId}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "Authorization",
                "value": "{{Authorization}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "environment",
                "value": "{{environment}}",
                "description": ""
              },
              {
                "disabled": false,
                "key": "channel",
                "value": "{{channel}}",
                "description": ""
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n    \"usecase\": [\n        \"{{usecase_0_*string}}\",\n        \"{{usecase_1_*string}}\"\n    ]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "status": "Not Found",
          "code": 404,
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            }
          ],
          "body": "{\n  \"err\": {\n    \"message\": \"string\"\n  }\n}",
          "cookie": [],
          "_postman_previewlanguage": "json"
        }
      ],
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ********RoostGPT********\n/*\nTest generated by RoostGPT for test pw-api-openai-github-1763639890489 using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for deeplink for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif (contentType === \"application/xml\") {\n  var parseString = require('xml2js').parseString;\n  parseString(pm.response.body, function(err, result) {\n    if (err) {\n      console.error('Error parsing XML:', err);\n    } else {\n      responseData = result;\n    }\n  });\n} else {\n  responseData = pm.response.json();\n}\n// Status code check with early exit\nconst expectedStatusCode = parseInt(pm.variables.get(\"statusCode\"));\nlet statusMatches = true;\nif (pm.variables.get(\"statusCode\")) {\n  statusMatches = (pm.response.code === expectedStatusCode);\n  pm.test(\"Status code matches expected value\", function() {\n    pm.expect(pm.response.code).to.equal(expectedStatusCode);\n  });\n}\n\nif (pm.response.code == 200 && statusMatches) {\n  pm.test(\"success\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"OK\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        if (Array.isArray(responseData)) {\n          responseData.forEach((item, index) => {\n            if (item !== null && item !== undefined) {\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: usecase\n\n              pm.test(`'item field has usecase that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`usecase`)) {\n                  const value = item?.usecase;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: link\n\n              pm.test(`'item field has link that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`link`)) {\n                  const value = item?.link;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n              // Condition: Raw data type and parent property is not an array\n              // pathStr: item\n              // subKey: linkType\n\n              pm.test(`'item field has linkType that is of type string'`, function() {\n                let parent = item;\n                // console.log(parent);\n                if (pm.expect(parent).to.have.nested.property(`linkType`)) {\n                  const value = item?.linkType;\n                  console.log(`{pathStr}?.{subKey}`, value);\n\n                  if (!ld.isEmpty(value)) {\n                    pm.expect(typeof value).to.equal(\"string\");\n                  }\n                }\n              })\n\n            }\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 401 && statusMatches) {\n  pm.test(\"Error: Authorisation failed.\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}\nif (pm.response.code == 404 && statusMatches) {\n  pm.test(\"Error: Not Found\", function() {\n    pm.expect(pm.response.status).to.be.eql(\"Not Found\");\n    try {\n      if (responseData !== null && responseData !== undefined) {\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData\n        // subKey: err\n\n        pm.test(`'responseData field has err that is of type object'`, function() {\n          let parent = responseData;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`err`)) {\n            const value = responseData?.err;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"object\");\n            }\n          }\n        })\n\n        // Condition: Raw data type and parent property is not an array\n        // pathStr: responseData.err\n        // subKey: message\n\n        pm.test(`'responseData.err field has message that is of type string'`, function() {\n          let parent = responseData.err;\n          // console.log(parent);\n          if (pm.expect(parent).to.have.nested.property(`message`)) {\n            const value = responseData.err?.message;\n            console.log(`{pathStr}?.{subKey}`, value);\n\n            if (!ld.isEmpty(value)) {\n              pm.expect(typeof value).to.equal(\"string\");\n            }\n          }\n        })\n\n      }\n    } catch (error) {\n      console.error('Error during response validation:', error.message);\n    }\n  });\n\n}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      }
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://localhost:8080/smt",
      "key": "baseUrl"
    },
    {
      "type": "number",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{bearerToken}}"
      }
    ]
  },
  "info": {
    "_postman_id": "0ea83a95-8823-445b-8876-3f25e455fa0b",
    "name": "BankAssist SMT Core Banking API Specification",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "kore.ai banking bot apis.",
      "type": "text/plain"
    }
  }
}